{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IOTStack Wiki","text":"<p>What is IOTstack</p> <p>IOTstack is a builder for docker-compose to easily make and maintain IoT stacks on the Raspberry Pi</p> <p>Welcome to IOTstack:</p> <ul> <li> <p>   Use the top tabs and then the left list to explore this Wiki.       Click the \"\u2261\" icon to navigate this Wiki.   </p> </li> <li> <p>If you are just getting started with IOTstack, see Getting Started.</p> <ul> <li>For latest changes, see Changelog.</li> <li>If you're running gcgarner/IOTstack see Migrating to SensorsIot.</li> </ul> </li> <li> <p>You're always welcome to ask questions on the IOTStack Discord.</p> </li> <li> <p>Fixes and improvements welcome, see Contributing</p> </li> </ul> <p>Full site page listing</p> <p>{nav}</p>"},{"location":"Basic_setup/","title":"Getting Started","text":""},{"location":"Basic_setup/#conventions","title":"About IOTstack","text":"<p>IOTstack is not a system. It is a set of conventions for assembling arbitrary collections of containers into something that has a reasonable chance of working out-of-the-box. The three most important conventions are:</p> <ol> <li> <p>If a container needs information to persist across restarts (and most containers do) then the container's persistent store will be found at:</p> <pre><code>~/IOTstack/volumes/\u00abcontainer\u00bb\n</code></pre> <p>Most service definitions examples found on the web have a scattergun approach to this problem. IOTstack imposes order on this chaos.</p> </li> <li> <p>To the maximum extent possible, network port conflicts have been sorted out in advance.</p> <p>Sometimes this is not possible. For example, Pi-hole and AdGuardHome both offer Domain Name System services. The DNS relies on port 53. You can't have two containers claiming port 53 so the only way to avoid this is to pick either Pi-hole or AdGuardHome. 3. Where multiple containers are needed to implement a single user-facing service, the IOTstack service definition will include everything needed. A good example is NextCloud which relies on MariaDB. IOTstack implements MariaDB as a private instance which is only available to NextCloud. This strategy ensures that you are able to run your own separate MariaDB container without any risk of interference with your NextCloud service. </p> </li> </ol>"},{"location":"Basic_setup/#requirements","title":"Requirements","text":"<p>IOTstack makes the following assumptions:</p> <ol> <li> <p>Your hardware is capable of running Debian or one of its derivatives. Examples that are known to work include:</p> <ul> <li> <p>a Raspberry Pi (typically a 3B+ or 4B)</p> <p>The Raspberry Pi Zero W2 has been tested with IOTstack. It works but the 512MB RAM means you should not try to run too many containers concurrently.</p> </li> <li> <p>Orange Pi Win/Plus see also issue 375</p> </li> <li>an Intel-based Mac running macOS plus Parallels with a Debian guest.</li> <li>an Intel-based platform running Proxmox with a Debian guest.</li> </ul> </li> <li> <p>Your host or guest system is running a reasonably-recent version of Debian or an operating system which is downstream of Debian in the Linux family tree, such as Raspberry Pi OS (aka \"Raspbian\") or Ubuntu.</p> <p>IOTstack is known to work in 32-bit mode but not all containers have images on DockerHub that support 320bit mode. If you are setting up a new system from scratch, you should choose a 64-bit option.</p> <p>IOTstack was known to work with Buster but it has not been tested recently. Bullseye is known to work but if you are setting up a new system from scratch, you should choose Bookworm.</p> <p>Please don't waste your own time trying Linux distributions from outside the Debian family tree. They are unlikely to work.</p> </li> <li> <p>You are logged-in as the default user (ie not root). In most cases, this is the user with ID=1000 and is what you get by default on either a Raspberry Pi OS or Debian installation.</p> <p>This assumption is not really an IOTstack requirement as such. However, many containers assume UID=1000 exists and you are less likely to encounter issues if this assumption holds.</p> </li> </ol> <p>Please don't read these assumptions as saying that IOTstack will not run on other hardware, other operating systems, or as a different user. It is just that IOTstack gets most of its testing under these conditions. The further you get from these implicit assumptions, the more your mileage may vary.</p>"},{"location":"Basic_setup/#new-installation","title":"New installation","text":"<p>You have two choices:</p> <ol> <li>If you have an existing system and you want to add IOTstack to it, then the add-on method is your best choice.</li> <li>If you are setting up a new system from scratch, then PiBuilder is probably your best choice. You can, however, also use the add-on method in a green-fields installation.</li> </ol>"},{"location":"Basic_setup/#addonInstall","title":"add-on method","text":"<p>This method assumes an existing system rather than a green-fields installation. The script uses the principle of least interference. It only installs the bare minimum of prerequisites and, with the exception of adding some boot time options to your Raspberry Pi (but not any other kind of hardware), makes no attempt to tailor your system.</p> <p>To use this method:</p> <ol> <li> <p>Install <code>curl</code>:</p> <pre><code>$ sudo apt install -y curl\n</code></pre> </li> <li> <p>Run the following command:</p> <pre><code>$ curl -fsSL https://raw.githubusercontent.com/SensorsIot/IOTstack/master/install.sh | bash\n</code></pre> </li> </ol> <p>The <code>install.sh</code> script is designed to be run multiple times. If the script discovers a problem, it will explain how to fix that problem and, assuming you follow the instructions, you can safely re-run the script. You can repeat this process until the script completes normally.</p>"},{"location":"Basic_setup/#pibuilderInstall","title":"PiBuilder method","text":"<p>Compared with the add-on method, PiBuilder is far more comprehensive. PiBuilder:</p> <ol> <li>Does everything the add-on method does.</li> <li>Adds support packages and debugging tools that have proven useful in the IOTstack context.</li> <li>Installs all required system patches (see next section).</li> <li> <p>In addition to cloning IOTstack (this repository), PiBuilder also clones:</p> <ul> <li>IOTstackBackup which is an alternative to the backup script supplied with IOTstack but does not require your stack to be taken down to perform backups; and</li> <li>IOTstackAliases which provides shortcuts for common IOTstack operations.</li> </ul> </li> <li> <p>Performs extra tailoring intended to deliver a rock-solid platform for IOTstack.</p> </li> </ol> <p>PiBuilder does, however, assume a green fields system rather than an existing installation. Although the PiBuilder scripts will probably work on an existing system, that scenario has never been tested so it's entirely at your own risk. </p> <p>PiBuilder actually has two specific use-cases:</p> <ol> <li>A first-time build of a system to run IOTstack; and</li> <li>The ability to create your own customised version of PiBuilder so that you can quickly rebuild your Raspberry Pi or Proxmox guest after a disaster. Combined with IOTstackBackup, you can go from bare metal to a running system with data restored in about half an hour.</li> </ol>"},{"location":"Basic_setup/#required-system-patches","title":"Required system patches","text":"<p>You can skip this section if you used PiBuilder to construct your system. That's because PiBuilder installs all necessary patches automatically.</p> <p>If you used the add-on method, you should consider applying these patches by hand. Unless you know that a patch is not required, assume that it is needed.</p>"},{"location":"Basic_setup/#patch-1-restrict-dhcp","title":"patch 1 \u2013 restrict DHCP","text":"<p>Run the following commands:</p> <pre><code>$ sudo bash -c '[ $(egrep -c \"^allowinterfaces eth\\*,wlan\\*\" /etc/dhcpcd.conf) -eq 0 ] &amp;&amp; echo \"allowinterfaces eth*,wlan*\" &gt;&gt; /etc/dhcpcd.conf'\n</code></pre> <p>This patch prevents the <code>dhcpcd</code> daemon from trying to allocate IP addresses to Docker's <code>docker0</code> and <code>veth</code> interfaces. Docker assigns the IP addresses itself and <code>dhcpcd</code> trying to get in on the act can lead to a deadlock condition which can freeze your Pi.</p> <p>See Issue 219 and Issue 253 for more information.</p>"},{"location":"Basic_setup/#patch-2-update-libseccomp2","title":"patch 2 \u2013 update libseccomp2","text":"<p>This patch is ONLY for Raspbian Buster. Do NOT install this patch if you are running Raspbian Bullseye or Bookworm.</p> <ol> <li> <p>check your OS release</p> <p>Run the following command:</p> <pre><code>$ grep \"PRETTY_NAME\" /etc/os-release\nPRETTY_NAME=\"Raspbian GNU/Linux 10 (buster)\"\n</code></pre> <p>If you see the word \"buster\", proceed to step 2. Otherwise, skip this patch.</p> </li> <li> <p>if you are indeed running \"buster\"</p> <p>Without this patch on Buster, Docker images will fail if:</p> <ul> <li>the image is based on Alpine and the image's maintainer updates to Alpine 3.13; and/or</li> <li>an image's maintainer updates to a library that depends on 64-bit values for Unix epoch time (the so-called Y2038 problem).</li> </ul> <p>To install the patch:</p> <pre><code>$ sudo apt-key adv --keyserver hkps://keyserver.ubuntu.com:443 --recv-keys 04EE7237B7D453EC 648ACFD622F3D138\n$ echo \"deb http://httpredir.debian.org/debian buster-backports main contrib non-free\" | sudo tee -a \"/etc/apt/sources.list.d/debian-backports.list\"\n$ sudo apt update\n$ sudo apt install libseccomp2 -t buster-backports\n</code></pre> </li> </ol>"},{"location":"Basic_setup/#patch-3-kernel-control-groups","title":"patch 3 - kernel control groups","text":"<p>Kernel control groups need to be enabled in order to monitor container specific usage. This makes commands like <code>docker stats</code> fully work. Also needed for full monitoring of docker resource usage by the telegraf container.</p> <p>Enable by running (takes effect after reboot):</p> <pre><code>$ CMDLINE=\"/boot/firmware/cmdline.txt\" &amp;&amp; [ -e \"$CMDLINE\" ] || CMDLINE=\"/boot/cmdline.txt\"\n$ echo $(cat \"$CMDLINE\") cgroup_memory=1 cgroup_enable=memory | sudo tee \"$CMDLINE\"\n$ sudo reboot\n</code></pre>"},{"location":"Basic_setup/#iotstackMenu","title":"the IOTstack menu","text":"<p>The menu is used to construct your <code>docker-compose.yml</code> file. That file is read by <code>docker-compose</code> which issues the instructions necessary for starting your stack.</p> <p>The menu is a great way to get started quickly but it is only an aid. It is a good idea to learn the various <code>docker</code> and <code>docker-compose</code> commands so you can use them outside the menu. It is also a good idea to study the <code>docker-compose.yml</code> generated by the menu to see how everything is put together. You will gain a lot of flexibility if you learn how to add containers by hand.</p> <p>In essence, the menu is a concatenation tool which appends service definitions that exist inside the hidden <code>~/IOTstack/.templates</code> folder to your <code>docker-compose.yml</code>.</p> <p>Once you understand what the menu does (and, more importantly, what it doesn't do), you will realise that the real power of IOTstack lies not in its menu system but resides in its conventions.</p>"},{"location":"Basic_setup/#buildStack","title":"menu item: Build Stack","text":"<p>To create your first <code>docker-compose.yml</code>:</p> <pre><code>$ cd ~/IOTstack\n$ ./menu.sh\nSelect \"Build Stack\"\n</code></pre> <p>Follow the on-screen prompts and select the containers you need.</p> <p>The best advice we can give is \"start small\". Limit yourself to the core containers you actually need (eg Mosquitto, Node-RED, InfluxDB, Grafana, Portainer). You can always add more containers later. Some users have gone overboard with their initial selections and have run into what seem to be Raspberry Pi OS limitations.</p> <p>Key point:</p> <ul> <li>If you are running \"new menu\" (master branch) and you select Node-RED, you must press the right-arrow and choose at least one add-on node. If you skip this step, Node-RED will not build properly.</li> <li>Old menu forces you to choose add-on nodes for Node-RED.</li> </ul> <p>The process finishes by asking you to bring up the stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p>The first time you run <code>up</code> the stack docker will download all the images from DockerHub. How long this takes will depend on how many containers you selected and the speed of your internet connection.</p> <p>Some containers also need to be built locally. Node-RED is an example. Depending on the Node-RED nodes you select, building the image can also take a very long time. This is especially true if you select the SQLite node.</p> <p>Be patient (and, if you selected the SQLite node, ignore the huge number of warnings).</p>"},{"location":"Basic_setup/#menu-item-docker-commands","title":"menu item: Docker commands","text":"<p>The commands in this menu execute shell scripts in the root of the project.</p>"},{"location":"Basic_setup/#other-menu-items","title":"other menu items","text":"<p>The old and new menus differ in the options they offer. You should come back and explore them once your stack is built and running.</p>"},{"location":"Basic_setup/#useful-commands-docker-docker-compose","title":"useful commands: docker &amp; docker-compose","text":"<p>Handy rules:</p> <ul> <li><code>docker</code> commands can be executed from anywhere, but</li> <li><code>docker-compose</code> commands need to be executed from within <code>~/IOTstack</code></li> </ul>"},{"location":"Basic_setup/#starting-your-iotstack","title":"starting your IOTstack","text":"<p>To start the stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p>Once the stack has been brought up, it will stay up until you take it down. This includes shutdowns and reboots of your Raspberry Pi. If you do not want the stack to start automatically after a reboot, you need to stop the stack before you issue the reboot command.</p>"},{"location":"Basic_setup/#logging-journald-errors","title":"logging journald errors","text":"<p>If you get docker logging error like:</p> <pre><code>Cannot create container for service [service name here]: unknown log opt 'max-file' for journald log driver\n</code></pre> <ol> <li> <p>Run the command:</p> <pre><code>$ sudo nano /etc/docker/daemon.json\n</code></pre> </li> <li> <p>change:</p> <pre><code>\"log-driver\": \"journald\",\n</code></pre> <p>to:</p> <pre><code>\"log-driver\": \"json-file\",\n</code></pre> </li> </ol> <p>Logging limits were added to prevent Docker using up lots of RAM if log2ram is enabled, or SD cards being filled with log data and degraded from unnecessary IO. See Docker Logging configurations</p> <p>You can also turn logging off or set it to use another option for any service by using the IOTstack <code>docker-compose-override.yml</code> file mentioned at IOTstack/Custom.</p> <p>Another approach is to change <code>daemon.json</code> to be like this:</p> <pre><code>{\n  \"log-driver\": \"local\",\n  \"log-opts\": {\n    \"max-size\": \"1m\"\n  }\n}\n</code></pre> <p>The <code>local</code> driver is specifically designed to prevent disk exhaustion. Limiting log size to one megabyte also helps, particularly if you only have a limited amount of storage.</p> <p>If you are familiar with system logging where it is best practice to retain logs spanning days or weeks, you may feel that one megabyte is unreasonably small. However, before you rush to increase the limit, consider that each container is the equivalent of a small computer dedicated to a single task. By their very nature, containers tend to either work as expected or fail outright. That, in turn, means that it is usually only recent container logs showing failures as they happen that are actually useful for diagnosing problems.</p>"},{"location":"Basic_setup/#starting-an-individual-container","title":"starting an individual container","text":"<p>To start a particular container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d \u00abcontainer\u00bb\n</code></pre>"},{"location":"Basic_setup/#stopping-your-iotstack","title":"stopping your IOTstack","text":"<p>Stopping aka \"downing\" the stack stops and deletes all containers, and removes the internal network:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down\n</code></pre> <p>To stop the stack without removing containers, run:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop\n</code></pre>"},{"location":"Basic_setup/#stopping-an-individual-container","title":"stopping an individual container","text":"<p><code>stop</code> can also be used to stop individual containers, like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop \u00abcontainer\u00bb\n</code></pre> <p>This puts the container in a kind of suspended animation. You can resume the container with</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose start \u00abcontainer\u00bb\n</code></pre> <p>You can also <code>down</code> a container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down \u00abcontainer\u00bb\n</code></pre> <p>Note:</p> <ul> <li> <p>If the <code>down</code> command returns an error suggesting that you can't use it to down a container, it actually means that you have an obsolete version of <code>docker-compose</code>. You should upgrade your system. The workaround is to you the old syntax:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose rm --force --stop -v \u00abcontainer\u00bb\n</code></pre> </li> </ul> <p>To reactivate a container which has been stopped and removed:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d \u00abcontainer\u00bb\n</code></pre>"},{"location":"Basic_setup/#checking-container-status","title":"checking container status","text":"<p>You can check the status of containers with:</p> <pre><code>$ docker ps\n</code></pre> <p>or</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose ps\n</code></pre>"},{"location":"Basic_setup/#viewing-container-logs","title":"viewing container logs","text":"<p>You can inspect the logs of most containers like this:</p> <pre><code>$ docker logs \u00abcontainer\u00bb\n</code></pre> <p>for example:</p> <pre><code>$ docker logs nodered\n</code></pre> <p>You can also follow a container's log as new entries are added by using the <code>-f</code> flag:</p> <pre><code>$ docker logs -f nodered\n</code></pre> <p>Terminate with a Control+C. Note that restarting a container will also terminate a followed log.</p>"},{"location":"Basic_setup/#restarting-a-container","title":"restarting a container","text":"<p>You can restart a container in several ways:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart \u00abcontainer\u00bb\n</code></pre> <p>This kind of restart is the least-powerful form of restart. A good way to think of it is \"the container is only restarted, it is not rebuilt\".</p> <p>If you change a <code>docker-compose.yml</code> setting for a container and/or an environment variable file referenced by <code>docker-compose.yml</code> then a <code>restart</code> is usually not enough to bring the change into effect. You need to make <code>docker-compose</code> notice the change:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d \u00abcontainer\u00bb\n</code></pre> <p>This type of \"restart\" rebuilds the container.</p> <p>Alternatively, to force a container to rebuild (without changing either <code>docker-compose.yml</code> or an environment variable file):</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d --force-recreate \u00abcontainer\u00bb\n</code></pre> <p>See also updating images built from Dockerfiles if you need to force <code>docker-compose</code> to notice a change to a Dockerfile.</p>"},{"location":"Basic_setup/#persistent-data","title":"persistent data","text":"<p>Docker allows a container's designer to map folders inside a container to a folder on your disk (SD, SSD, HD). This is done with the \"volumes\" key in <code>docker-compose.yml</code>. Consider the following snippet for Node-RED:</p> <pre><code>volumes:\n  - ./volumes/nodered/data:/data\n</code></pre> <p>You read this as two paths, separated by a colon. The:</p> <ul> <li>external path is <code>./volumes/nodered/data</code></li> <li>internal path is <code>/data</code></li> </ul> <p>In this context, the leading \".\" means \"the folder containing<code>docker-compose.yml</code>\", so the external path is actually:</p> <ul> <li><code>~/IOTstack/volumes/nodered/data</code></li> </ul> <p>This type of volume is a bind-mount, where the container's internal path is directly linked to the external path. All file-system operations, reads and writes, are mapped to directly to the files and folders at the external path.</p>"},{"location":"Basic_setup/#deleting-persistent-data","title":"deleting persistent data","text":"<p>If you need a \"clean slate\" for a container, you can delete its volumes. Using InfluxDB as an example:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose rm --force --stop -v influxdb\n$ sudo rm -rf ./volumes/influxdb\n$ docker-compose up -d influxdb\n</code></pre> <p>When <code>docker-compose</code> tries to bring up InfluxDB, it will notice this volume mapping in <code>docker-compose.yml</code>:</p> <pre><code>    volumes:\n      - ./volumes/influxdb/data:/var/lib/influxdb\n</code></pre> <p>and check to see whether <code>./volumes/influxdb/data</code> is present. Finding it not there, it does the equivalent of:</p> <pre><code>$ sudo mkdir -p ./volumes/influxdb/data\n</code></pre> <p>When InfluxDB starts, it sees that the folder on right-hand-side of the volumes mapping (<code>/var/lib/influxdb</code>) is empty and initialises new databases.</p> <p>This is how most containers behave. There are exceptions so it's always a good idea to keep a backup.</p>"},{"location":"Basic_setup/#stack-maintenance","title":"stack maintenance","text":"<p>Breaking update</p> <p>Recent changes will require manual steps or you may get an error like: <code>ERROR: Service \"influxdb\" uses an undefined network \"iotstack_nw\"</code></p>"},{"location":"Basic_setup/#update-raspberry-pi-os","title":"update Raspberry Pi OS","text":"<p>You should keep your Raspberry Pi up-to-date. Despite the word \"container\" suggesting that containers are fully self-contained, they sometimes depend on operating system components (\"WireGuard\" is an example).</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade -y\n</code></pre>"},{"location":"Basic_setup/#git-pull","title":"git pull","text":"<p>Although the menu will generally do this for you, it does not hurt to keep your local copy of the IOTstack repository in sync with the master version on GitHub.</p> <pre><code>$ cd ~/IOTstack\n$ git pull\n</code></pre>"},{"location":"Basic_setup/#container-image-updates","title":"container image updates","text":"<p>There are two kinds of images used in IOTstack:</p> <ul> <li>Those not built using Dockerfiles (the majority)</li> <li> <p>Those built using Dockerfiles (special cases)</p> <p>A Dockerfile is a set of instructions designed to customise an image before it is instantiated to become a running container.</p> </li> </ul> <p>The easiest way to work out which type of image you are looking at is to inspect the container's service definition in your <code>docker-compose.yml</code> file. If the service definition contains the:</p> <ul> <li><code>image:</code> keyword then the image is not built using a Dockerfile.</li> <li><code>build:</code> keyword then the image is built using a Dockerfile.</li> </ul>"},{"location":"Basic_setup/#updating-images-not-built-from-dockerfiles","title":"updating images not built from Dockerfiles","text":"<p>If new versions of this type of image become available on DockerHub, your local IOTstack copies can be updated by a <code>pull</code> command:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune\n</code></pre> <p>The <code>pull</code> downloads any new images. It does this without disrupting the running stack.</p> <p>The <code>up -d</code> notices any newly-downloaded images, builds new containers, and swaps old-for-new. There is barely any downtime for affected containers.</p>"},{"location":"Basic_setup/#updating-images-built-from-dockerfiles","title":"updating images built from Dockerfiles","text":"<p>Containers built using Dockerfiles have a two-step process:</p> <ol> <li>A base image is downloaded from from DockerHub; and then</li> <li>The Dockerfile \"runs\" to build a local image.</li> </ol> <p>Node-RED is a good example of a container built from a Dockerfile. The Dockerfile defines some (or possibly all) of your add-on nodes, such as those needed for InfluxDB or Tasmota.</p> <p>There are two separate update situations that you need to consider:</p> <ul> <li>If your Dockerfile changes; or</li> <li>If a newer base image appears on DockerHub</li> </ul> <p>Node-RED also provides a good example of why your Dockerfile might change: if you decide to add or remove add-on nodes.</p> <p>Note:</p> <ul> <li>You can also add nodes to Node-RED using Manage Palette.</li> </ul>"},{"location":"Basic_setup/#when-dockerfile-changes-local-image-only","title":"when Dockerfile changes (local image only)","text":"<p>When your Dockerfile changes, you need to rebuild like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up --build -d \u00abcontainer\u00bb\n$ docker system prune\n</code></pre> <p>This only rebuilds the local image and, even then, only if <code>docker-compose</code> senses a material change to the Dockerfile.</p> <p>If you are trying to force the inclusion of a later version of an add-on node, you need to treat it like a DockerHub update.</p> <p>Key point:</p> <ul> <li>The base image is not affected by this type of update.</li> </ul> <p>Note:</p> <ul> <li> <p>You can also use this type of build if you get an error after modifying Node-RED's environment:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up --build -d nodered\n</code></pre> </li> </ul>"},{"location":"Basic_setup/#when-dockerhub-updates-base-and-local-images","title":"when DockerHub updates (base and local images)","text":"<p>When a newer version of the base image appears on DockerHub, you need to rebuild like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull \u00abcontainer\u00bb\n$ docker-compose up -d \u00abcontainer\u00bb\n$ docker system prune\n$ docker system prune\n</code></pre> <p>This causes DockerHub to be checked for the later version of the base image, downloading it as needed.</p> <p>Then, the Dockerfile is run to produce a new local image. The Dockerfile run happens even if a new base image was not downloaded in the previous step.</p>"},{"location":"Basic_setup/#deleting-unused-images","title":"deleting unused images","text":"<p>As your system evolves and new images come down from DockerHub, you may find that more disk space is being occupied than you expected. Try running:</p> <pre><code>$ docker system prune\n</code></pre> <p>This recovers anything no longer in use. Sometimes multiple <code>prune</code> commands are needed (eg the first removes an old local image, the second removes the old base image).</p> <p>If you add a container via <code>menu.sh</code> and later remove it (either manually or via <code>menu.sh</code>), the associated images(s) will probably persist. You can check which images are installed via:</p> <pre><code>$ docker images\n\nREPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\ninfluxdb                 latest              1361b14bf545        5 days ago          264MB\ngrafana/grafana          latest              b9dfd6bb8484        13 days ago         149MB\niotstack_nodered         latest              21d5a6b7b57b        2 weeks ago         540MB\nportainer/portainer-ce   latest              5526251cc61f        5 weeks ago         163MB\neclipse-mosquitto        latest              4af162db6b4c        6 weeks ago         8.65MB\nnodered/node-red         latest              fa3bc6f20464        2 months ago        376MB\nportainer/portainer      latest              dbf28ba50432        2 months ago        62.5MB\n</code></pre> <p>Both \"Portainer CE\" and \"Portainer\" are in that list. Assuming \"Portainer\" is no longer in use, it can be removed by using either its repository name or its Image ID. In other words, the following two commands are synonyms:</p> <pre><code>$ docker rmi portainer/portainer\n$ docker rmi dbf28ba50432\n</code></pre> <p>In general, you can use the repository name to remove an image but the Image ID is sometimes needed. The most common situation where you are likely to need the Image ID is after an image has been updated on DockerHub and pulled down to your Raspberry Pi. You will find two containers with the same name. One will be tagged \"latest\" (the running version) while the other will be tagged \"\\&lt;none&gt;\" (the prior version). You use the Image ID to resolve the ambiguity.</p>"},{"location":"Basic_setup/#pinning-to-specific-versions","title":"pinning to specific versions","text":"<p>See container image updates to understand how to tell the difference between images that are used \"as is\" from DockerHub versus those that are built from local Dockerfiles.</p> <p>Note:</p> <ul> <li>You should always visit an image's DockerHub page before pinning to a specific version. This is the only way to be certain that you are choosing the appropriate version suffix.</li> </ul> <p>To pin an image to a specific version:</p> <ul> <li> <p>If the image comes straight from DockerHub, you apply the pin in <code>docker-compose.yml</code>. For example, to pin Grafana to version 7.5.7, you change:</p> <pre><code>  grafana:\n    container_name: grafana\n    image: grafana/grafana:latest\n    \u2026\n</code></pre> <p>to:</p> <pre><code>  grafana:\n    container_name: grafana\n    image: grafana/grafana:7.5.7\n    \u2026\n</code></pre> <p>To apply the change, \"up\" the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d grafana\n</code></pre> </li> <li> <p>If the image is built using a local Dockerfile, you apply the pin in the Dockerfile. For example, to pin Mosquitto to version 1.6.15, edit <code>~/IOTstack/.templates/mosquitto/Dockerfile</code> to change:</p> <pre><code># Download base image\nFROM eclipse-mosquitto:latest\n\u2026\n</code></pre> <p>to:</p> <pre><code># Download base image\nFROM eclipse-mosquitto:1.6.15\n\u2026\n</code></pre> <p>To apply the change, \"up\" the container and pass the <code>--build</code> flag:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d --build mosquitto\n</code></pre> </li> </ul>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/","title":"Accessing your device from the internet","text":"<p>The challenge most of us face with remotely accessing our home networks is that our routers usually have a dynamically-allocated IP address on the public (WAN) interface.</p> <p>From time to time the IP address that your ISP assigns changes and it's difficult to keep up. Fortunately, there is a solution: Dynamic DNS. The section below shows you how to set up an easy-to-remember domain name that follows your public IP address no matter when it changes.</p> <p>Secondly, how do you get into your home network? Your router has a firewall that is designed to keep the rest of the internet out of your network to protect you. The solution to that is a Virtual Private Network (VPN) or \"tunnel\". </p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#dynamic-dns","title":"Dynamic DNS","text":"<p>There are two parts to a Dynamic DNS service:</p> <ol> <li>You have to register with a Dynamic DNS service provider and obtain a domain name that is not already taken by someone else.</li> <li>Something on your side of the network needs to propagate updates so that your chosen domain name remains in sync with your router's dynamically-allocated public IP address.</li> </ol>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#register-with-a-dynamic-dns-service-provider","title":"Register with a Dynamic DNS service provider","text":"<p>The first part is fairly simple and there are quite a few Dynamic DNS service providers including:</p> <ul> <li>DuckDNS.org</li> <li>NoIP.com</li> </ul> <p>You can find more service providers by Googling \"Dynamic DNS service\".</p> <p>Some router vendors also provide their own built-in Dynamic DNS capabilities for registered customers so it's a good idea to check your router's capabilities before you plough ahead.</p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#dynamic-dns-propagation","title":"Dynamic DNS propagation","text":"<p>The \"something\" on your side of the network propagating WAN IP address changes can be either:</p> <ul> <li>your router; or</li> <li>a \"behind the router\" technique, typically a periodic job running on the same Raspberry Pi that is hosting IOTstack and WireGuard.</li> </ul> <p>If you have the choice, your router is to be preferred. That's because your router is usually the only device in your network that actually knows when its WAN IP address changes. A Dynamic DNS client running on your router will propagate changes immediately and will only transmit updates when necessary. More importantly, it will persist through network interruptions or Dynamic DNS service provider outages until it receives an acknowledgement that the update has been accepted.</p> <p>Nevertheless, your router may not support the Dynamic DNS service provider you wish to use, or may come with constraints that you find unsatisfactory so any behind-the-router technique is always a viable option, providing you understand its limitations.</p> <p>A behind-the-router technique usually relies on sending updates according to a schedule. An example is a <code>cron</code> job that runs every five minutes. That means any router WAN IP address changes won't be propagated until the next scheduled update. In the event of network interruptions or service provider outages, it may take close to ten minutes before everything is back in sync. Moreover, given that WAN IP address changes are infrequent events, most scheduled updates will be sending information unnecessarily.</p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#duckdns-container","title":"DuckDNS container","text":"<p>The recommended and easiest solution is to install the Duckdns docker-container from the menu. It includes the cron service and logs are handled by Docker.</p> <p>For configuration see Containers/Duck DNS.</p> <p>Note</p> <p>This is a recently added container, please don't hesitate to report any possible faults to Discord or as Github issues.</p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#duckdns-client","title":"DuckDNS client script","text":"<p>Info</p> <p>This method will soon be deprecated in favor of the DuckDNS container.</p> <p>IOTstack provides a solution for DuckDNS. The best approach to running it is:</p> <pre><code>$ mkdir -p ~/.local/bin\n$ cp ~/IOTstack/duck/duck.sh ~/.local/bin\n</code></pre> <p>The reason for recommending that you make a copy of <code>duck.sh</code> is because the \"original\" is under Git control. If you change the \"original\", Git will keep telling you that the file has changed and it may block incoming updates from GitHub.</p> <p>Then edit <code>~/.local/bin/duck.sh</code> to add your DuckDNS domain name(s) and token:</p> <pre><code>DOMAINS=\"YOURS.duckdns.org\"\nDUCKDNS_TOKEN=\"YOUR_DUCKDNS_TOKEN\"\n</code></pre> <p>For example:</p> <pre><code>DOMAINS=\"downunda.duckdns.org\"\nDUCKDNS_TOKEN=\"8a38f294-b5b6-4249-b244-936e997c6c02\"\n</code></pre> <p>Note:</p> <ul> <li> <p>The <code>DOMAINS=</code> variable can be simplified to just \"YOURS\", with the <code>.duckdns.org</code> portion implied, as in:</p> <pre><code>DOMAINS=\"downunda\"\n</code></pre> </li> </ul> <p>Once your credentials are in place, test the result by running:</p> <pre><code>$ ~/.local/bin/duck.sh\nddd, dd mmm yyyy hh:mm:ss \u00b1zzzz - updating DuckDNS\nOK\n</code></pre> <p>The timestamp is produced by the <code>duck.sh</code> script. The expected responses from the DuckDNS service are:</p> <ul> <li>\"OK\" - indicating success; or</li> <li>\"KO\" - indicating failure.</li> </ul> <p>Check your work if you get \"KO\" or any other errors.</p> <p>Next, assuming <code>dig</code> is installed on your Raspberry Pi (<code>sudo apt install dnsutils</code>), you can test propagation by sending a directed query to a DuckDNS name server. For example, assuming the domain name you registered was <code>downunda.duckdns.org</code>, you would query like this:</p> <pre><code>$ dig @ns1.duckdns.org downunda.duckdns.org +short\n</code></pre> <p>The expected result is the IP address of your router's WAN interface. It is a good idea to confirm that it is the same as you get from whatismyipaddress.com.</p> <p>A null result indicates failure so check your work.</p> <p>Remember, the Domain Name System is a distributed database. It takes time for changes to propagate. The response you get from directing a query to ns1.duckdns.org may not be the same as the response you get from any other DNS server. You often have to wait until cached records expire and a recursive query reaches the authoritative DuckDNS name-servers.</p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#running-the-duckdns-client-automatically","title":"Running the DuckDNS client automatically","text":"<p>The recommended arrangement for keeping your Dynamic DNS service up-to-date is to invoke <code>duck.sh</code> from <code>cron</code> at five minute intervals.</p> <p>If you are new to <code>cron</code>, see these guides for more information about setting up and editing your <code>crontab</code>:</p> <ul> <li>raspberrytips.com</li> <li>pimylifeup.com</li> </ul> <p>A typical <code>crontab</code> will look like this:</p> <pre><code>SHELL=/bin/bash\nHOME=/home/pi\nPATH=/home/pi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n\n*/5 *   *   *   *   duck.sh &gt;/dev/null 2&gt;&amp;1\n</code></pre> <p>The first three lines construct the runtime environment correctly and should be at the start of any <code>crontab</code>.</p> <p>The last line means \"run duck.sh every five minutes\". See crontab.guru if you want to understand the syntax of the last line.</p> <p>When launched in the background by <code>cron</code>, the script supplied with IOTstack adds a random delay of up to one minute to try to reduce the \"hammering effect\" of a large number of users updating DuckDNS simultaneously.</p> <p>Standard output and standard error are redirected to <code>/dev/null</code> which is appropriate in this instance. When DuckDNS is working correctly (which is most of the time), the only output from the <code>curl</code> command is \"OK\". Logging that every five minutes would add wear and tear to SD cards for no real benefit.</p> <p>If you suspect DuckDNS is misbehaving, you can run the <code>duck.sh</code> command from a terminal session, in which case you will see all the <code>curl</code> output in the terminal window.</p> <p>If you wish to keep a log of <code>duck.sh</code> activity, the following will get the job done:</p> <ol> <li> <p>Make a directory to hold log files:</p> <pre><code>$ mkdir -p ~/Logs\n</code></pre> </li> <li> <p>Edit the last line of the <code>crontab</code> like this:</p> <pre><code>*/5 *   *   *   *   duck.sh &gt;&gt;./Logs/duck.log 2&gt;&amp;1\n</code></pre> </li> </ol> <p>Remember to prune the log from time to time. The generally-accepted approach is:</p> <pre><code>$ cat /dev/null &gt;~/Logs/duck.log\n</code></pre>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#virtual-private-network","title":"Virtual Private Network","text":""},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#wireguard","title":"WireGuard","text":"<p>WireGuard is supplied as part of IOTstack. See WireGuard documentation.</p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#pivpn","title":"PiVPN","text":"<p>pimylifeup.com has an excellent tutorial on how to install PiVPN</p> <p>In point 17 and 18 they mention using noip for their dynamic DNS. Here you can use the DuckDNS address if you created one.</p> <p>Don't forget you need to open the port 1194 on your firewall. Most people won't be able to VPN from inside their network so download OpenVPN client for your mobile phone and try to connect over mobile data. (More info.)</p> <p>Once you activate your VPN (from your phone/laptop/work computer) you will effectively be on your home network and you can access your devices as if you were on the wifi at home.</p> <p>I personally use the VPN any time I'm on public wifi, all your traffic is secure.</p>"},{"location":"Basic_setup/Accessing-your-Device-from-the-internet/#zerotier","title":"Zerotier","text":"<p>https://www.zerotier.com/</p> <p>Zerotier is an alternative to PiVPN that doesn't require port forwarding on your router. It does however require registering for their free tier service here. </p> <p>Kevin Zhang has written a how to guide here. Just note that the install link is outdated and should be:</p> <pre><code>$ curl -s 'https://raw.githubusercontent.com/zerotier/ZeroTierOne/master/doc/contact%40zerotier.com.gpg' | gpg --import &amp;&amp; \\\nif z=$(curl -s 'https://install.zerotier.com/' | gpg); then echo \"$z\" | sudo bash; fi\n</code></pre>"},{"location":"Basic_setup/Backup-and-Restore/","title":"Backing up and restoring IOTstack","text":"<p>This page explains how to use the backup and restore functionality of IOTstack.</p>"},{"location":"Basic_setup/Backup-and-Restore/#backup","title":"Backup","text":"<p>The backup command can be executed from IOTstack's menu, or from a cronjob.</p>"},{"location":"Basic_setup/Backup-and-Restore/#running-backup","title":"Running backup","text":"<p>To ensure that all your data is saved correctly, the stack should be brought down. This is mainly due to databases potentially being in a state that could cause data loss.</p> <p>There are 2 ways to run backups:</p> <ul> <li>From the menu: <code>Backup and Restore</code> &gt; <code>Run backup</code></li> <li>Running the following command: <code>bash ./scripts/backup.sh</code></li> </ul> <p>The command that's run from the command line can also be executed from a cronjob:</p> <p><code>0 2 * * * cd /home/pi/IOTstack &amp;&amp; /bin/bash ./scripts/backup.sh</code></p> <p>The current directory of bash must be in IOTstack's directory, to ensure that it can find the relative paths of the files it's meant to back up. In the example above, it's assume that it's inside the <code>pi</code> user's home directory.</p>"},{"location":"Basic_setup/Backup-and-Restore/#arguments","title":"Arguments","text":"<pre><code>./scripts/backup.sh {TYPE=3} {USER=$(whoami)}\n</code></pre> <ul> <li>Types:</li> <li>1 = Backup with Date<ul> <li>A tarball file will be created that contains the date and time the backup was started, in the filename.</li> </ul> </li> <li>2 = Rolling Date<ul> <li>A tarball file will be created that contains the day of the week (0-6) the backup was started, in the filename.</li> <li>If a tarball already exists with the same name, it will be overwritten.</li> </ul> </li> <li>3 = Both</li> <li>User:     This parameter only becomes active if run as root. This script will default to the current logged in user       If this parameter is not supplied when run as root, the script will ask for the username as input</li> </ul> <p>Backups:</p> <ul> <li>You can find the backups in the ./backups/ folder. With rolling being in ./backups/rolling/ and date backups in ./backups/backup/</li> <li>Log files can also be found in the ./backups/logs/ directory.</li> </ul>"},{"location":"Basic_setup/Backup-and-Restore/#examples","title":"Examples:","text":"<ul> <li><code>./scripts/backup.sh</code></li> <li><code>./scripts/backup.sh 3</code></li> </ul> <p>Either of these will run both backups.</p> <ul> <li><code>./scripts/backup.sh 2</code></li> </ul> <p>This will only produce a backup in the rollowing folder. It will be called 'backup_XX.tar.gz' where XX is the current day of the week (as an int)</p> <ul> <li><code>sudo bash ./scripts/backup.sh 2 pi</code></li> </ul> <p>This will only produce a backup in the rollowing folder and change all the permissions to the 'pi' user.</p>"},{"location":"Basic_setup/Backup-and-Restore/#restore","title":"Restore","text":"<p>There are 2 ways to run a restore:</p> <ul> <li>From the menu: <code>Backup and Restore</code> &gt; <code>Restore from backup</code></li> <li>Running the following command: <code>bash ./scripts/restore.sh</code></li> </ul> <p>Important: The restore script assumes that the IOTstack directory is fresh, as if it was just cloned. If it is not fresh, errors may occur, or your data may not correctly be restored even if no errors are apparent.</p> <p>Note: It is suggested that you test that your backups can be restored after initially setting up, and anytime you add or remove a service. Major updates to services can also break backups.</p>"},{"location":"Basic_setup/Backup-and-Restore/#arguments_1","title":"Arguments","text":"<p><pre><code>./scripts/restore.sh {FILENAME=backup.tar.gz} {noask}\n</code></pre> The restore script takes 2 arguments:</p> <ul> <li>Filename: The name of the backup file. The file must be present in the <code>./backups/</code> directory, or a subfolder in it. That means it should be moved from <code>./backups/backup</code> to <code>./backups/</code>, or that you need to specify the <code>backup</code> portion of the directory (see examples)</li> <li>NoAsk: If a second parameter is present, is acts as setting the no ask flag to true. </li> </ul>"},{"location":"Basic_setup/Backup-and-Restore/#pre-and-post-script-hooks","title":"Pre and post script hooks","text":"<p>The script checks if there are any pre and post back up hooks to execute commands. Both of these files will be included in the backup, and have also been added to the <code>.gitignore</code> file, so that they will not be touched when IOTstack updates.</p>"},{"location":"Basic_setup/Backup-and-Restore/#prebackup-script-hook","title":"Prebackup script hook","text":"<p>The prebackup hook script is executed before any compression happens and before anything is written to the temporary backup manifest file (<code>./.tmp/backup-list_{{NAME}}.txt</code>). It can be used to prepare any services (such as databases that IOTstack isn't aware of) for backing up.</p> <p>To use it, simple create a <code>./pre_backup.sh</code> file in IOTstack's main directory. It will be executed next time a backup runs.</p>"},{"location":"Basic_setup/Backup-and-Restore/#postbackup-script-hook","title":"Postbackup script hook","text":"<p>The postbackup hook script is executed after the tarball file has been written to disk, and before the final backup log information is written to disk.</p> <p>To use it, simple create a <code>./post_backup.sh</code> file in IOTstack's main directory. It will be executed after the next time a backup runs.</p>"},{"location":"Basic_setup/Backup-and-Restore/#post-restore-script-hook","title":"Post restore script hook","text":"<p>The post restore hook script is executed after all files have been extracted and written to disk. It can be used to apply permissions that your custom services may require.</p> <p>To use it, simple create a <code>./post_restore.sh</code> file in IOTstack's main directory. It will be executed after a restore happens.</p>"},{"location":"Basic_setup/Backup-and-Restore/#third-party-integration","title":"Third party integration","text":"<p>This section explains how to backup your files with 3rd party software.</p>"},{"location":"Basic_setup/Backup-and-Restore/#dropbox","title":"Dropbox","text":"<p>Coming soon.</p>"},{"location":"Basic_setup/Backup-and-Restore/#google-drive","title":"Google Drive","text":"<p>Coming soon.</p>"},{"location":"Basic_setup/Backup-and-Restore/#rsync","title":"rsync","text":"<p>Coming soon.</p>"},{"location":"Basic_setup/Backup-and-Restore/#duplicati","title":"Duplicati","text":"<p>Coming soon.</p>"},{"location":"Basic_setup/Backup-and-Restore/#sftp","title":"SFTP","text":"<p>Coming soon.</p>"},{"location":"Basic_setup/Custom/","title":"Custom overrides","text":"<p>Each time you build the stack from the menu, the Docker Compose file <code>docker-compose.yml</code> is recreated, losing any custom changes you've made. There are different ways of dealing with this:</p> <ol> <li>Not using the menu after you've made changes. Do remember to backup your     customized <code>docker-compose.yml</code>, in case you overwrite it by mistake or     habit from the menu.</li> <li>Use the Docker Compose inbuilt override mechanism by creating a file named     <code>docker-compose.override.yml</code>. This limits you to changing values and     appending to lists already present in your docker-compose.yml, but it's     handy as changes are immediately picked up by docker-compose commands. To     see the resulting final config run <code>docker-compose config</code>.</li> <li>IOTstack menu, in the default master-branch, implements a mechanism to     merge the yaml file <code>compose-override.yml</code> with the menu-generated stack     into <code>docker-compose.yml</code>. This can be used to add even complete new     services. See below for details.</li> <li>This is not an actual extension mechanism, but well worth mentioning: If     you need a new services that doesn't communicate with the services in     IOTstack, create it completely separately and independently into its own     folder, e.g. <code>~/customStack/docker-compose.yml</code>. This composition can then     be independently managed from that folder: <code>cd ~/customStack</code> and use     <code>docker-compose</code> commands as normal. The best override is the one you don't     have to make.</li> </ol>"},{"location":"Basic_setup/Custom/#custom-services-and-overriding-default-settings-for-iotstack","title":"Custom services and overriding default settings for IOTstack","text":"<p>You can specify modifcations to the <code>docker-compose.yml</code> file, including your own networks and custom containers/services.</p> <p>Create a file called <code>compose-override.yml</code> in the main directory, and place your modifications into it. These changes will be merged into the <code>docker-compose.yml</code> file next time you run the build script.</p> <p>The <code>compose-override.yml</code> file has been added to the <code>.gitignore</code> file, so it shouldn't be touched when upgrading IOTstack. It has been added to the backup script, and so will be included when you back up and restore IOTstack. Always test your backups though! New versions of IOTstack may break previous builds.</p>"},{"location":"Basic_setup/Custom/#how-it-works","title":"How it works","text":"<ol> <li>After the build process has been completed, a temporary docker compose file is created in the <code>tmp</code> directory.</li> <li>The script then checks if <code>compose-override.yml</code> exists:<ul> <li>If it exists, then continue to step <code>3</code></li> <li>If it does not exist, copy the temporary docker compose file to the main directory and rename it to <code>docker-compose.yml</code>.</li> </ul> </li> <li>Using the <code>yaml_merge.py</code> script, merge both the <code>compose-override.yml</code> and the temporary docker compose file together; Using the temporary file as the default values and interating through each level of the yaml structure, check to see if the <code>compose-override.yml</code> has a value set.</li> <li>Output the final file to the main directory, calling it <code>docker-compose.yml</code>.</li> </ol>"},{"location":"Basic_setup/Custom/#a-word-of-caution","title":"A word of caution","text":"<p>If you specify an override for a service, and then rebuild the <code>docker-compose.yml</code> file, but deselect the service from the list, then the YAML merging will still produce that override.</p> <p>For example, lets say NodeRed was selected to have have the following override specified in <code>compose-override.yml</code>: <pre><code>services:\n  nodered:\n    restart: always\n</code></pre></p> <p>When rebuilding the menu, ensure to have NodeRed service always included because if it's no longer included, the only values showing in the final <code>docker-compose.yml</code> file for NodeRed will be the <code>restart</code> key and its value. Docker Compose will error with the following message:</p> <p><code>Service nodered has neither an image nor a build context specified. At least one must be provided.</code></p> <p>When attempting to bring the services up with <code>docker-compose up -d</code>.</p> <p>Either remove the override for NodeRed in <code>compose-override.yml</code> and rebuild the stack, or ensure that NodeRed is built with the stack to fix this.</p>"},{"location":"Basic_setup/Custom/#examples","title":"Examples","text":""},{"location":"Basic_setup/Custom/#overriding-default-settings","title":"Overriding default settings","text":"<p>Lets assume you put the following into the <code>compose-override.yml</code> file: <pre><code>services:\n  mosquitto:\n    ports:\n      - 1996:1996\n      - 9001:9001\n</code></pre></p> <p>Normally the mosquitto service would be built like this inside the <code>docker-compose.yml</code> file: <pre><code>version: '3.6'\nservices:\n  mosquitto:\n    container_name: mosquitto\n    image: eclipse-mosquitto\n    restart: unless-stopped\n    user: \"1883\"\n    ports:\n      - 1883:1883\n      - 9001:9001\n    volumes:\n      - ./volumes/mosquitto/data:/mosquitto/data\n      - ./volumes/mosquitto/log:/mosquitto/log\n      - ./volumes/mosquitto/pwfile:/mosquitto/pwfile\n      - ./services/mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf\n      - ./services/mosquitto/filter.acl:/mosquitto/config/filter.acl\n</code></pre></p> <p>Take special note of the ports list.</p> <p>If you run the build script with the <code>compose-override.yml</code> file in place, and open up the final <code>docker-compose.yml</code> file, you will notice that the port list have been replaced with the ones you specified in the <code>compose-override.yml</code> file. <pre><code>version: '3.6'\nservices:\n  mosquitto:\n    container_name: mosquitto\n    image: eclipse-mosquitto\n    restart: unless-stopped\n    user: \"1883\"\n    ports:\n      - 1996:1996\n      - 9001:9001\n    volumes:\n      - ./volumes/mosquitto/data:/mosquitto/data\n      - ./volumes/mosquitto/log:/mosquitto/log\n      - ./volumes/mosquitto/pwfile:/mosquitto/pwfile\n      - ./services/mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf\n      - ./services/mosquitto/filter.acl:/mosquitto/config/filter.acl\n</code></pre></p> <p>Do note that it will replace the entire list, if you were to specify <pre><code>services:\n  mosquitto:\n    ports:\n      - 1996:1996\n</code></pre></p> <p>Then the final output will be: <pre><code>version: '3.6'\nservices:\n  mosquitto:\n    container_name: mosquitto\n    image: eclipse-mosquitto\n    restart: unless-stopped\n    user: \"1883\"\n    ports:\n      - 1996:1996\n    volumes:\n      - ./volumes/mosquitto/data:/mosquitto/data\n      - ./volumes/mosquitto/log:/mosquitto/log\n      - ./volumes/mosquitto/pwfile:/mosquitto/pwfile\n      - ./services/mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf\n      - ./services/mosquitto/filter.acl:/mosquitto/config/filter.acl\n</code></pre></p>"},{"location":"Basic_setup/Custom/#using-env-files-instead-of-docker-compose-variables","title":"Using env files instead of docker-compose variables","text":"<p>If you need or prefer to use *.env files for docker-compose environment variables in a separate file instead of using overrides, you can do so like this:</p> <pre><code>services:\n  grafana:\n    env_file:\n      - ./services/grafana/grafana.env\n    environment:\n</code></pre> <p>This will remove the default environment variables set in the template, and tell docker-compose to use the variables specified in your file. It is not mandatory that the .env file be placed in the service's service directory, but is strongly suggested. Keep in mind the PostBuild Script functionality to automatically copy your .env files into their directories on successful build if you need to.</p>"},{"location":"Basic_setup/Custom/#adding-custom-services","title":"Adding custom services","text":"<p>Custom services can be added in a similar way to overriding default settings for standard services. Lets add a Minecraft and rcon server to IOTstack. Firstly, put the following into <code>compose-override.yml</code>: <pre><code>services:\n  mosquitto:\n    ports:\n      - 1996:1996\n      - 9001:9001\n  minecraft:\n    image: itzg/minecraft-server\n    ports:\n      - \"25565:25565\"\n    volumes:\n      - \"./volumes/minecraft:/data\"\n    environment:\n      EULA: \"TRUE\"\n      TYPE: \"PAPER\"\n      ENABLE_RCON: \"true\"\n      RCON_PASSWORD: \"PASSWORD\"\n      RCON_PORT: 28016\n      VERSION: \"1.15.2\"\n      REPLACE_ENV_VARIABLES: \"TRUE\"\n      ENV_VARIABLE_PREFIX: \"CFG_\"\n      CFG_DB_HOST: \"http://localhost:3306\"\n      CFG_DB_NAME: \"IOTstack Minecraft\"\n      CFG_DB_PASSWORD_FILE: \"/run/secrets/db_password\"\n    restart: unless-stopped\n  rcon:\n    image: itzg/rcon\n    ports:\n      - \"4326:4326\"\n      - \"4327:4327\"\n    volumes:\n      - \"./volumes/rcon_data:/opt/rcon-web-admin/db\"\nsecrets:\n  db_password:\n    file: ./db_password\n</code></pre></p> <p>Then create the service directory that the new instance will use to store persistant data:</p> <p><code>mkdir -p ./volumes/minecraft</code></p> <p>and</p> <p><code>mkdir -p ./volumes/rcon_data</code></p> <p>Obviously you will need to give correct folder names depending on the <code>volumes</code> you specify for your custom services. If your new service doesn't require persistant storage, then you can skip this step.</p> <p>Then simply run the <code>./menu.sh</code> command, and rebuild the stack with what ever services you had before.</p> <p>Using the Mosquitto example above, the final <code>docker-compose.yml</code> file will look like:</p> <pre><code>version: '3.6'\nservices:\n  mosquitto:\n    ports:\n    - 1996:1996\n    - 9001:9001\n    container_name: mosquitto\n    image: eclipse-mosquitto\n    restart: unless-stopped\n    user: '1883'\n    volumes:\n    - ./volumes/mosquitto/data:/mosquitto/data\n    - ./volumes/mosquitto/log:/mosquitto/log\n    - ./services/mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf\n    - ./services/mosquitto/filter.acl:/mosquitto/config/filter.acl\n  minecraft:\n    image: itzg/minecraft-server\n    ports:\n    - 25565:25565\n    volumes:\n    - ./volumes/minecraft:/data\n    environment:\n      EULA: 'TRUE'\n      TYPE: PAPER\n      ENABLE_RCON: 'true'\n      RCON_PASSWORD: PASSWORD\n      RCON_PORT: 28016\n      VERSION: 1.15.2\n      REPLACE_ENV_VARIABLES: 'TRUE'\n      ENV_VARIABLE_PREFIX: CFG_\n      CFG_DB_HOST: http://localhost:3306\n      CFG_DB_NAME: IOTstack Minecraft\n      CFG_DB_PASSWORD_FILE: /run/secrets/db_password\n    restart: unless-stopped\n  rcon:\n    image: itzg/rcon\n    ports:\n    - 4326:4326\n    - 4327:4327\n    volumes:\n    - ./volumes/rcon_data:/opt/rcon-web-admin/db\nsecrets:\n  db_password:\n    file: ./db_password\n</code></pre> <p>Do note that the order of the YAML keys is not guaranteed.</p>"},{"location":"Basic_setup/Default-Configs/","title":"Default ports","text":"<p>Here you can find a list of the default mode and ports used by each service found in the .templates directory.</p> <p>This list can be generated by running the default_ports_md_generator.sh script.</p> Service Name Mode Port(s) External:Internal adguardhome non-host 53:53  8089:8089  3001:3000  adminer non-host 9080:8080  blynk_server non-host 8180:8080  8440:8440  9443:9443  chronograf non-host 8888:8888  dashmachine non-host 5000:5000  deconz non-host 8090:80  443:443  5901:5900  diyhue non-host 8070:80  1900:1900  1982:1982  2100:2100  domoticz non-host 8083:8080  6144:6144  1443:1443  dozzle non-host 8889:8080  duckdns host espruinohub host gitea non-host 7920:3000  2222:22  grafana non-host 3000:3000  heimdall non-host 8880:80  8883:443  home_assistant host homebridge host homer non-host 8881:8080  influxdb non-host 8086:8086  influxdb2 non-host 8087:8086  kapacitor non-host 9092:9092  mariadb non-host 3306:3306  mosquitto non-host 1883:1883  \"motioneye\" non-host 8765:8765  8081:8081  \"n8n\" non-host 5678:5678  nextcloud non-host 9321:80  nodered non-host 1880:1880  octoprint non-host 9980:80  openhab host pihole non-host 8089:80  53:53  67:67  plex host portainer-ce non-host 8000:8000  9000:9000  portainer-agent non-host 9001:9001  postgres non-host 5432:5432  prometheus-cadvisor non-host 8082:8080  prometheus-nodeexporter non-host prometheus non-host 9090:9090  python non-host qbittorrent non-host 6881:6881  15080:15080  1080:1080  ring-mqtt non-host 8554:8554  55123:55123  rtl_433 non-host scrypted host 10443:10443  syncthing host tasmoadmin non-host 8088:80  telegraf non-host 8092:8092  8094:8094  8125:8125  timescaledb non-host transmission non-host 9091:9091  51413:51413  webthingsio_gateway host wireguard non-host 51820:51820  zerotier host zerotier host zigbee2mqtt non-host 8080:8080  zigbee2mqtt_assistant non-host 8880:80"},{"location":"Basic_setup/Docker/","title":"Docker","text":""},{"location":"Basic_setup/Docker/#logging","title":"Logging","text":"<p>When Docker starts a container, it executes its entrypoint command. Any output produced by this command is logged by Docker. By default Docker stores logs internally together with other data associated to the container image.</p> <p>This has the effect that when recreating or updating a container, logs shown by <code>docker-compose logs</code> won't show anything associated with the previous instance. Use <code>docker system prune</code> to remove old instances and free up disk space. Keeping logs only for the latest instance is helpful when testing, but may not be desirable for production.</p> <p>By default there is no limit on the log size. Surprisingly, when using a SD-card this is exactly what you want. If a runaway container floods the log with output, writing will stop when the disk becomes full. Without a mechanism to prevent such excessive writing, the SD-card would keep being written to until the flash hardware program-erase cycle limit is reached, after which it is permanently broken.</p> <p>When using a quality SSD-drive, potential flash-wear isn't usually a concern. Then you can enable log-rotation by either:</p> <ol> <li> <p>Configuring Docker to do it for you automatically. Edit your     <code>docker-compose.yml</code> and add a top-level x-logging and a logging: to     each service definition. The Docker compose reference documentation has     a good example.</p> </li> <li> <p>Configuring Docker to log to the host system's journald.</p> <p>ps. if <code>/etc/docker/daemon.json</code> doesn't exist, just create it.</p> </li> </ol>"},{"location":"Basic_setup/Docker/#aliases","title":"Aliases","text":"<p>Bash aliases for stopping and starting the stack and other common operations are in the file <code>.bash_aliases</code>. To use them immediately and in future logins, run in a console:</p> <pre><code>$ source ~/IOTstack/.bash_aliases\n$ echo \"source ~/IOTstack/.bash_aliases\" &gt;&gt; ~/.profile\n</code></pre> <p>These commands no longer need to be executed from the IOTstack directory and can be executed in any directory</p> .bash_aliases<pre><code>IOTSTACK_HOME=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" &amp;&amp; pwd)\"\nalias iotstack_up=\"cd \"$IOTSTACK_HOME\" &amp;&amp; docker-compose up -d --remove-orphans\"\nalias iotstack_down=\"cd \"$IOTSTACK_HOME\" &amp;&amp; docker-compose down --remove-orphans\"\nalias iotstack_start=\"cd \"$IOTSTACK_HOME\" &amp;&amp; docker-compose start\"\nalias iotstack_stop=\"cd \"$IOTSTACK_HOME\" &amp;&amp; docker-compose stop\"\nalias iotstack_pull=\"cd \"$IOTSTACK_HOME\" &amp;&amp; docker-compose pull\"\nalias iotstack_build=\"cd \"$IOTSTACK_HOME\" &amp;&amp; docker-compose build --pull --no-cache\"\nalias iotstack_update_docker_images='f(){ iotstack_pull \"$@\" &amp;&amp; iotstack_build \"$@\" &amp;&amp; iotstack_up --build \"$@\"; }; f'\n</code></pre> <p>You can now type <code>iotstack_up</code>. The aliases also accept additional parameters, e.g. <code>iotstack_stop portainer</code>.</p> <p>The <code>iotstack_update_docker_images</code> alias will update docker images to newest released images, build and recreate containers. Do note that using this will result in a broken containers from time to time, as upstream may release faulty docker images. Have proper backups, or be prepared to manually pin a previous release build by editing <code>docker-compose.yml</code>.</p>"},{"location":"Basic_setup/Menu/","title":"Menu","text":"<p>The <code>menu.sh</code>-script is used to create or modify the <code>docker-compose.yml</code>-file. This file defines how all containers added to the stack are configured.</p>"},{"location":"Basic_setup/Menu/#miscellaneous","title":"Miscellaneous","text":""},{"location":"Basic_setup/Menu/#log2ram","title":"log2ram","text":"<p>One of the drawbacks of an sd card is that it has a limited lifespan. One way to reduce the load on the sd card is to move your log files to RAM. log2ram is a convenient tool to simply set this up. It can be installed from the miscellaneous menu.</p> <p>This only affects logs written to /var/log, and won't have any effect on Docker logs or logs stored inside containers.</p>"},{"location":"Basic_setup/Menu/#dropbox-uploader","title":"Dropbox-Uploader","text":"<p>This a great utility to easily upload data from your PI to the cloud. The MagPi has an excellent explanation of the process of setting up the Dropbox API. Dropbox-Uploader is used in the backup script.</p>"},{"location":"Basic_setup/Menu/#backup-and-restore","title":"Backup and Restore","text":"<p>See Backing up and restoring IOTstack</p>"},{"location":"Basic_setup/Menu/#native-installs","title":"Native Installs","text":""},{"location":"Basic_setup/Menu/#rtl_433","title":"RTL_433","text":"<p>RTL_433 can be installed from the \"Native install sections\"</p> <p>This video demonstrates how to use RTL_433</p>"},{"location":"Basic_setup/Menu/#rpieasy","title":"RPIEasy","text":"<p>The installer will install any dependencies. If <code>~/rpieasy</code> exists it will update the project to its latest, if not it will clone the project</p> <p>RPIEasy can be run by <code>sudo ~/rpieasy/RPIEasy.py</code></p> <p>To have RPIEasy start on boot in the webui under hardware look for \"RPIEasy autostart at boot\"</p> <p>RPIEasy will select its ports from the first available one in the list (80,8080,8008). If you run Hass.io then there will be a conflict so check the next available port</p>"},{"location":"Basic_setup/Menu/#old-menu-branch-details","title":"Old-menu branch details","text":"<p>The build script creates the ./services directory and populates it from the template file in .templates . The script then appends the text withing each service.yml file to the docker-compose.yml . When the stack is rebuilt the menu does not overwrite the service folder if it already exists. Make sure to sync any alterations you have made to the docker-compose.yml file with the respective service.yml so that on your next build your changes pull through.</p> <p>The .gitignore file is setup such that if you do a <code>git pull origin master</code> it does not overwrite the files you have already created. Because the build script does not overwrite your service directory any changes in the .templates directory will have no affect on the services you have already made. You will need to move your service folder out to get the latest version of the template.</p>"},{"location":"Basic_setup/Networking/","title":"Networking","text":"<p>The docker-compose instruction creates an internal network for the containers to communicate in, the ports get exposed to the PI's IP address when you want to connect from outside. It also creates a \"DNS\" the name being the container name. So it is important to note that when one container talks to another they talk by name. All the containers names are lowercase like nodered, influxdb...</p> <p>An easy way to find out your IP is by typing <code>ip address</code> in the terminal and look next to eth0 or wlan0 for your IP. It is highly recommended that you set a static IP for your PI or at least reserve an IP on your router so that you know it</p> <p>Check the docker-compose.yml to see which ports have been used</p> <p></p>"},{"location":"Basic_setup/Networking/#examples","title":"Examples","text":"<ul> <li>You want to connect your nodered to your mqtt server. In nodered drop an mqtt node, when you need to specify the address type <code>mosquitto</code></li> <li>You want to connect to your influxdb from grafana. You are in the Docker network and you need to use the name of the Container. The address you specify in the grafana is <code>http://influxdb:8086</code></li> <li>You want to connect to the web interface of grafana from your laptop. Now you are outside the container environment you type PI's IP eg 192.168.n.m:3000</li> </ul>"},{"location":"Basic_setup/Networking/#ports","title":"Ports","text":"<p>Many containers try to use popular ports such as 80,443,8080. For example openHAB and Adminer both want to use port 8080 for their web interface. Adminer's port has been moved 9080 to accommodate this. Please check the description of the container in the README to see if there are any changes as they may not be the same as the port you are used to.</p> <p>Port mapping is done in the docker-compose.yml file. Each service should have a section that reads like this: <pre><code>    ports:\n      - HOST_PORT:CONTAINER_PORT\n</code></pre> For adminer: <pre><code>    ports:\n      - 9080:8080\n</code></pre> Port 9080 on Host Pi is mapped to port 8080 of the container. Therefore 127.0.0.1:8080 will take you to openHAB, where 127.0.0.1:9080 will take you to adminer</p>"},{"location":"Basic_setup/Troubleshooting/","title":"Troubleshooting","text":""},{"location":"Basic_setup/Troubleshooting/#resources","title":"Resources","text":"<ul> <li> <p>Search github issues.</p> <ul> <li>Closed issues or pull-requests may also have valuable hints.</li> </ul> </li> <li> <p>Ask questions on IOTStack Discord. Or report     how you were able to fix a problem.</p> </li> <li> <p>There are over 40 gists about IOTstack. These address a diverse range of     topics from small convenience scripts to complete guides. These are     individual contributions that aren't reviewed.</p> <p>You can add your own keywords into the search: https://gist.github.com/search?q=iotstack</p> </li> </ul>"},{"location":"Basic_setup/Troubleshooting/#faq","title":"FAQ","text":"<p>Breaking update</p> <p>A change done 2022-01-18 will require manual steps or you may get an error like: <code>ERROR: Service \"influxdb\" uses an undefined network \"iotstack_nw\"</code></p>"},{"location":"Basic_setup/Troubleshooting/#device-errors","title":"Device Errors","text":"<p>If you are trying to run IOTstack on non-Raspberry Pi hardware, you will probably get the following error from <code>docker-compose</code> when you try to bring up your stack for the first time:</p> <pre><code>Error response from daemon: error gathering device information while adding custom device \"/dev/ttyAMA0\": no such file or directory\n</code></pre> <p>You will get a similar message about any device which is not known to your hardware.</p> <p>The <code>/dev/ttyAMA0</code> device is the Raspberry Pi's built-in serial port so it is guaranteed to exist on any \"real\" Raspberry Pi. As well as being referenced by containers that can actually use the serial port, <code>ttyAMA0</code> is often employed as a placeholder.</p> <p>Examples:</p> <ul> <li>Node-RED flows can use the <code>node-red-node-serialport</code> node to access the serial port. This is an example of \"actual use\";</li> <li> <p>The Zigbee2MQTT container employs <code>ttyAMA0</code> as a placeholder. This allows the container to start. Once you have worked out how your Zigbee adapter appears on your system, you will substitute your adapter's actual device path. For example:</p> <pre><code>- \"/dev/serial/by-id/usb-Texas_Instruments_TI_CC2531_USB_CDC___0X00125B0028EEEEE0-if00:/dev/ttyACM0\"\n</code></pre> </li> </ul> <p>The simplest approach to solving \"error gathering device information\" problems is just to comment-out every device mapping that produces an error and, thereafter, treat the comments as documentation about what the container is expecting at run-time. For example, this is the devices list for Node-RED:</p> <pre><code>  devices:\n    - \"/dev/ttyAMA0:/dev/ttyAMA0\"\n    - \"/dev/vcio:/dev/vcio\"\n    - \"/dev/gpiomem:/dev/gpiomem\"\n</code></pre> <p>Those are, in turn, the Raspberry Pi's:</p> <ul> <li>serial port</li> <li>videoCore multimedia processor</li> <li>mechanism for accessing GPIO pin headers</li> </ul> <p>If none of those is available on your chosen platform (the usual situation on non-Pi hardware), commenting-out the entire block is appropriate:</p> <pre><code># devices:\n#   - \"/dev/ttyAMA0:/dev/ttyAMA0\"\n#   - \"/dev/vcio:/dev/vcio\"\n#   - \"/dev/gpiomem:/dev/gpiomem\"\n</code></pre> <p>You interpret each line in a device map like this:</p> <pre><code>    - \"\u00abexternal\u00bb:\u00abinternal\u00bb\"\n</code></pre> <p>The \u00abexternal\u00bb device is what the platform (operating system plus hardware) sees. The \u00abinternal\u00bb device is what the container sees. Although it is reasonably common for the two sides to be the same, this is not a requirement. It is usual to replace the \u00abexternal\u00bb device with the actual device while leaving the \u00abinternal\u00bb device unchanged.</p> <p>Here is an example. On macOS, a CP2102 USB-to-Serial adapter shows up as:</p> <pre><code>/dev/cu.SLAB_USBtoUART\n</code></pre> <p>Assume you are running the Node-RED container in macOS Docker Desktop, and that you want a flow to communicate with the CP2102. You would change the service definition like this:</p> <pre><code>  devices:\n    - \"/dev/cu.SLAB_USBtoUART:/dev/ttyAMA0\"\n#   - \"/dev/vcio:/dev/vcio\"\n#   - \"/dev/gpiomem:/dev/gpiomem\"\n</code></pre> <p>In other words, the \u00abexternal\u00bb (real world) device <code>cu.SLAB_USBtoUART</code> is mapped to the \u00abinternal\u00bb (container) device <code>ttyAMA0</code>. The flow running in the container is expecting to communicate with <code>ttyAMA0</code> and is none-the-wiser.</p>"},{"location":"Basic_setup/Troubleshooting/#needing-to-use-sudo-to-run-docker-commands","title":"Needing to use <code>sudo</code> to run docker commands","text":"<p>You should never (repeat never) use <code>sudo</code> to run docker or docker compose commands. Forcing docker to do something with <code>sudo</code> almost always creates more problems than it solves. Please see What is sudo? to understand how <code>sudo</code> actually works.</p> <p>If <code>docker</code> or <code>docker-compose</code> commands seem to need elevated privileges, the most likely explanation is incorrect group membership. Please read the next section about errors involving <code>docker.sock</code>. The solution (two <code>usermod</code> commands) is the same.</p> <p>If, however, the current user is a member of the <code>docker</code> group but you still get error responses that seem to imply a need for <code>sudo</code>, it implies that something fundamental is broken. Rather than resorting to <code>sudo</code>, you are better advised to rebuild your system.</p>"},{"location":"Basic_setup/Troubleshooting/#dockerGroup","title":"Errors involving <code>docker.sock</code>","text":"<p>If you encounter permission errors that mention <code>/var/run/docker.sock</code>, the most likely explanation is the current user (usually \"pi\") not being a member of the \"docker\" group.</p> <p>You can check membership with the <code>groups</code> command:</p> <pre><code>$ groups\npi adm dialout cdrom sudo audio video plugdev games users input render netdev bluetooth lpadmin docker gpio i2c spi\n</code></pre> <p>In that list, you should expect to see both <code>bluetooth</code> and <code>docker</code>. If you do not, you can fix the problem like this:</p> <pre><code>$ sudo usermod -G docker -a $USER\n$ sudo usermod -G bluetooth -a $USER\n$ exit\n</code></pre> <p>The <code>exit</code> statement is required. You must logout and login again for the two <code>usermod</code> commands to take effect. An alternative is to reboot.</p>"},{"location":"Basic_setup/Troubleshooting/#system-freezes-or-ssd-problems","title":"System freezes or SSD problems","text":"<p>You should read this section if you experience any of the following problems:</p> <ul> <li>Apparent system hangs, particularly if Docker containers were running at the time the system was shutdown or rebooted;</li> <li>Much slower than expected performance when reading/writing your SSD; or</li> <li>Suspected data-corruption on your SSD.</li> </ul>"},{"location":"Basic_setup/Troubleshooting/#try-a-usb2-port","title":"Try a USB2 port","text":"<p>Start by shutting down your Pi and moving your SSD to one of the USB2 ports. The slower speed will often alleviate the problem.</p> <p>Tips:</p> <ol> <li> <p>If you don't have sufficient control to issue a shutdown and/or your Pi won't shut down cleanly:</p> <ul> <li>remove power</li> <li>move the SSD to a USB2 port</li> <li>apply power again.</li> </ul> </li> <li> <p>If you run \"headless\" and find that the Pi responds to pings but you can't connect via SSH:</p> <ul> <li>remove power</li> <li>connect the SSD to a support platform (Linux, macOS, Windows)</li> <li>create a file named \"ssh\" at the top level of the boot partition</li> <li>eject the SSD from your support platform</li> <li>connect the SSD to a USB2 port on your Pi</li> <li>apply power again.</li> </ul> </li> </ol>"},{"location":"Basic_setup/Troubleshooting/#check-the-dhcpcd-patch","title":"Check the <code>dhcpcd</code> patch","text":"<p>Next, verify that the dhcpcd patch is installed. There seems to be a timing component to the deadlock which is why it can be alleviated, to some extent, by switching the SSD to a USB2 port.</p> <p>If the <code>dhcpcd</code> patch was not installed but you have just installed it, try returning the SSD to a USB3 port.</p>"},{"location":"Basic_setup/Troubleshooting/#try-a-quirks-string","title":"Try a quirks string","text":"<p>If problems persist even when the <code>dhcpcd</code> patch is in place, you may have an SSD which isn't up to the Raspberry Pi's expectations. Try the following:</p> <ol> <li>If your IOTstack is running, take it down.</li> <li>If your SSD is attached to a USB3 port, shut down your Pi, move the SSD to a USB2 port, and apply power.</li> <li> <p>Run the following command:</p> <pre><code>$ dmesg | grep \"\\] usb [[:digit:]]-\"\n</code></pre> <p>In the output, identify your SSD. Example:</p> <pre><code>[    1.814248] usb 2-1: new SuperSpeed Gen 1 USB device number 2 using xhci_hcd\n[    1.847688] usb 2-1: New USB device found, idVendor=f0a1, idProduct=f1b2, bcdDevice= 1.00\n[    1.847708] usb 2-1: New USB device strings: Mfr=99, Product=88, SerialNumber=77\n[    1.847723] usb 2-1: Product: Blazing Fast SSD\n[    1.847736] usb 2-1: Manufacturer: Suspect Drives\n</code></pre> <p>In the above output, the second line contains the Vendor and Product codes that you need:</p> <ul> <li><code>idVendor=f0a1</code></li> <li><code>idProduct=f1b2</code></li> </ul> </li> <li> <p>Substitute the values of \u00abidVendor\u00bb and \u00abidProduct\u00bb into the following command template:</p> <pre><code>sed -i.bak '1s/^/usb-storage.quirks=\u00abidVendor\u00bb:\u00abidProduct\u00bb:u /' \"$CMDLINE\"\n</code></pre> <p>This is known as a \"quirks string\". Given the <code>dmesg</code> output above, the string would be:</p> <pre><code>sed -i.bak '1s/^/usb-storage.quirks=f0a1:f1b2:u /' \"$CMDLINE\"\n</code></pre> <p>Make sure that you keep the space between the <code>:u</code> and <code>/'</code>. You risk breaking your system if that space is not there.</p> </li> <li> <p>Run these commands - the second line is the one you prepared in step 4 using <code>sudo</code>:</p> <pre><code>$ CMDLINE=\"/boot/firmware/cmdline.txt\" &amp;&amp; [ -e \"$CMDLINE\" ] || CMDLINE=\"/boot/cmdline.txt\"\n$ sudo sed -i.bak '1s/^/usb-storage.quirks=f0a1:f1b2:u /' \"$CMDLINE\"\n</code></pre> <p>The command:</p> <ul> <li>makes a backup copy of <code>cmdline.txt</code> as <code>cmdline.txt.bak</code></li> <li>inserts the quirks string at the start of <code>cmdline.txt</code>.</li> </ul> <p>You can confirm the result as follows:</p> <ul> <li> <p>display the original (baseline reference):</p> <pre><code>$ cat \"$CMDLINE.bak\"\nconsole=serial0,115200 console=tty1 root=PARTUUID=06c69364-02 rootfstype=ext4 fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles\n</code></pre> </li> <li> <p>display the modified version:</p> <pre><code>$ cat \"$CMDLINE\"\nusb-storage.quirks=f0a1:f1b2:u console=serial0,115200 console=tty1 root=PARTUUID=06c69364-02 rootfstype=ext4 fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles\n</code></pre> </li> </ul> </li> <li> <p>Shutdown your Pi.</p> </li> <li>Connect your SSD to a USB3 port and apply power.</li> </ol> <p>There is more information about this problem on the Raspberry Pi forum.</p>"},{"location":"Basic_setup/Troubleshooting/#getting-a-clean-slate","title":"Getting a clean slate","text":"<p>If you create a mess and can't see how to recover, try proceeding like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down\n$ cd\n$ mv IOTstack IOTstack.old\n$ git clone https://github.com/SensorsIot/IOTstack.git IOTstack\n</code></pre> <p>In words:</p> <ol> <li>Be in the right directory.</li> <li>Take the stack down.</li> <li>The <code>cd</code> command without any arguments changes your working directory to    your home directory (variously known as <code>~</code> or <code>$HOME</code> or <code>/home/pi</code>).</li> <li> <p>Move your existing IOTstack directory out of the way. If you get a    permissions problem:</p> <ul> <li>Re-try the command with <code>sudo</code>; and</li> <li>Read a word about the <code>sudo</code> command. Needing <code>sudo</code>   in this situation is an example of over-using <code>sudo</code>.</li> </ul> </li> <li> <p>Check out a clean copy of IOTstack.</p> </li> </ol> <p>Now, you have a clean slate and can start afresh by running the menu:</p> <pre><code>$ cd ~/IOTstack\n$ ./menu.sh\n</code></pre> <p>The <code>IOTstack.old</code> directory remains available as a reference for as long as you need it. Once you have no further use for it, you can clean it up via:</p> <pre><code>$ cd\n$ sudo rm -rf ./IOTstack.old # (1)\n</code></pre> <ol> <li>The <code>sudo</code> command is needed in this situation because some files and    folders (eg the \"volumes\" directory and most of its contents) are owned by    root.</li> </ol>"},{"location":"Basic_setup/Understanding-Containers/","title":"What is Docker?","text":"<p>In simple terms, Docker is a software platform that simplifies the process of building, running,  managing and distributing applications. It does this by virtualizing the operating system of the  computer on which it is installed and running.</p>"},{"location":"Basic_setup/Understanding-Containers/#the-problem","title":"The Problem","text":"<p>Let\u2019s say you have three different Python-based applications that you plan to host on a single server  (which could either be a physical or a virtual machine).</p> <p>Each of these applications makes use of a different version of Python, as well as the associated  libraries and dependencies, differ from one application to another.</p> <p>Since we cannot have different versions of Python installed on the same machine, this prevents us from  hosting all three applications on the same computer.</p>"},{"location":"Basic_setup/Understanding-Containers/#the-solution","title":"The Solution","text":"<p>Let\u2019s look at how we could solve this problem without making use of Docker. In such a scenario, we  could solve this problem either by having three physical machines, or a single physical machine, which  is powerful enough to host and run three virtual machines on it.</p> <p>Both the options would allow us to install different versions of Python on each of these machines,  along with their associated dependencies.</p> <p>The machine on which Docker is installed and running is usually referred to as a Docker Host or Host in simple terms. So, whenever you plan to deploy an application on the host, it would create a logical  entity on it to host that application. In Docker terminology, we call this logical entity a Container or  Docker Container to be more precise.</p> <p>Whereas the kernel of the host\u2019s operating system is shared across all the containers that are running  on it.</p> <p>This allows each container to be isolated from the other present on the same host. Thus it supports  multiple containers with different application requirements and dependencies to run on the same host,  as long as they have the same operating system requirements.</p>"},{"location":"Basic_setup/Understanding-Containers/#docker-terminology","title":"Docker Terminology","text":"<p>Docker Images and Docker Containers are the two essential things that you will come across daily while  working with Docker.</p> <p>In simple terms, a Docker Image is a template that contains the application, and all the dependencies  required to run that application on Docker.</p> <p>On the other hand, as stated earlier, a Docker Container is a logical entity. In more precise terms,  it is a running instance of the Docker Image.</p>"},{"location":"Basic_setup/Understanding-Containers/#what-is-docker-compose","title":"What is Docker-Compose?","text":"<p>Docker Compose provides a way to orchestrate multiple containers that work together. Docker compose  is a simple yet powerful tool that is used to run multiple containers as a single service.  For example, suppose you have an application which requires Mqtt as a communication service between IOT devices and OpenHAB instance as a Smarthome application service. In this case by docker-compose, you can create one  single file (docker-compose.yml) which will create both the containers as a single service without starting  each separately. It wires up the networks (literally), mounts all volumes and exposes the ports.</p> <p>The IOTstack with the templates and menu is a generator for that docker-compose service descriptor.</p>"},{"location":"Basic_setup/Understanding-Containers/#how-docker-compose-works","title":"How Docker Compose Works?","text":"<p>use yaml files to configure application services (docker-compose.yaml) can start all the services with a single command ( docker-compose up ) can stop all the service with a single command ( docker-compose down )</p>"},{"location":"Basic_setup/Understanding-Containers/#how-are-the-containers-connected","title":"How are the containers connected","text":"<p>The containers are automagically connected when we run the stack with docker-compose up.  The containers using same logical network (by default) where the instances can access each other with the instance  logical name. Means if there is an instance called mosquitto and an openhab, when openHAB instance need to access mqtt on that case the domain name of mosquitto will be resolved as the runnuning instance of mosquitto.</p>"},{"location":"Basic_setup/Understanding-Containers/#how-the-container-are-connected-to-host-machine","title":"How the container are connected to host machine","text":""},{"location":"Basic_setup/Understanding-Containers/#volumes","title":"Volumes","text":"<p>The containers are enclosed processes which state are lost with the restart of container. To be able to  persist states volumes (images or directories) can be used to share data with the host.  Which means if you need to persist some database, configuration or any state you have to bind volumes where the  running service inside the container will write files to that binded volume. In order to understand what a Docker volume is, we first need to be clear about how the filesystem normally works  in Docker. Docker images are stored as series of read-only layers. When we start a container, Docker takes  the read-only image and adds a read-write layer on top. If the running container modifies an existing file,  the file is copied out of the underlying read-only layer and into the top-most read-write layer where the  changes are applied. The version in the read-write layer hides the underlying file, but does not  destroy it -- it still exists in the underlying layer. When a Docker container is deleted,  relaunching the image will start a fresh container without any of the changes made in the previously  running container -- those changes are lost, thats the reason that configs, databases are not persisted,</p> <p>Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure of the host machine, volumes are completely  managed by Docker. In IOTstack project uses the volumes directory in general to bind these container volumes.</p>"},{"location":"Basic_setup/Understanding-Containers/#ports","title":"Ports","text":"<p>When containers running a we would like to delegate some services to the outside world, for example OpenHAB web frontend have to be accessible for users. There are several ways to achive that. One is mounting the port to the most machine, this called port binding. On that case service will have a dedicated port which can be accessed, one drawback is one host port can be used one serice only. Another way is reverse proxy.  The term reverse proxy (or Load Balancer in some terminology) is normally applied to a service that sits in front  of one or more servers (in our case containers), accepting requests from clients for resources located on the  server(s). From the client point of view, the reverse proxy appears to be the web server and so is  totally transparent to the remote user. Which means several service can share same port the server will route the request by the URL (virtual domain or context path). For example, there is grafana and openHAB instances, where the opeanhab.domain.tld request will be routed to openHAB instance 8181 port while  grafana.domain.tld to grafana instance 3000 port. On that case the proxy have to be mapped for host port 80 and/or 444 on host machine, the proxy server will access the containers via the docker virtual network.</p> <p>Source materials used:</p> <p>https://takacsmark.com/docker-compose-tutorial-beginners-by-example-basics/ https://www.freecodecamp.org/news/docker-simplified-96639a35ff36/ https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/ https://blog.container-solutions.com/understanding-volumes-docker</p>"},{"location":"Basic_setup/What-is-sudo/","title":"What is sudo?","text":"<p>Many first-time users of IOTstack get into difficulty by misusing the <code>sudo</code> command. The problem is best understood by example. In the following, you would expect <code>~</code> (tilde) to expand to <code>/home/pi</code>. It does:</p> <pre><code>$ echo ~/IOTstack\n/home/pi/IOTstack\n</code></pre> <p>The command below sends the same <code>echo</code> command to <code>bash</code> for execution. This is what happens when you type the name of a shell script. You get a new instance of <code>bash</code> to run the script:</p> <pre><code>$ bash -c 'echo ~/IOTstack'\n/home/pi/IOTstack\n</code></pre> <p>Same answer. Again, this is what you expect. But now try it with <code>sudo</code> on the front:</p> <pre><code>$ sudo bash -c 'echo ~/IOTstack'\n/root/IOTstack\n</code></pre> <p>Different answer. It is different because <code>sudo</code> means \"become root, and then run the command\". The process of becoming root changes the home directory, and that changes the definition of <code>~</code>.</p> <p>Any script designed for working with IOTstack assumes <code>~</code> (or the equivalent <code>$HOME</code> variable) expands to <code>/home/pi</code>. That assumption is invalidated if the script is run by <code>sudo</code>.</p> <p>Of necessity, any script designed for working with IOTstack will have to invoke <code>sudo</code> inside the script when it is required. You do not need to second-guess the script's designer.</p> <p>Please try to minimise your use of <code>sudo</code> when you are working with IOTstack. Here are some rules of thumb:</p> <ol> <li> <p>Is what you are about to run a script? If yes, check whether the script already contains <code>sudo</code> commands. Using <code>menu.sh</code> as the example:</p> <pre><code>$ grep -c 'sudo' ~/IOTstack/menu.sh\n28\n</code></pre> <p>There are numerous uses of <code>sudo</code> within <code>menu.sh</code>. That means the designer thought about when <code>sudo</code> was needed.</p> </li> <li> <p>Did the command you just executed work without <code>sudo</code>? Note the emphasis on the past tense. If yes, then your work is done. If no, and the error suggests elevated privileges are necessary, then re-execute the last command like this:</p> <pre><code>$ sudo !!\n</code></pre> </li> </ol> <p>It takes time, patience and practice to learn when <code>sudo</code> is actually needed. Over-using <code>sudo</code> out of habit, or because you were following a bad example you found on the web, is a very good way to find that you have created so many problems for yourself that will need to reinstall your IOTstack. Please err on the side of caution!</p>"},{"location":"Basic_setup/What-is-sudo/#configuration","title":"Configuration","text":"<p>To edit sudo functionality and permissions use: <code>sudo visudo</code></p> <p>For instance, to allow sudo usage without prompting for a password: <pre><code># Allow members of group sudo to execute any command without password prompt\n%sudo   ALL=(ALL:ALL) NOPASSWD:ALL\n</code></pre></p> <p>For more information: <code>man sudoers</code></p>"},{"location":"Containers/AdGuardHome/","title":"AdGuard Home","text":""},{"location":"Containers/AdGuardHome/#references","title":"References","text":"<ul> <li>AdGuard Home GitHub</li> <li>AdGuard Home DockerHub</li> </ul>"},{"location":"Containers/AdGuardHome/#either-adguard-home-or-pihole-but-not-both","title":"Either AdGuard Home or PiHole, but not both","text":"<p>AdGuard Home and PiHole perform similar functions. They use the same ports so you can not run both at the same time. You must choose one or the other.</p>"},{"location":"Containers/AdGuardHome/#quickStart","title":"Quick Start","text":"<p>When you first install AdGuard Home:</p> <ol> <li> <p>Use a web browser to connect to it using port 3001. For example:</p> <pre><code>http://raspberrypi.local:3001\n</code></pre> </li> <li> <p>Click \"Getting Started\".</p> </li> <li> <p>Change the port number for the Admin Web Interface to be \"8089\". Leave the other settings on the page at their defaults and click \"Next\".</p> </li> <li>Enter a username and password and click \"Next\".</li> <li>Click \"Open Dashboard\". This redirects to port 8089.</li> <li> <p>After the initial setup, you connect to AdGuard Home via port 8089:</p> <pre><code>http://raspberrypi.local:8089\n</code></pre> </li> </ol>"},{"location":"Containers/AdGuardHome/#about-port-8089","title":"About port 8089","text":"<p>Port 8089 is the default administrative user interface for AdGuard Home running under IOTstack.</p> <p>Port 8089 is not active until you have completed the Quick Start procedure. You must start by connecting to port 3001.</p> <p>Because of AdGuard Home limitations, you must take special precautions if you decide to change to a different port number:</p> <ol> <li> <p>The internal and external ports must be the same; and</p> </li> <li> <p>You must convince AdGuard Home that it is a first-time installation: </p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop adguardhome\n$ docker-compose rm -f adguardhome\n$ sudo rm -rf ./volumes/adguardhome\n$ docker-compose up -d adguardhome\n</code></pre> </li> <li> <p>Repeat the Quick Start procedure, this time substituting the new Admin Web Interface port where you see \"8089\".</p> </li> </ol>"},{"location":"Containers/AdGuardHome/#about-port-30013000","title":"About port 3001:3000","text":"<p>Port 3001 (external, 3000 internal) is only used during Quick Start procedure. Once port 8089 becomes active, port 3001 ceases to be active.</p> <p>In other words, you need to keep port 3001 reserved even though it is only ever used to set up port 8089.</p>"},{"location":"Containers/AdGuardHome/#about-host-mode","title":"About Host Mode","text":"<p>If you want to run AdGuard Home as your DHCP server, you need to put the container into \"host mode\". You need edit the AdGuard Home service definition in <code>docker-compose.yml</code> to:</p> <ol> <li> <p>add the line:</p> <pre><code>network_mode: host\n</code></pre> </li> <li> <p>remove the <code>ports:</code> directive and all of the port mappings.</p> </li> </ol> <p>Note:</p> <ul> <li>It is not really a good idea to offer DHCP services from a container. This is because containers generally start far too late in a boot process to be useful. If you want to use AdGuard Home for DHCP, you should probably consider a native installation.</li> </ul>"},{"location":"Containers/Adminer/","title":"Adminer","text":""},{"location":"Containers/Adminer/#references","title":"References","text":"<ul> <li>Docker</li> <li>Website</li> </ul>"},{"location":"Containers/Adminer/#about","title":"About","text":"<p>This is a nice tool for managing databases. Web interface has moved to port 9080. There was an issue where openHAB and Adminer were using the same ports. If you have an port conflict edit the docker-compose.yml and under the adminer service change the line to read: <pre><code>    ports:\n      - 9080:8080\n</code></pre></p>"},{"location":"Containers/Blynk_server/","title":"Blynk server","text":"<p>This document discusses an IOTstack-specific version of Blynk-Server. It is built on top of an Ubuntu base image using a Dockerfile.</p>"},{"location":"Containers/Blynk_server/#references","title":"References","text":"<ul> <li>Ubuntu base image at DockerHub</li> <li>Peter Knight Blynk-Server fork at GitHub (includes documentation)</li> <li>Peter Knight Blynk-Server releases at GitHub</li> <li>Blynk home page at blynk.io</li> <li>Blynk documentation at blynk.io</li> <li>Blynk community forum at community.blynk.cc</li> <li>Interesting post by Peter Knight on MQTT/Node Red flows  at community.blynk.cc</li> <li>Blynk flow examples at GitHub</li> </ul> <p>Acknowledgement:</p> <ul> <li>Original writeup from @877dev</li> </ul>"},{"location":"Containers/Blynk_server/#significantFiles","title":"Significant directories and files","text":"<pre><code>~/IOTstack\n\u251c\u2500\u2500 .templates\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 blynk_server\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 Dockerfile \u2776\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 docker-entrypoint.sh \u2777\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 iotstack_defaults \u2778\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mail.properties\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 server.properties\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 service.yml \u2779\n\u251c\u2500\u2500 services\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 blynk_server\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 service.yml \u277a\n\u251c\u2500\u2500 docker-compose.yml \u277b\n\u2514\u2500\u2500 volumes\n    \u2514\u2500\u2500 blynk_server \u277c\n     \u00a0\u00a0 \u251c\u2500\u2500 config \u277d\n     \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 mail.properties\n     \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 server.properties\n     \u00a0\u00a0 \u2514\u2500\u2500 data\n</code></pre> <ol> <li>The Dockerfile used to construct Blynk Server on top of Ubuntu.</li> <li>A start-up script designed to handle container self-repair.</li> <li>A folder holding the default versions of the configuration files.</li> <li>The template service definition.</li> <li>The working service definition (only relevant to old-menu, copied from \u2779).</li> <li>The Compose file (includes \u2779).</li> <li>The persistent storage area for the <code>blynk_server</code> container.</li> <li>Working copies of the configuration files (copied from \u2778).</li> </ol> <p>Everything in \u277d:</p> <ul> <li>will be replaced if it is not present when the container starts; but</li> <li>will never be overwritten if altered by you.</li> </ul>"},{"location":"Containers/Blynk_server/#howBlynkServerIOTstackGetsBuilt","title":"How Blynk Server gets built for IOTstack","text":""},{"location":"Containers/Blynk_server/#dockerHubImages","title":"GitHub Updates","text":"<p>Periodically, the source code is updated and a new version is released. You can check for the latest version at the releases page.</p>"},{"location":"Containers/Blynk_server/#iotstackMenu","title":"IOTstack menu","text":"<p>When you select Blynk Server in the IOTstack menu, the template service definition is copied into the Compose file.</p> <p>Under old menu, it is also copied to the working service definition and then not really used.</p>"},{"location":"Containers/Blynk_server/#iotstackFirstRun","title":"IOTstack first run","text":"<p>On a first install of IOTstack, you run the menu, choose your containers, and are told to do this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p><code>docker-compose</code> reads the Compose file. When it arrives at the <code>blynk_server</code> fragment, it finds:</p> <pre><code>  blynk_server:\n    build:\n      context: ./.templates/blynk_server/.\n      args:\n        - BLYNK_SERVER_VERSION=0.41.16\n</code></pre> <p>The <code>build</code> statement tells <code>docker-compose</code> to look for:</p> <pre><code>~/IOTstack/.templates/blynk_server/Dockerfile\n</code></pre> <p>The <code>BLYNK_SERVER_VERSION</code> argument is passed into the build process. This implicitly pins each build to the version number in the Compose file (eg 0.41.16). If you need to update to a  </p> <p>The Dockerfile is in the <code>.templates</code> directory because it is intended to be a common build for all IOTstack users. This is different to the arrangement for Node-RED where the Dockerfile is in the <code>services</code> directory because it is how each individual IOTstack user's version of Node-RED is customised.</p> <p>The Dockerfile begins with:</p> <pre><code>FROM ubuntu\n</code></pre> <p>The <code>FROM</code> statement tells the build process to pull down the base image from DockerHub.</p> <p>It is a base image in the sense that it never actually runs as a container on your Raspberry Pi.</p> <p>The remaining instructions in the Dockerfile customise the base image to produce a local image. The customisations are:</p> <ol> <li>Add packages to satisfy dependencies.</li> <li>Add the default versions of the configuration files so that the container can perform self-repair each time it is launched.</li> <li>Download an install the Java package that implements the Blynk Server. </li> </ol> <p>The local image is instantiated to become your running container.</p> <p>When you run the <code>docker images</code> command after Blynk Server has been built, you may see two rows that are relevant:</p> <pre><code>$ docker images\nREPOSITORY              TAG      IMAGE ID       CREATED         SIZE\niotstack_blynk_server   latest   3cd6445f8a7e   3 hours ago     652MB\nubuntu                  latest   897590a6c564   7 days ago      49.8MB\n</code></pre> <ul> <li><code>ubuntu</code> is the base image; and</li> <li><code>iotstack_blynk_server</code> is the local image.</li> </ul> <p>You may see the same pattern in Portainer, which reports the base image as \"unused\". You should not remove the base image, even though it appears to be unused.</p> <p>Whether you see one or two rows depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Blynk_server/#logging","title":"Logging","text":"<p>You can inspect Blynk Server's log by:</p> <pre><code>$ docker logs blynk_server\n</code></pre>"},{"location":"Containers/Blynk_server/#editConfiguration","title":"Changing Blynk Server's configuration","text":"<p>The first time you launch the <code>blynk_server</code> container, the following structure will be created in the persistent storage area:</p> <pre><code>~/IOTstack/volumes/blynk_server\n\u251c\u2500\u2500 [drwxr-xr-x pi      ]  config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 [-rw-r--r-- pi      ]  mail.properties\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 [-rw-r--r-- pi      ]  server.properties\n\u2514\u2500\u2500 [drwxr-xr-x root    ]  data\n</code></pre> <p>The two <code>.properties</code> files can be used to alter Blynk Server's configuration. When you make change to these files, you activate then by restarting the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart blynk_server\n</code></pre>"},{"location":"Containers/Blynk_server/#cleanSlate","title":"Getting a clean slate","text":"<p>Erasing Blynk Server's persistent storage area triggers self-healing and restores known defaults:</p> <p><pre><code>$ cd ~/IOTstack\n$ docker-compose down blynk_server\n$ sudo rm -rf ./volumes/blynk_server\n$ docker-compose up -d blynk_server\n</code></pre> Notes:</p> <ul> <li> <p>You can also remove individual configuration files and then trigger self-healing. For example, if you decide to edit <code>server.properties</code> and make a mess, you can restore the original default version like this:</p> <pre><code>$ cd ~/IOTstack\n$ rm volumes/blynk_server/config/server.properties\n$ docker-compose restart blynk_server\n</code></pre> </li> <li> <p>See also if downing a container doesn't work</p> </li> </ul>"},{"location":"Containers/Blynk_server/#upgradingBlynkServer","title":"Upgrading Blynk Server","text":"<p>To find out when a new version has been released, you need to visit the Blynk-Server releases page at GitHub.</p> <p>At the time of writing, version 0.41.16 was the most up-to-date. Suppose that version 0.41.17 has been released and that you decide to upgrade:</p> <ol> <li> <p>Edit your Compose file to change the version nuumber:</p> <pre><code>  blynk_server:\n    build:\n      context: ./.templates/blynk_server/.\n      args:\n        - BLYNK_SERVER_VERSION=0.41.17\n</code></pre> <p>Note:</p> <ul> <li>You can use this method to pin Blynk Server to any available version.</li> </ul> </li> <li> <p>You then have two options:</p> <ul> <li> <p>If you only want to reconstruct the local image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up --build -d blynk_server\n$ docker system prune -f\n</code></pre> </li> <li> <p>If you want to update the Ubuntu base image at the same time:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull blynk_server\n$ docker-compose up -d blynk_server\n$ docker system prune -f\n$ docker system prune -f\n</code></pre> <p>The second <code>prune</code> will only be needed if there is an old base image and that, in turn, depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p> </li> </ul> </li> </ol>"},{"location":"Containers/Blynk_server/#usingBlynkServer","title":"Using Blynk Server","text":"<p>See the References for documentation links.</p>"},{"location":"Containers/Blynk_server/#blynkAdmin","title":"Connecting to the administrative UI","text":"<p>To connect to the administrative interface, navigate to:</p> <pre><code>https://&lt;your pis IP&gt;:9444/admin\n</code></pre> <p>You may encounter browser security warnings which you will have to acknowledge in order to be able to connect to the page. The default credentials are:</p> <ul> <li>username = <code>admin@blynk.cc</code></li> <li>password = <code>admin</code></li> </ul>"},{"location":"Containers/Blynk_server/#changePassword","title":"Change username and password","text":"<ol> <li>Click on Users &gt; \"email address\" and edit email, name and password. </li> <li>Save changes.</li> <li> <p>Restart the container using either Portainer or the command line:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart blynk_server\n</code></pre> </li> </ol>"},{"location":"Containers/Blynk_server/#gmailSetup","title":"Setup gmail","text":"<p>Optional step, useful for getting the auth token emailed to you. (To be added once confirmed working....)</p>"},{"location":"Containers/Blynk_server/#mobileSetup","title":"iOS/Android app setup","text":"<ol> <li>When setting up the application on your mobile be sure to select \"custom\" setup see.</li> <li>Press \"New Project\"</li> <li>Give it a name, choose device \"Raspberry Pi 3 B\" so you have plenty of virtual pins available, and lastly select WiFi.</li> <li>Create project and the auth token will be emailed to you (if emails configured). You can also find the token in app under the phone app settings, or in the admin web interface by clicking Users&gt;\"email address\" and scroll down to token.</li> </ol>"},{"location":"Containers/Blynk_server/#quickAppGuide","title":"Quick usage guide for app","text":"<ol> <li>Press on the empty page, the widgets will appear from the right.</li> <li>Select your widget, let's say a button.</li> <li>It appears on the page, press on it to configure.</li> <li>Give it a name and colour if you want. </li> <li>Press on PIN, and select virtual. Choose any pin i.e. V0</li> <li>Press ok.</li> <li>To start the project running, press top right Play button.</li> <li>You will get an offline message, because no devices are connected to your project via the token.</li> </ol> <p>Enter Node-Red.....</p>"},{"location":"Containers/Blynk_server/#enterNodeRed","title":"Node-RED","text":"<ol> <li>Install <code>node-red-contrib-blynk-ws</code> from Manage Palette.</li> <li>Drag a \"write event\" node into your flow, and connect to a debug node</li> <li> <p>Configure the Blynk node for the first time:</p> <pre><code>URL: wss://youripaddress:9444/websockets\n</code></pre> <p>There is more information here. 4. Enter your auth token from before and save/exit. 5. When you deploy the flow, notice the app shows connected message, as does the Blynk node. 6. Press the button on the app, you will notice the payload is sent to the debug node.</p> </li> </ol>"},{"location":"Containers/Chronograf/","title":"Chronograf","text":""},{"location":"Containers/Chronograf/#references","title":"References","text":"<ul> <li>influxdata Chronograf documentation</li> <li>GitHub: influxdata/influxdata-docker/chronograf</li> <li>DockerHub: influxdata Chronograf</li> </ul>"},{"location":"Containers/Chronograf/#kapacitor-integration","title":"Kapacitor integration","text":"<p>If you selected Kapacitor in the menu and want Chronograf to be able to interact with it, you need to edit <code>docker-compose.yml</code> to un-comment the lines which are commented-out in the following:</p> <pre><code>chronograf:\n  \u2026\n  environment:\n  \u2026\n  # - KAPACITOR_URL=http://kapacitor:9092\n  depends_on:\n  \u2026\n  # - kapacitor\n</code></pre> <p>If the Chronograf container is already running when you make this change, run:</p> <pre><code>$ cd ~IOTstack\n$ docker-compose up -d chronograf\n</code></pre>"},{"location":"Containers/Chronograf/#upgrading-chronograf","title":"Upgrading Chronograf","text":"<p>You can update the container via:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune\n</code></pre> <p>In words:</p> <ul> <li><code>docker-compose pull</code> downloads any newer images;</li> <li><code>docker-compose up -d</code> causes any newly-downloaded images to be instantiated as containers (replacing the old containers); and</li> <li>the <code>prune</code> gets rid of the outdated images.</li> </ul>"},{"location":"Containers/Chronograf/#chronograf-version-pinning","title":"Chronograf version pinning","text":"<p>If you need to pin to a particular version:</p> <ol> <li>Use your favourite text editor to open <code>docker-compose.yml</code>.</li> <li> <p>Find the line:</p> <pre><code>image: chronograf:latest\n</code></pre> </li> <li> <p>Replace <code>latest</code> with the version you wish to pin to. For example, to pin to version 1.9.0:</p> <pre><code>image: chronograf:1.9.0\n</code></pre> </li> <li> <p>Save the file and tell <code>docker-compose</code> to bring up the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d chronograf\n$ docker system prune\n</code></pre> </li> </ol>"},{"location":"Containers/DashMachine/","title":"DashMachine","text":""},{"location":"Containers/DashMachine/#references","title":"References","text":"<ul> <li>Homepage</li> <li>Docker</li> </ul>"},{"location":"Containers/DashMachine/#web-interface","title":"Web Interface","text":"<p>The web UI can be found on <code>\"your_ip\":5000</code>.</p> <p>The default credentials are: * User: <code>admin</code> * Password: <code>admin</code></p>"},{"location":"Containers/DashMachine/#about-dashmachine","title":"About DashMachine","text":"<p>DashMachine is a web application bookmark dashboard. It allows you to have all your application bookmarks available in one place, grouped and organized how you want to see them.</p> <p>Within the context of IOTstack, DashMachine can help you organize your deployed services.</p>"},{"location":"Containers/Deconz/","title":"deCONZ","text":""},{"location":"Containers/Deconz/#references","title":"References","text":"<ul> <li>Docker</li> <li>Website</li> </ul>"},{"location":"Containers/Deconz/#setup","title":"Setup","text":""},{"location":"Containers/Deconz/#old-menu-old-menu-branch","title":"Old menu (old menu branch)","text":"<p>If you use \"old menu\", you may get an error message similar to the following on first launch:</p> <pre><code>parsing ~/IOTstack/docker-compose.yml: error while interpolating services.deconz.devices.[]: required variable DECONZ_DEVICE_PATH is missing a value: eg echo DECONZ_DEVICE_PATH=/dev/serial0 &gt;&gt;~/IOTstack/.env\n</code></pre> <p>The message is telling you that you need to define the path to your deCONZ device. Common examples are:</p> <ul> <li>Raspbee at <code>/dev/serial0</code></li> <li>Conbee at <code>/dev/ttyUSB0</code></li> <li>Conbee II at <code>/dev/ttyACM0</code></li> </ul> <p>Once you have identified the appropriate device path, you can define it like this:</p> <pre><code>$ echo DECONZ_DEVICE_PATH=/dev/serial0 &gt;&gt;~/IOTstack/.env\n</code></pre> <p>This example uses <code>/dev/serial0</code>. Substitute your actual device path if it is different. </p>"},{"location":"Containers/Deconz/#new-menu-master-branch","title":"New menu (master branch)","text":"<p>New menu offers a sub-menu (place the cursor on <code>deconz</code> and press the right arrow) where you can select the appropriate device path.</p>"},{"location":"Containers/Deconz/#dialout-group","title":"Dialout group","text":"<p>Before running <code>docker-compose up -d</code>, make sure your Linux user is part of the dialout group, which allows the user access to serial devices (i.e. Conbee/Conbee II/RaspBee). If you are not certain, simply add your user to the dialout group by running the following command (username \"pi\" being used as an example):</p> <pre><code>$ sudo usermod -a -G dialout pi\n</code></pre>"},{"location":"Containers/Deconz/#troubleshooting","title":"Troubleshooting","text":"<p>Your Conbee/Conbee II/RaspBee gateway must be plugged in when the deCONZ Docker container is being brought up. If your gateway is not detected, or no lights can be paired, try moving the device to another usb port. A reboot may help too.</p> <p>Use a 0.5-1m usb extension cable with ConBee (II) to avoid wifi and bluetooth noise/interference from your Raspberry Pi (recommended by the manufacturer and often the solution to poor performance).</p>"},{"location":"Containers/Deconz/#accessing-the-phoscon-ui","title":"Accessing the Phoscon UI","text":"<p>The Phoscon UI is available using port 8090 (http://your.local.ip.address:8090/)</p>"},{"location":"Containers/Deconz/#viewing-the-deconz-zigbee-mesh","title":"Viewing the deCONZ Zigbee mesh","text":"<p>The Zigbee mesh can be viewed using VNC on port 5901. The default VNC password is \"changeme\".</p>"},{"location":"Containers/Deconz/#connecting-deconz-and-node-red","title":"Connecting deCONZ and Node-RED","text":"<p>Install node-red-contrib-deconz via the \"Manage palette\" menu in Node-RED (if not already installed) and follow these 2 simple steps (also shown in the video below):</p> <p>Step 1: In the Phoscon UI, Go to Settings &gt; Gateway &gt; Advanced and click \"Authenticate app\".</p> <p>Step 2: In Node-RED, open a deCONZ node, select \"Add new deonz-server\", insert your ip adress and port 8090 and click \"Get settings\".  Click \"Add\", \"Done\" and \"Deploy\". Your device list will not be updated before deploying.</p> <p></p>"},{"location":"Containers/DiyHue/","title":"DIY hue","text":"<ul> <li>website</li> </ul>"},{"location":"Containers/DiyHue/#about","title":"About","text":"<p>diyHue is a utility to contol the lights in your home</p>"},{"location":"Containers/DiyHue/#setup","title":"Setup","text":"<p>Before you start diyHue you will need to get your IP and MAC addresses. Run <code>ip addr</code> in the terminal</p> <p></p> <p>Enter these values into the <code>./services/diyhue/diyhue.env</code> file</p> <p>The default username and password it <code>Hue</code> and <code>Hue</code> respectively </p>"},{"location":"Containers/DiyHue/#usage","title":"Usage","text":"<p>The web interface is available on port 8070</p>"},{"location":"Containers/Domoticz/","title":"Domoticz","text":""},{"location":"Containers/Domoticz/#references","title":"References","text":"<ul> <li> <p>Domoticz home</p> <ul> <li>User Guide (pdf)</li> </ul> </li> <li> <p>GitHub: domoticz/domoticz</p> </li> <li>DockerHub: domoticz/domoticz</li> </ul>"},{"location":"Containers/Domoticz/#invitation","title":"Invitation","text":"<p>There is no IOTstack documentation for Domoticz.</p> <p>This is a standing invitation to anyone who is familiar with this container to submit a Pull Request to provide some documentation.</p>"},{"location":"Containers/Domoticz/#environment-variables","title":"Environment Variables","text":"<ul> <li> <p><code>TZ=${TZ:-Etc/UTC}</code></p> <p>If <code>TZ</code> is defined in <code>~/IOTstack/.env</code> then the value there is applied, otherwise the default of <code>Etc/UTC</code> is used. You can initialise <code>.env</code> like this:</p> <pre><code>$ cd ~/IOTstack\n$ [ $(grep -c \"^TZ=\" .env) -eq 0 ] &amp;&amp; echo \"TZ=$(cat /etc/timezone)\" &gt;&gt;.env\n</code></pre> </li> <li> <p><code>LOG_PATH=/opt/domoticz/userdata/domoticz.log</code></p> <p>This is disabled by default. If you enable it, Domoticz will write a log to that internal path. The path corresponds with the external path:</p> <pre><code>~/IOTstack/volumes/domoticz/domoticz.log\n</code></pre> <p>Note that this log is persistent. In other words, it will survive container restarts. This means you are responsible for pruning it from time to time. The Unix tradition for pruning logs is:</p> <pre><code>$ cd ~/IOTstack/volumes/domoticz/\n$ cat /dev/null | sudo tee domoticz.log\n</code></pre> <p>If, instead, you decide to delete the log file, you should stop the container first:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down domoticz\n$ sudo rm ./volumes/domoticz/domoticz.log\n$ docker-compose up -d domoticz\n</code></pre> </li> <li> <p><code>EXTRA_CMD_ARG=</code></p> <p>This is disabled by default. It can be enabled and used to override the default parameters and pass command-line parameters of your choosing to Domoticz.</p> </li> </ul>"},{"location":"Containers/Domoticz/#devices","title":"Devices","text":"<p>The service definition includes an <code>x-devices:</code> clause. The <code>x-</code> prefix has the same effect as commenting-out the entire clause. If you wish to map an external device into the container:</p> <ol> <li>Adjust the left-hand-side of the example path to point to the device as it appears on your Raspberry Pi;</li> <li>Remove the <code>x-</code> prefix.</li> <li> <p>Recreate the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d domoticz\n</code></pre> </li> </ol>"},{"location":"Containers/Domoticz/#migration-notes","title":"Migration Notes","text":"<ol> <li>Older IOTstack service definitions for Domoticz used the <code>lscr.io/linuxserver/domoticz:latest</code> image. The current service definition uses the <code>domoticz/domoticz:stable</code> image.</li> <li> <p>The location of the persistent store has changed, as has its relationship to the internal path:</p> service definition persistent store internal path older ~/IOTstack/volumes/domoticz/data config current ~/IOTstack/volumes/domoticz /opt/domoticz/userdata <p>If you have have been using the older service definition and wish to upgrade to the current service definition, you  can try migrating like this:</p> <pre><code>$ cd ~/IOTstack/volumes\n$ sudo mv domoticz domoticz.old\n$ sudo cp -a domoticz.old/data domoticz\n</code></pre> </li> </ol>"},{"location":"Containers/Dozzle/","title":"Dozzle","text":""},{"location":"Containers/Dozzle/#reference","title":"Reference","text":"<ul> <li>Dozzle GitHub</li> </ul>"},{"location":"Containers/Dozzle/#webinterface","title":"Webinterface","text":"<p>Webninterface is available at <code>\"your_ip\":8889</code></p>"},{"location":"Containers/Dozzle/#about-dozzle","title":"About Dozzle","text":"<p>Dozzle is a small lightweight application with a web based interface to monitor Docker logs.  It doesn\u2019t store any log files. It is for live monitoring of your container logs only.</p>"},{"location":"Containers/Duckdns/","title":"Duck DNS","text":"<p>Duckdns is a free public DNS service that provides you with a domain name you can update to match your dynamic IP-address.</p> <p>This container automates the process to keep the duckdns.org domain updated when your IP-address changes.</p>"},{"location":"Containers/Duckdns/#configuration","title":"Configuration","text":"<p>First, register an account, add your subdomain and get your token from http://www.duckdns.org/</p> <p>Either edit <code>~/IOTstack/docker-compose.yml</code> or create a file <code>~/IOTstack/docker-compose.override.yml</code>. Place your Duckdns token and subdomain name (without .duckdns.org) there:</p> docker-compose.override.yml<pre><code>version: '3.6'\nservices:\n  duckdns:\n    environment:\n      TOKEN: your-duckdns-token\n      SUBDOMAINS: subdomain\n</code></pre> <p>Observe that at least the initial update is successful:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d duckdns\n$ docker-compose logs -f duckdns\n...SNIP...\nduckdns    | Sat May 21 11:01:00 UTC 2022: Your IP was updated\n...SNIP...\n(ctrl-c to stop following the log)\n</code></pre> <p>If there is a problem, check that the resulting effective configuration of 'duckdns:' looks OK: <pre><code>$ cd ~/IOTstack &amp;&amp; docker-compose config\n</code></pre></p>"},{"location":"Containers/Duckdns/#domain-name-for-the-private-ip","title":"Domain name for the private IP","text":"<p>Example public/private IP:s and domains</p> <pre><code>flowchart\nI([Internet])\nG(\"Router\\npublic IP: 52.85.51.71\\nsubdomain.duckdns.org\")\nR(Raspberry pi\\nprivate IP: 192.168.0.100\\nprivate_subdomain.duckdns.org)\nI --- |ISP| G --- |LAN| R</code></pre> <p>As a public DNS server, Duckdns is not meant to be used for private IPs. It's recommended that for resolving internal LAN IPs you use the Pi Hole container or run a dedicated DNS server.</p> <p>That said, it's possible to update a Duckdns subdomain to your private LAN IP. This may be convenient if you have devices that don't support mDNS (.local) or don't want to run Pi-hole. This is especially useful if you can't assign a static IP to your RPi. No changes to your DNS resolver settings are needed.</p> <p>First, as for the public subdomain, add the domain name to your Duckdns account by logging in from their homepage. Then add a <code>PRIVATE_SUBDOMAINS</code> variable indicating this subdomain:</p> <pre><code>version: '3.6'\nservices:\n  duckdns:\n    environment:\n      TOKEN: ...\n      SUBDOMAINS: ...\n      PRIVATE_SUBDOMAINS: private_subdomain\n</code></pre>"},{"location":"Containers/Duckdns/#references","title":"References","text":"<ul> <li>uses ukkopahis' fork based on   the linuxserver   docker-duckdns container</li> </ul>"},{"location":"Containers/ESPHome/","title":"ESPHome","text":"<p>ESPHome is a system to control your microcontrollers by simple yet powerful configuration files and control them remotely through Home Automation systems.</p>"},{"location":"Containers/ESPHome/#resources","title":"Resources","text":"<ul> <li>ESPHome documentation</li> <li>DockerHub</li> <li>GitHub</li> </ul>"},{"location":"Containers/ESPHome/#serviceDefinition","title":"IOTstack service definition","text":"<pre><code>esphome:\n  container_name: esphome\n  image: esphome/esphome\n  restart: unless-stopped\n  environment:\n    - TZ=${TZ:-Etc/UTC}\n    - USERNAME=${ESPHOME_USERNAME:-esphome}\n    - PASSWORD=${ESPHOME_PASSWORD:?eg echo ESPHOME_PASSWORD=ChangeMe &gt;&gt;~/IOTstack/.env}\n  network_mode: host\n  x-ports:\n    - \"6052:6052\"\n  volumes:\n    - ./volumes/esphome/config:/config\n  device_cgroup_rules:\n    - 'c 188:* rw'\n</code></pre> <p>Notes:</p> <ol> <li>The container runs in \"host\" mode, meaning it binds to the host port 6052.</li> <li>The <code>x-</code> prefix on the <code>x-ports</code> clause has the same effect as commenting-out lines 10 and 11. It serves the twin purposes of documenting the fact that the ESPHome container uses port 6052 and minimising the risk of port number collisions.</li> </ol>"},{"location":"Containers/ESPHome/#container-installation","title":"Container installation","text":""},{"location":"Containers/ESPHome/#via-the-iotstack-menu","title":"via the IOTstack menu","text":"<p>If you select ESPHome in the IOTstack menu, as well as adding the service definition to your compose file, the menu:</p> <ol> <li>Copies a rules file into <code>/etc/udev/rules.d</code>.</li> <li>Checks <code>~/IOTstack/.env</code> for the presence of the <code>ESPHOME_USERNAME</code> and initialises it to the value <code>esphome</code> if it is not found.</li> <li>Checks <code>~/IOTstack/.env</code> for the presence of the <code>ESPHOME_PASSWORD</code> and initialises it to a random value if it is not found.</li> </ol>"},{"location":"Containers/ESPHome/#manualInstall","title":"manual installation","text":"<p>If you prefer to avoid the menu, you can install ESPHome like this:</p> <ol> <li> <p>Be in the correct directory:</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>If you are on the \"master\" branch, add the service definition like this:</p> <pre><code>$ sed -e \"s/^/  /\" ./.templates/esphome/service.yml &gt;&gt;docker-compose.yml\n</code></pre> <p>Alternatively, if you are on the \"old-menu\" branch, do this:</p> <pre><code>$ cat ./.templates/esphome/service.yml &gt;&gt;docker-compose.yml\n</code></pre> </li> <li> <p>Replace <code>\u00abusername\u00bb</code> and <code>\u00abpassword\u00bb</code> in the following commands with values of your choice and then run the commands:</p> <pre><code>$ echo \"ESPHOME_USERNAME=\u00abusername\u00bb\u201d &gt;&gt;.env\n$ echo \"ESPHOME_PASSWORD=\u00abpassword\u00bb\" &gt;&gt;.env\n</code></pre> <p>This initialises the required environment variables. Although the username defaults to <code>esphome</code>, there is no default for the password. If you forget to set a password, <code>docker-compose</code> will remind you when you try to start the container:</p> <pre><code>error while interpolating services.esphome.environment.[]: \\\n  required variable ESPHOME_PASSWORD is missing a value: \\\n  eg echo ESPHOME_PASSWORD=ChangeMe &gt;&gt;~/IOTstack/.env\n</code></pre> <p>The values of the username and password variables are applied each time you start the container. In other words, if you decide to change these credentials, all you need to do is edit the <code>.env</code> file and \u201cup\u201d the container.</p> </li> <li> <p>Copy the UDEV rules file into place and ensure it has the correct permissions:</p> <pre><code>$ sudo cp ./.templates/esphome/88-tty-iotstack-esphome.rules /etc/udev/rules.d/\n$ sudo chmod 644 /etc/udev/rules.d/88-tty-iotstack-esphome.rules\n</code></pre> </li> </ol>"},{"location":"Containers/ESPHome/#a-quick-tour","title":"A quick tour","text":"<p>ESPHome provides a number of methods for provisioning an ESP device. These instructions focus on the situation where the device is connected to your Raspberry\u00a0Pi via a USB cable.</p>"},{"location":"Containers/ESPHome/#start-the-container","title":"start the container","text":"<p>To start the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d esphome\n</code></pre> <p>Tip:</p> <ul> <li> <p>You can always retrieve your ESPHome login credentials from the <code>.env</code> file. For example:</p> <pre><code>$ grep \u201c^ESPHOME_\u201d .env\nESPHOME_USERNAME=esphome\nESPHOME_PASSWORD=8AxXG5ZVsO4UGTMt\n</code></pre> </li> </ul>"},{"location":"Containers/ESPHome/#connect-your-esp-device","title":"connect your ESP device","text":"<p>Connect your ESP device to one of your Raspberry\u00a0Pi\u2019s USB ports. You need to connect the device while the ESPHome container is running so that the UDEV rules file can propagate the device (typically <code>/dev/ttyUSBn</code>) into the container.</p> <p>So long as the container is running, you can freely connect and disconnect ESP devices to your Raspberry\u00a0Pi\u2019s USB ports, and the container will keep \u201cin sync\u201d.</p>"},{"location":"Containers/ESPHome/#in-your-browser","title":"in your browser","text":"<p>Launch your browser. For maximum flexibility, ESPHome recommends browsers that support WebSerial, like Google Chrome or Microsoft Edge.</p> <ol> <li> <p>Connect to your Raspberry\u00a0Pi on port 6052 (reference point \ud83c\udd30 in the following screen shot):</p> <p></p> <p>You can use your Raspberry\u00a0Pi\u2019s:</p> <ul> <li>multicast domain name (eg <code>raspberrypi.local</code>);</li> <li>IP address (eg 192.168.1.100); or</li> <li>domain name (if you run your own Domain Name System server).</li> </ul> </li> <li> <p>Enter your ESPHome credentials at \ud83c\udd31 and click Login.</p> </li> <li> <p>Click either of the + New Device buttons \ud83c\udd32:</p> <p></p> <p>Read the dialog and then click Continue \ud83c\udd33:</p> <p></p> </li> <li> <p>Give the configuration a name at \ud83c\udd34:</p> <p></p> <p>In the fields at \ud83c\udd35, enter the Network Name (SSID) and password (PSK) of the WiFi network that you want your ESP devices to connect to when they power up.</p> <p>The WiFi fields are only displayed the very first time you set up a device. Thereafter, ESPHome assumes all your devices will use the same WiFi network.</p> <p>Click \u201cNext\u201d \ud83c\udd36.</p> </li> <li> <p>Select the appropriate SoC (System on a Chip) type for your device. Here, I am using a generic ESP32 at \ud83c\udd37:</p> <p></p> <p>Clicking on the appropriate line proceeds to the next step.</p> </li> <li> <p>You can either make a note of the encryption key or, as is explained in the dialog, defer that until you actually need it for Home Assistant. Click \u201cInstall\u201d \ud83c\udd38.</p> <p></p> </li> <li> <p>The primary reason for running ESPHome as a container in IOTstack is so you can program ESP devices attached to your Raspberry\u00a0Pi. You need to tell ESPHome what you are doing by selecting \u201cPlug into the computer running ESPHome Dashboard\u201d \ud83c\udd39:</p> <p></p> </li> <li> <p>If all has gone well, your device will appear in the list. Select it \ud83c\udd3a:</p> <p></p> <p>If, instead, you see the window below, it likely means you did not connect your ESP device while the ESPHome container was running:</p> <p></p> <p>Try disconnecting and reconnecting your ESP device, and waiting for the panel \ud83c\udd3a to refresh. If that does not cure the problem then it likely means the UDEV rules are not matching on your particular device for some reason. You may need to consider privileged mode.</p> </li> <li> <p>The container will begin the process of compiling the firmware and uploading it to your device. The first time you do this takes significantly longer than second-or-subsequent builds, mainly because the container downloads almost 2GB of data.</p> <p></p> <p>The time to compile depends on the speed of your Raspberry\u00a0Pi hardware (ie a Raspberry\u00a0Pi 5 will be significantly faster than a model 4, than a model 3). Be patient!</p> <p>When the progress log \ud83c\udd3b implies the process has been completed, you can click Stop \ud83c\udd3c to dismiss the window.</p> </li> <li> <p>Assuming normal completion, your ESP device should show as \u201cOnline\u201d \ud83c\udd3d. You can edit or explore the configuration using the \u201cEdit\u201d and \u201c\u22ee\u201d buttons.</p> <p></p> </li> </ol>"},{"location":"Containers/ESPHome/#getting-a-clean-slate","title":"Getting a clean slate","text":"<p>If ESPHome misbehaves or your early experiments leave a lot of clutter behind, and you decide it would be best to start over with a clean installation, run the commands below:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down esphome\n$ sudo rm -rf ./volumes/esphome\n$ docker-compose up -d esphome\n</code></pre> <p>Notes:</p> <ol> <li>Always be careful with <code>sudo rm</code>. Double-check the command before you press enter.</li> <li> <p>The <code>sudo rm</code> may seem to take longer than you expect. Do not be concerned. ESPHome downloads a lot of data which it stores at the hidden path:</p> <pre><code>/IOTstack/volumes/esphome/config/.esphome\n</code></pre> <p>A base install has more than 13,000 files and over 3,000 directories. Even on a solid state disk, deleting that meny directory entries takes time!</p> </li> </ol>"},{"location":"Containers/ESPHome/#device-mapping","title":"Device mapping","text":""},{"location":"Containers/ESPHome/#udevRules","title":"UDEV rules file","text":"<p>The service definition contains the following lines:</p> <pre><code>  device_cgroup_rules:\n    - 'c 188:* rw'\n</code></pre> <p>Those lines assume the presence of a rules file at:</p> <pre><code>/etc/udev/rules.d/88-tty-iotstack-esphome.rules\n</code></pre> <p>That file is copied into place automatically if you use the IOTstack menu to select ESPHome. It should also have been copied if you installed ESPHome manually.</p> <p>What the rules file does is to wait for you to connect any USB device which maps to a major device number of 188. That includes most (hopefully all) USB-to-serial adapters that are found on ESP dev boards, or equivalent standalone adapters such as those made by Future Technology Devices International (FTDI) and Silicon Laboratories Incorporated where you typically connect jumper wires to the GPIO pins which implement the ESP's primary serial interface.</p> <p>Whenever you connect such a device to your Raspberry\u00a0Pi, the rules file instructs the ESPHome container to add a matching node. Similarly, when you remove such a device, the rules file instructs the ESPHome container to delete the matching node. The container gains the ability to access the USB device (the ESP) via the <code>device_cgroup_rules</code> clause.</p> <p>You can check whether a USB device is known to the container by running:</p> <pre><code>$ docker exec esphome ls /dev\n</code></pre> <p>The mechanism is not 100% robust. In particular, it will lose synchronisation if the system is rebooted, or the container is started when a USB device is already mounted. Worst case should be the need to unplug then re-plug the device, after which the container should catch up.</p>"},{"location":"Containers/ESPHome/#udevRulesRemoval","title":"Removing the rules file","text":"<p>The UDEV rules \"fire\" irrespective of whether or not the ESPHome container is actually running. All that happens if the container is not running is an error message in the system log. However, if you decide to remove the ESPHome container, you should remove the rules file by hand:</p> <pre><code>$ sudo rm /etc/udev/rules.d/88-tty-iotstack-esphome.rules\n</code></pre>"},{"location":"Containers/ESPHome/#privileged","title":"Privileged mode","text":"<p>The UDEV rules approach uses the principle of least privilege but it relies upon an assumption about how ESP devices represent themselves when connected to a Raspberry\u00a0Pi.</p> <p>If you encounter difficulties, you can consider trying this instead:</p> <ol> <li>Follow the instructions to remove the UDEV rules file.</li> <li> <p>Edit the service definition so that it looks like this:</p> <pre><code>  x-device_cgroup_rules:\n    - 'c 188:* rw'\n  privileged: true\n</code></pre> <p>The <code>x-</code> prefix has the effect of commenting-out lines 14 and 15, making it easy to restore them later.</p> </li> <li> <p>Start the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d esphome\n</code></pre> </li> </ol> <p>The <code>privileged</code> flag gives the container unrestricted access to all of <code>/dev</code>. The container runs as root so this is the same as granting any process running inside the ESPHome container full and unrestricted access to all corners of your hardware platform, including your mass storage devices (SD, HD, SSD). You should use privileged mode sparingly and in full knowledge that it is entirely at your own risk! </p>"},{"location":"Containers/ESPHome/#routine-maintenance","title":"Routine maintenance","text":"<p>You can keep ESPHome up-to-date with routine \u201cpull\u201d commands:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune -f\n</code></pre> <p>If a <code>pull</code> downloads a more-recent image for ESPHome, the subsequent <code>up</code> will (logically) disconnect any connected ESP device from the container.</p> <p>The same will happen if you \u201cdown\u201d and \u201cup\u201d the ESPHome container, or reboot the Raspberry\u00a0Pi, while an ESP device is physically connected to the Raspberry\u00a0Pi.</p> <p>In every case, the device will still be known to the Raspberry\u00a0Pi, just not the ESPHome container. In a logical sense, the container is \u201cout of sync\u201d with the host system.</p> <p>If this happens, disconnect and reconnect the device. The UDEV rule will \u201cfire\u201d and propagate the device back into the running container.</p>"},{"location":"Containers/EspruinoHub/","title":"Espruinohub","text":"<p>This is a testing container</p> <p>I tried it however the container keeps restarting <code>docker logs espruinohub</code> I get \"BLE Broken?\" but could just be i dont have any BLE devices nearby</p> <p>web interface is on \"{your_Pis_IP}:1888\"</p> <p>see EspruinoHub#status--websocket-mqtt--espruino-web-ide for other details.</p> <p>there were no recommendations for persistent data volumes. so <code>docker-compose down</code> may destroy all you configurations so use <code>docker-compose stop</code> in stead </p> <p>Please check existing issues if you encounter a problem, and then open a new issue if your problem has not been reported.</p>"},{"location":"Containers/Grafana/","title":"Grafana","text":""},{"location":"Containers/Grafana/#references","title":"References","text":"<ul> <li>Docker</li> <li>Website</li> </ul>"},{"location":"Containers/Grafana/#adding-influxdb-datasource","title":"Adding InfluxDB datasource","text":"<p>When you have logged into Grafana (default user/pass: admin/admin), you have to add a data source to be used for the graphs.</p> <p>Select <code>Data Sources</code> -&gt; <code>Add data source</code> -&gt; <code>InfluxDB</code>.</p> <p>Set options:</p> <ul> <li>HTTP / URL: <code>http://influxdb:8086</code></li> <li>InfluxDB Details / Database: <code>telegraf</code></li> <li>InfluxDB Details / User: <code>nodered</code></li> <li>InfluxDB Details / Password: <code>nodered</code></li> </ul>"},{"location":"Containers/Grafana/#overriding-configuration-variables","title":"Overriding configuration variables","text":"<p>Grafana documentation contains a list of settings. Settings are described in terms of how they appear in \".ini\" files.</p> <p>Grafana configuration is usually done in grafana.ini, but when used via docker as the IOTstack does, it should be configured using environment variables.</p> <p>Edit <code>docker-compose.yml</code> and find <code>grafana:</code> and under it <code>environment:</code> this is where you can place the ini-options, but formatted as: <pre><code>    - GF_&lt;SectionName&gt;_&lt;KeyName&gt;=&lt;value&gt;\n</code></pre> If you are using old-menu edit <code>~/IOTstack/services/grafana/grafana.env</code> instead and add the lines directly there, but without the leading dash: <code>GF_&lt;SectionName&gt;_&lt;KeyName&gt;=&lt;value&gt;</code></p> <p>For any changes to take effect you need recreate the Grafana container:</p> <pre><code>$ docker-compose up -d grafana\n</code></pre>"},{"location":"Containers/Grafana/#setting-your-time-zone","title":"Setting your time-zone","text":"<p>Change the right hand side to your own timezone:</p> <pre><code>    - TZ=Etc/UTC\n</code></pre>"},{"location":"Containers/Grafana/#anonymous-login","title":"Anonymous login","text":"<p>To allow anonymous logins add:</p> <pre><code>    - GF_AUTH_ANONYMOUS_ENABLED=true\n</code></pre>"},{"location":"Containers/Grafana/#custom-admin-user-and-password-not-recommended","title":"Custom admin user and password (not recommended)","text":"<p>If you do not change anything then, when you bring up the stack and use a browser to connect to your Raspberry Pi on port 3000, Grafana will:</p> <ul> <li>Expect you to login as user \"admin\" with password \"admin\"; and then</li> <li>Force you to change the default password to something else.</li> </ul> <p>Thereafter, you will login as \"admin\" with whatever password you chose. You can change the administrator's password as often as you like via the web UI (profile button, change password tab).</p> <p>This default operation can be changed by configuration options.  They will have any effect only if Grafana has just been added to the stack, but has never been launched. Thus, if the folder ~/IOTstack/volumes/grafana exists, Grafana has already been started, and adding and changing these options will not have any effect.</p> <p>To customize, editing the file as describe above, add the following lines under the <code>environment:</code> clause. For example, to set the administrative username to be \"maestro\" with password \"123456\":</p> <pre><code>    - GF_SECURITY_ADMIN_USER=maestro\n    - GF_SECURITY_ADMIN_PASSWORD=123456\n</code></pre> <p>If you change the default password, Grafana will not force you to change the password on first login but you will still be able to change it via the web UI.</p> <p>As a summary, the environment variables only take effect if you set them up before Grafana is launched for the first time:</p> <ul> <li><code>GF_SECURITY_ADMIN_USER</code> has a default value of \"admin\". You can explicitly set it to \"admin\" or some other value. Whatever option you choose then that's the account name of Grafana's administrative user. But choosing any value other than \"admin\" is probably a bad idea.</li> <li><code>GF_SECURITY_ADMIN_PASSWORD</code> has a default value of \"admin\". You can explicitly set it to \"admin\" or some other value. If its value is \"admin\" then you will be forced to change it the first time you login to Grafana. If its value is something other than \"admin\" then that will be the password until you change it via the web UI.</li> </ul>"},{"location":"Containers/Grafana/#options-with-spaces","title":"Options with spaces","text":"<p>To set an options with a space, you must enclose the whole value in quotes:</p> <pre><code>    - \"GF_AUTH_ANONYMOUS_ORG_NAME=Main Org.\"\n</code></pre>"},{"location":"Containers/Grafana/#help-i-forgot-my-grafana-admin-password","title":"HELP \u2013 I forgot my Grafana admin password!","text":"<p>Assuming Grafana is started, run:</p> <pre><code>$ docker exec grafana grafana cli admin reset-admin-password \u00abNEWPASSWORD\u00bb\n</code></pre> <p>where <code>\u00abNEWPASSWORD\u00bb</code> is the value of your choice.</p> <p>Note:</p> <ul> <li>If you have customized <code>GF_SECURITY_ADMIN_USER</code> to be something other than \"admin\", the password change will be applied to that username. In other words, in the <code>docker exec</code> command above, the two references to \"admin\" are referring to the administrator's account, not the username of the administrator's account. Run the command \"as is\". Do not replace \"admin\" with the username of the administrator's account.</li> </ul>"},{"location":"Containers/Grafana/#help-resetting-to-a-clean-slate","title":"HELP - Resetting to a clean slate","text":"<p>\"I made a bit of a mess with Grafana. First time user. Steep learning curve. False starts, many. Mistakes, unavoidable. Been there, done that. But now I really need to start from a clean slate. And, yes, I understand there is no undo for this.\"</p> <p>Begin by stopping Grafana:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down grafana\n</code></pre> <p>see also if downing a container doesn't work</p> <p>You have two options:</p> <ol> <li> <p>Destroy your settings and dashboards but retain any plugins you may have installed:</p> <pre><code>$ sudo rm ~/IOTstack/volumes/grafana/data/grafana.db\n</code></pre> </li> <li> <p>Nuke everything (triple-check this command before you hit return):</p> <pre><code>$ sudo rm -rf ~/IOTstack/volumes/grafana/data\n</code></pre> </li> </ol> <p>This is where you should edit docker-compose.yml or ~/IOTstack/services/grafana/grafana.env to correct any problems (such as choosing an administrative username other than \"admin\").</p> <p>When you are ready, bring Grafana back up again:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d grafana\n</code></pre> <p>Grafana will automatically recreate everything it needs. You will be able to login as \"admin/admin\" (or the credentials you set using <code>GF_SECURITY_ADMIN_USER</code> and <code>GF_SECURITY_ADMIN_PASSWORD</code>).</p>"},{"location":"Containers/Heimdall/","title":"Heimdall","text":""},{"location":"Containers/Heimdall/#references","title":"References","text":"<ul> <li>Homepage</li> <li>Docker</li> </ul>"},{"location":"Containers/Heimdall/#web-interface","title":"Web Interface","text":"<p>The web UI can be found on:</p> <ul> <li>HTTP: <code>\"your_ip\":8882</code></li> <li>HTTPS: <code>\"your_ip\":8883</code></li> </ul>"},{"location":"Containers/Heimdall/#about-heimdall","title":"About Heimdall","text":"<p>From the Heimdall website:</p> <p>Heimdall Application Dashboard is a dashboard for all your web applications. It doesn't need to be limited to applications though, you can add links to anything you like. There are no iframes here, no apps within apps, no abstraction of APIs. if you think something should work a certain way, it probably does.</p> <p>Within the context of IOTstack, the Heimdall Application Dashboard can help you organize your deployed services.</p>"},{"location":"Containers/Home-Assistant/","title":"Home Assistant","text":"<p>Home Assistant is a home automation platform. It is able to track and control all devices at your home and offer a platform for automating control.</p>"},{"location":"Containers/Home-Assistant/#references","title":"References","text":"<ul> <li> <p>Home Assistant home page</p> <ul> <li>Raspberry Pi installation</li> <li>General installation (may be useful if you are trying to run on other hardware).</li> </ul> </li> <li> <p>GitHub repository</p> </li> <li>DockerHub</li> </ul>"},{"location":"Containers/Home-Assistant/#twoVersions","title":"Home Assistant: two versions","text":"<p>There are two versions of Home Assistant:</p> <ul> <li>Home Assistant Container; and</li> <li>Supervised Home Assistant (also known as both \"Hass.io\" and \"Home Assistant Core\").</li> </ul> <p>Each version:</p> <ul> <li>provides a web-based management interface on port 8123; and</li> <li>runs in \"host mode\" in order to discover devices on your LAN, including devices communicating via multicast traffic.</li> </ul> <p>Home Assistant Container runs as a single Docker container, and doesn't support all the features that Supervised Home Assistant does (such as add-ons). Supervised Home Assistant runs as a collection of Docker containers under its own orchestration.</p> <p>The only method supported by IOTstack is Home Assistant Container.</p> <p>To understand why, see about Supervised Home Assistant.</p> <p>If Home Assistant Container will not do what you want then, basically, you will need two Raspberry Pis:</p> <ul> <li>One running Raspberry Pi OS (\"Raspbian\") hosting IOTstack; and</li> <li>Another dedicated to running Home Assistant Operating System.</li> </ul>"},{"location":"Containers/Home-Assistant/#installHAContainer","title":"Installing Home Assistant Container","text":"<p>Home Assistant (Container) can be found in the <code>Build Stack</code> menu. Selecting it in this menu results in a service definition being added to:</p> <pre><code>~/IOTstack/docker-compose.yml\n</code></pre> <p>The normal IOTstack commands apply to Home Assistant Container such as:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre>"},{"location":"Containers/Home-Assistant/#usingBluetooth","title":"Using bluetooth from the container","text":"<p>In order to be able to use BT &amp; BLE devices from HA integrations, make sure that Bluetooth is enabled:</p> <pre><code>$ hciconfig\nhci0:   Type: Primary  Bus: UART\n    BD Address: DC:89:FB:A6:32:4B  ACL MTU: 1021:8  SCO MTU: 64:1\n    UP RUNNING \n    RX bytes:2003 acl:0 sco:0 events:159 errors:0\n    TX bytes:11583 acl:0 sco:0 commands:159 errors:0\n</code></pre> <p>The \"UP\" in the third line of output indicates that Bluetooth is enabled. If Bluetooth is not enabled, check:</p> <pre><code>$ grep \"^AutoEnable\" /etc/bluetooth/main.conf\nAutoEnable=true\n</code></pre> <p>If <code>AutoEnable</code> is either missing or not set to <code>true</code>, then:</p> <ol> <li> <p>Use <code>sudo</code> to and your favouring text editor to open:</p> <pre><code>/etc/bluetooth/main.conf\n</code></pre> </li> <li> <p>Find <code>AutoEnable</code> and make it <code>true</code>.</p> <p>If <code>AutoEnable</code> is missing, it needs to be added to the <code>[Policy]</code> section.</p> </li> <li> <p>Reboot your Raspberry Pi.</p> </li> <li>Check that the Bluetooth interface is enabled.</li> </ol> <p>See also: Scribles: Auto Power On Bluetooth Adapter on Boot-up.</p>"},{"location":"Containers/Home-Assistant/#serviceDefinition","title":"Possible service definition changes","text":"<p>Although the Home Assistant documentation does not mention this, it is possible that you may also need to make the following changes to the Home Assistant service definition in your <code>docker-compose.yml</code>:</p> <ul> <li> <p>Add the following mapping to the <code>volumes:</code> clause:</p> <pre><code>- /var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket\n</code></pre> </li> <li> <p>Add the following <code>devices:</code> clause:</p> <pre><code>devices:\n  - \"/dev/serial1:/dev/ttyAMA0\"\n  - \"/dev/vcio:/dev/vcio\"\n  - \"/dev/gpiomem:/dev/gpiomem\"\n</code></pre> </li> </ul> <p>Notes:</p> <ul> <li>These changes are specific to the Raspberry Pi. If you need Bluetooth support on non-Pi hardware, you will need to figure out the details for your chosen platform.</li> <li>Historically, <code>/dev/ttyAMA0</code> meant \"the serial interface\" on Raspberry Pis. Subsequently, it came to mean \"the Bluetooth interface\" where Bluetooth support was present. Now, <code>/dev/serial1</code> is used to mean \"the Raspberry Pi's Bluetooth interface\". The example above maps that to the internal device <code>/dev/ttyAMA0</code> because that is probably what the container expects. There are no guarantees and you may need to experiment with internal device names.</li> </ul>"},{"location":"Containers/Home-Assistant/#httpsWithSSLcert","title":"HTTPS with a valid SSL certificate","text":"<p>Some HA integrations (e.g google assistant) require your HA API to be accessible via https with a valid certificate. You can configure HA to do this: docs / guide or use a reverse proxy container, as described below.</p> <p>The linuxserver Secure Web Access Gateway container (swag) (Docker hub docs) will automatically generate a SSL-certificate, update the SSL certificate before it expires and act as a reverse proxy.</p> <ol> <li>First test your HA is working correctly: <code>http://raspberrypi.local:8123/</code> (assuming your RPi hostname is raspberrypi)</li> <li>Make sure you have duckdns working.</li> <li>On your internet router, forward public port 443 to the RPi port 443</li> <li> <p>Add swag to ~/IOTstack/docker-compose.yml beneath the <code>services:</code>-line:</p> <pre><code>  swag:\n    image: ghcr.io/linuxserver/swag\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=${TZ:-Etc/UTC}\n      - URL=&lt;yourdomain&gt;.duckdns.org\n      - SUBDOMAINS=wildcard\n      - VALIDATION=duckdns\n      - DUCKDNSTOKEN=&lt;token&gt;\n      - CERTPROVIDER=zerossl\n      - EMAIL=&lt;e-mail&gt; # required when using zerossl\n    volumes:\n      - ./volumes/swag/config:/config\n    ports:\n      - 443:443\n    restart: unless-stopped\n</code></pre> <p>Replace the bracketed values. Do NOT use any \"-characters to enclose the values.</p> </li> <li> <p>Start the swag container, this creates the file to be edited in the next step:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p>Check it starts up OK: <code>docker-compose logs -f swag</code>. It will take a minute or two before it finally logs \"Server ready\".</p> </li> <li> <p>Enable reverse proxy for <code>raspberrypi.local</code>. <code>homassistant.*</code> is already by default. and fix homeassistant container name (\"upstream_app\"):</p> <pre><code>$ cd ~/IOTstack\n$ sed -e 's/server_name/server_name *.local/' \\\n  volumes/swag/config/nginx/proxy-confs/homeassistant.subdomain.conf.sample \\\n  &gt; volumes/swag/config/nginx/proxy-confs/homeassistant.subdomain.conf\n</code></pre> </li> <li> <p>Forward to correct IP when target is a container running in \"network_mode:    host\" (like Home Assistant does):</p> <p> Note: in order for copy-paste to work properly, the usual $-prompts are omitted<pre><code>cd ~/IOTstack\ncat &lt;&lt; 'EOF' | sudo tee volumes/swag/config/custom-cont-init.d/add-host.docker.internal.sh\n#!/bin/sh\nDOCKER_GW=$(ip route | awk 'NR==1 {print $3}')\n\nsed -i -e \"s/upstream_app .*/upstream_app ${DOCKER_GW};/\" \\\n   /config/nginx/proxy-confs/homeassistant.subdomain.conf\nEOF\nsudo chmod u+x volumes/swag/config/custom-cont-init.d/add-host.docker.internal.sh\n</code></pre></p> <p>(This needs to be copy-pasted/entered as-is, ignore any \"&gt; \"-prefixes printed by bash)</p> </li> <li> <p>(optional) Add reverse proxy password protection if you don't want to rely    on the HA login for security, doesn't affect API-access:</p> <pre><code>$ cd ~/IOTstack\n$ sed -i -e 's/#auth_basic/auth_basic/' \\\n    volumes/swag/config/nginx/proxy-confs/homeassistant.subdomain.conf\n$ docker-compose exec swag htpasswd -c /config/nginx/.htpasswd anyusername\n</code></pre> </li> <li> <p>Add <code>use_x_forwarded_for</code> and <code>trusted_proxies</code> to your homeassistant http    config. The configuration    file is at <code>volumes/home_assistant/configuration.yaml</code> For a default install    the resulting http-section should be:</p> <pre><code>http:\n   use_x_forwarded_for: true\n   trusted_proxies:\n     - 192.168.0.0/16\n     - 172.16.0.0/12\n     - 10.77.0.0/16\n</code></pre> </li> <li> <p>Refresh the stack: <code>cd ~/IOTstack &amp;&amp; docker-compose stop &amp;&amp; docker-compose     up -d</code> (again may take 1-3 minutes for swag to start if it recreates     certificates)</p> </li> <li>Test homeassistant is still working correctly:     <code>http://raspberrypi.local:8123/</code> (assuming your RPi hostname is     raspberrypi)</li> <li> <p>Test the reverse proxy https is working correctly:     <code>https://raspberrypi.local/</code> (browser will issue a warning about wrong     certificate domain, as the certificate is issued for you duckdns-domain, we     are just testing)</p> <p>Or from the command line in the RPi:</p> <pre><code>$ curl --resolve homeassistant.&lt;yourdomain&gt;.duckdns.org:443:127.0.0.1 \\\n    https://homeassistant.&lt;yourdomain&gt;.duckdns.org/\n</code></pre> <p>(output should end in <code>if (!window.latestJS) { }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code>)</p> </li> <li> <p>And finally test your router forwards correctly by accessing it from     outside your LAN(e.g. using a mobile phone):     <code>https://homeassistant.&lt;yourdomain&gt;.duckdns.org/</code> Now the certificate     should work without any warnings.</p> </li> </ol>"},{"location":"Containers/Home-Assistant/#hassioBackground","title":"about Supervised Home Assistant","text":"<p>IOTstack used to offer a menu entry leading to a convenience script that could install Supervised Home Assistant. That script stopped working when Home Assistant changed their approach. The script's author made it clear that script's future was bleak so the affordance was removed from IOTstack.</p> <p>For a time, you could manually install Supervised Home Assistant using their installation instructions for advanced users. Once you got HA working, you could install IOTstack, and the two would (mostly) happily coexist.</p> <p>The direction being taken by the Home Assistant folks is to supply a ready-to-run image for your Raspberry Pi. They still support the installation instructions for advanced users but the requirements are very specific. In particular:</p> <p>Debian Linux Debian 11 aka Bullseye (no derivatives)</p> <p>Raspberry Pi OS is a Debian derivative and it is becoming increasingly clear that the \"no derivatives\" part of that requirement must be taken literally and seriously. Recent examples of significant incompatibilities include:</p> <ul> <li>introducing a dependency on <code>grub</code> (GRand Unified Bootloader). The Raspberry Pi does not use <code>grub</code> but the change is actually about forcing Control Groups version 1 when the Raspberry Pi uses version 2.</li> <li>unilaterally starting <code>systemd-resolved</code>. This is a DNS resolver which claims port 53. That means you can't run your own DNS service like PiHole, AdGuardHome or BIND9 as an IOTstack container. </li> </ul> <p>Because of the self-updating nature of Supervised Home Assistant, your Raspberry Pi might be happily running Supervised Home Assistant plus IOTstack one day, and suddenly start misbehaving the next day, simply because Supervised Home Assistant assumed it was in total control of your Raspberry Pi.</p> <p>If you want Supervised Home Assistant to work, reliably, it really needs to be its own dedicated appliance. If you want IOTstack to work, reliably, it really needs to be kept well away from Supervised Home Assistant. If you want both Supervised Home Assistant and IOTstack, you really need two Raspberry Pis.</p>"},{"location":"Containers/Homebridge/","title":"Homebridge","text":""},{"location":"Containers/Homebridge/#references","title":"References","text":"<ul> <li>GitHub home</li> <li>Configuration Guide</li> <li>DockerHub</li> </ul>"},{"location":"Containers/Homebridge/#configuration","title":"Configuration","text":"<p>Homebridge documentation has a comprehensive configuration guide which you are encouraged to read.</p> <p>Homebridge is configured using environment variables. In IOTstack:</p> <ul> <li>If you are running new menu (master branch, the default), environment variables are kept inline in <code>docker-compose.yml</code>.</li> <li> <p>If you are running old menu (old-menu branch), environment variables are at the path:</p> <pre><code>~/IOTstack/services/homebridge/homebridge.env\n</code></pre> </li> </ul> <p>In either case, you apply changes by editing the relevant file (<code>docker-compose.yml</code> or <code>homebridge.env</code>) and then:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d homebridge\n</code></pre>"},{"location":"Containers/Homebridge/#about-avahi","title":"About \"avahi\"","text":"<p>\"avahi\", \"multicast DNS\", \"Rendezvous\", \"Bonjour\" and \"ZeroConf\" are synonyms.</p> <p>Current Homebridge images disable avahi services by default. The Homebridge container runs in \"host mode\" which means it can participate in multicast traffic flows. If you have a plugin that requires avahi, it can enabled by setting the environment variable:</p> <pre><code>ENABLE_AVAHI=1\n</code></pre>"},{"location":"Containers/Homebridge/#web-interface","title":"Web Interface","text":"<p>The web UI for Homebridge can be found on <code>\"your_ip\":8581</code>. You can change the port by adjusting the environment variable:</p> <pre><code>HOMEBRIDGE_CONFIG_UI_PORT=8581\n</code></pre>"},{"location":"Containers/Homer/","title":"Homer","text":""},{"location":"Containers/Homer/#references","title":"References","text":"<ul> <li>Homepage</li> <li>Docker</li> </ul>"},{"location":"Containers/Homer/#web-interface","title":"Web Interface","text":"<p>The web UI can be found on <code>\"your_ip\":8881</code></p>"},{"location":"Containers/Homer/#about-homer","title":"About Homer","text":"<p>From the Homer README:</p> <p>A dead simple static HOMepage for your servER to keep your services on hand, from a simple <code>yaml</code> configuration file.</p> <p>You can find an example of the <code>config.yml</code> file here.</p> <p>Within the context of IOTstack, Homer can help you organize your deployed services.</p>"},{"location":"Containers/InfluxDB/","title":"InfluxDB","text":"<p>InfluxDB is a time series database. What that means is time is the primary key of each table.</p> <p>Another feature of InfluxDB is the separation of attributes into:</p> <ul> <li>fields: which are intended to hold variable data (data that is likely to be different in each row, such as a temperature reading from a sensor); and</li> <li>tags: which are intended to hold metadata (data that is unlikely to be different in each row, such as the name of the sensor).</li> </ul> <p>InfluxDB has configurable aggregation and retention policies allowing measurement resolution reduction, storing all added data points for recent data and only aggregated values for older data.</p>"},{"location":"Containers/InfluxDB/#references","title":"References","text":"<ul> <li>DockerHub</li> <li>GitHub home page (for the container)</li> <li>InfluxDB 1.8 documentation</li> <li>InfluxDB 1.8 configuration reference</li> </ul> <p>Note:</p> <ul> <li>IOTstack uses the <code>influxdb:1.8</code> image. Substituting the <code>:latest</code> tag will get you InfluxDB version 2 and will create a mess.</li> </ul>"},{"location":"Containers/InfluxDB/#configuration","title":"Configuration","text":"<p>All InfluxDB settings can be applied using environment variables. Environment variables override any settings in the InfluxDB configuration file:</p> <ul> <li> <p>Under \"new menu\" (master branch), environment variables are stored inline in</p> <pre><code>~IOTstack/docker-compose.yml\n</code></pre> </li> <li> <p>Under \"old menu\", environment variables are stored in:</p> <pre><code>~/IOTstack/services/influxdb/influxdb.env\n</code></pre> </li> </ul> <p>Whenever you change an environment variable, you activate it like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d influxdb\n</code></pre> <p>The default service definition provided with IOTstack exposes the following environment variables:</p> <ul> <li><code>TZ=Etc/UTC</code> set this to your local timezone. Do not use quote marks!</li> <li> <p><code>INFLUXDB_HTTP_FLUX_ENABLED=false</code> set this <code>true</code> if you wish to use Flux queries rather than InfluxQL:</p> <p>At the time of writing, Grafana queries use InfluxQL.</p> </li> <li> <p><code>INFLUXDB_REPORTING_DISABLED=false</code> InfluxDB activates phone-home reporting by default. This variable disables it for IOTstack. You can activate it if you want your InfluxDB instance to send reports to the InfluxDB developers.</p> </li> <li> <p><code>INFLUXDB_MONITOR_STORE_ENABLED=FALSE</code> disables automatic creation of the <code>_internal</code> database. This database stores metrics about InfluxDB itself. The database is incredibly busy. Side-effects of enabling this feature include increased wear and tear on SD cards and, occasionally, driving CPU utilisation through the roof and generally making your IOTstack unstable.</p> <p>To state the problem in a nutshell: do you want Influx self-metrics, or do you want a usable IOTstack? You really can't have both. See also issue 19543.</p> </li> <li> <p>Authentication variables:</p> <ul> <li><code>INFLUXDB_HTTP_AUTH_ENABLED=false</code></li> <li><code>INFLUX_USERNAME=dba</code></li> <li><code>INFLUX_PASSWORD=supremo</code></li> </ul> <p>Misunderstanding the purpose and scope of these variables is a common mistake made by new users. Please do not guess! Please read Authentication before you enable or change any of these variables. In particular, <code>dba</code> and <code>supremo</code> are not defaults for database access.</p> </li> <li> <p>UDP data acquisition variables:</p> <ul> <li><code>INFLUXDB_UDP_ENABLED=false</code></li> <li><code>INFLUXDB_UDP_BIND_ADDRESS=0.0.0.0:8086</code></li> <li><code>INFLUXDB_UDP_DATABASE=udp</code></li> </ul> <p>Read UDP support before making any decisions on these variables.</p> </li> </ul>"},{"location":"Containers/InfluxDB/#configFile","title":"about <code>influxdb.conf</code>","text":"<p>A lot of InfluxDB documentation and help material on the web refers to the <code>influxdb.conf</code> configuration file. Such instructions are only appropriate when InfluxDB is installed natively.</p> <p>When InfluxDB runs in a container, changing <code>influxdb.conf</code> is neither necessary nor recommended. Anything that you can do with <code>influxdb.conf</code> can be done with environment variables.</p> <p>However, if you believe that you have a use case that absolutely demands the use of <code>influxdb.conf</code> then you can set it up like this:</p> <ol> <li>Make sure the InfluxDB container is running!</li> <li> <p>Execute the following commands:</p> <pre><code>$ cd ~/IOTstack\n$ docker cp influxdb:/etc/influxdb/influxdb.conf .\n</code></pre> </li> <li> <p>Edit <code>docker-compose.yml</code>, find the <code>influxdb</code> service definition, and add the following line to the <code>volumes:</code> directive:</p> <pre><code>- ./volumes/influxdb/config:/etc/influxdb\n</code></pre> </li> <li> <p>Execute the following commands:</p> <pre><code>$ docker-compose up -d influxdb\n$ sudo mv influxdb.conf ./volumes/influxdb/config/\n$ docker-compose restart influxdb\n</code></pre> </li> </ol> <p>At this point, you can start making changes to:</p> <pre><code>~/IOTstack/volumes/influxdb/config/influxdb.conf\n</code></pre> <p>You can apply changes by sending a <code>restart</code> to the container (as above). However, from time to time you may find that your settings disappear or revert to defaults. Make sure you keep good backups.</p>"},{"location":"Containers/InfluxDB/#connecting","title":"Connecting to InfluxDB","text":"<p>By default, InfluxDB runs in non-host mode and respects the following port-mapping directive in its service definition:</p> <pre><code>ports:\n  - \"8086:8086\"\n</code></pre> <p>If you are connecting from:</p> <ul> <li> <p>another container (eg Node-RED or Grafana) that is also running in non-host mode, use:</p> <pre><code>http://influxdb:8086\n</code></pre> <p>In this context, <code>8086</code> is the internal (right hand side) port number.</p> </li> <li> <p>either the Raspberry Pi itself or from another container running in host mode, use:</p> <pre><code>http://localhost:8086\n</code></pre> <p>In this context, <code>8086</code> is the external (left hand side) port number.</p> </li> <li> <p>a different host, you use either the IP address of the Raspberry Pi or its fully-qualified domain name. Examples:</p> <pre><code>http://192.168.1.10:8086\nhttp://raspberrypi.local:8086\nhttp://iot-hub.mydomain.com:8086\n</code></pre> <p>In this context, <code>8086</code> is the external (left hand side) port number.</p> </li> </ul>"},{"location":"Containers/InfluxDB/#influxCLI","title":"Interacting with the Influx CLI","text":"<p>You can open the <code>influx</code> CLI interactive shell by:</p> <pre><code>$ docker exec -it influxdb influx\nConnected to http://localhost:8086 version 1.8.10\nInfluxDB shell version: 1.8.10\n&gt;\n</code></pre> <p>The command prompt in the CLI is <code>&gt;</code>. While in the CLI you can type commands such as:</p> <pre><code>&gt; help\n&gt; create database MYTESTDATABASE\n&gt; show databases\n&gt; USE MYTESTDATABASE\n&gt; show measurements\n&gt; show series\n&gt; select * from \u00absomeMeasurement\u00bb where \u00absomeCriterion\u00bb\n</code></pre> <p>You may also wish to set retention policies on your databases. This is an example of creating a database named \"mydb\" where any data older than 52 weeks is deleted:</p> <pre><code>&gt; create database mydb\n\n&gt; show retention policies on mydb\nname    duration shardGroupDuration replicaN default\n----    -------- ------------------ -------- -------\nautogen 0s       168h0m0s           1        true\n\n&gt; alter retention policy \"autogen\" on \"mydb\" duration 52w shard duration 1w replication 1 default\n\n&gt; show retention policies on mydb\nname    duration  shardGroupDuration replicaN default\n----    --------  ------------------ -------- -------\nautogen 8736h0m0s 168h0m0s           1        true\n</code></pre> <p>To exit the CLI, either press Control+d or type:</p> <pre><code>&gt; exit\n$\n</code></pre>"},{"location":"Containers/InfluxDB/#usefulAlias","title":"useful alias","text":"<p>Consider adding the following alias to your <code>.bashrc</code>:</p> <pre><code>alias influx='docker exec -it influxdb influx -precision=rfc3339'\n</code></pre> <p>With that alias installed, typing <code>influx</code> and pressing return, gets you straight into the influx CLI. The <code>-precision</code> argument tells the influx CLI to display dates in human-readable form. Omitting that argument displays dates as integer nanoseconds since 1970-01-01.</p> <p>Note:</p> <ul> <li>This alias is installed by IOTstackAliases.</li> </ul>"},{"location":"Containers/InfluxDB/#authentication","title":"Authentication","text":""},{"location":"Containers/InfluxDB/#authWarning","title":"warning","text":"<p>This tutorial also assumes that you do not have any existing databases so it starts by creating two. One database will be provided with access controls but the other will be left alone so that the behaviour can be compared.</p> <p>However, you need to understand that enabling authentication in InfluxDB is all-or-nothing. If you have any existing InfluxDB databases, you will need to:</p> <ul> <li>define access rights for all of your databases; and</li> <li>provide credentials to processes like Node-Red and Grafana that access your databases.</li> </ul> <p>If you do not do this, your existing Node-Red flows, Grafana dashboards and other processes that write to or query your databases will stop working as soon as you activate authentication below.</p>"},{"location":"Containers/InfluxDB/#authStep1","title":"create two test databases","text":"<p>Create two databases named \"mydatabase1\" and \"mydatabase2\":</p> <pre><code>$ influx\n&gt; CREATE DATABASE \"mydatabase1\"\n&gt; CREATE DATABASE \"mydatabase2\"\n</code></pre> <p>Typing <code>influx</code> didn't work? See useful alias above. </p>"},{"location":"Containers/InfluxDB/#authStep2","title":"define users","text":"<p>Define an administrative user. In this example, that user is \"dba\" (database administrator) with the password \"supremo\":</p> <pre><code>&gt; CREATE USER \"dba\" WITH PASSWORD 'supremo' WITH ALL PRIVILEGES\n</code></pre> <ul> <li>Key point: the mixture of \"double\" and 'single' quotes is intentional and required.</li> </ul> <p>Define some garden-variety users:</p> <pre><code>&gt; CREATE USER \"nodered_user\" WITH PASSWORD 'nodered_user_pw'\n&gt; CREATE USER \"grafana_user\" WITH PASSWORD 'grafana_user_pw'\n</code></pre> <p>You can define any usernames you like. The reason for using \"nodered_\" and \"grafana_\" prefixes in these examples is because those are common candidates in an IOTstack environment. The reason for the \"_user\" suffixes is to make it clear that a username is separate and distinct from a container name.</p>"},{"location":"Containers/InfluxDB/#authStep3","title":"assign access rights","text":"<p>The user \"dba\" already has access to everything but, for all other users, you need to state which database(s) the user can access, and whether that access is:</p> <ul> <li>READ (aka read-only)</li> <li>WRITE (aka write-only)</li> <li>ALL (implies both READ and WRITE)</li> </ul> <pre><code>&gt; GRANT WRITE ON \"mydatabase1\" TO \"nodered_user\"\n&gt; GRANT READ ON \"mydatabase1\" TO \"grafana_user\"\n</code></pre> <ul> <li>Key point: you CREATE a user once but you need to GRANT access to every database to which that user needs access.</li> </ul> <p>Once you have finished defining users and assigning access rights, drop out of the influx CLI:</p> <pre><code>&gt; exit\n$\n</code></pre>"},{"location":"Containers/InfluxDB/#authStep4","title":"activate authentication","text":"<p>Make sure you read the warning above, then edit the InfluxDB environment variables to enable this key:</p> <pre><code>- INFLUXDB_HTTP_AUTH_ENABLED=true\n</code></pre> <p>Put the change into effect by \"upping\" the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d influxdb\n\nRecreating influxdb ... done\n</code></pre> <p>The <code>up</code> causes <code>docker-compose</code> to notice that the environment has changed, and to rebuild the container with the new settings.</p> <ul> <li> <p>Note: You should always wait for 30 seconds after a rebuild for InfluxDB to become available. Any time you see a message like this:</p> <pre><code>Failed to connect to http://localhost:8086: Get http://localhost:8086/ping: dial tcp 127.0.0.1:8086: connect: connection refused\nPlease check your connection settings and ensure 'influxd' is running.\n</code></pre> <p>it simply means that you did not wait long enough. Be patient!</p> </li> </ul>"},{"location":"Containers/InfluxDB/#authStep5","title":"experiments","text":"<p>Start the influx CLI:</p> <pre><code>$ influx\n</code></pre> <p>Unless you have also set up the <code>INFLUX_USERNAME</code> and <code>INFLUX_PASSWORD</code> environment variables (described later under Authentication Hints), your session will not be authenticated as any user so you will not be able to access either database:</p> <pre><code>&gt; USE mydatabase1\nERR: unable to parse authentication credentials\nDB does not exist!\n&gt; USE mydatabase2\nERR: unable to parse authentication credentials\nDB does not exist!\n</code></pre> <ul> <li>Key point: This is what will happen to any of your pre-existing databases if you enable authentication without a lot of care. You must define users and access rights for all of your databases, and you must provide those credentials to the relevant processes like Node-Red and Grafana.</li> </ul> <p>Authenticate as \"nodered_user\" and try again:</p> <pre><code>&gt; AUTH\nusername: nodered_user\npassword: \n&gt; USE mydatabase1\nUsing database mydatabase1\n&gt; USE mydatabase2\nERR: Database mydatabase2 doesn't exist. Run SHOW DATABASES for a list of existing databases.\nDB does not exist!\n</code></pre> <p>The \"nodered_user\" can access \"mydatabase1\" but not \"mydatabase2\". You will get similar behaviour for the \"grafana_user\" (try it).</p> <p>Authenticate as the \"dba\" and try again:</p> <pre><code>&gt; AUTH\nusername: dba\npassword: \n&gt; USE mydatabase1\nUsing database mydatabase1\n&gt; USE mydatabase2\nUsing database mydatabase2\n</code></pre> <p>The super-user can access both databases.</p> <p>To get a list of users:</p> <pre><code>&gt; SHOW USERS\nuser         admin\n----         -----\ndba          true\nnodered_user false\ngrafana_user false\n</code></pre> <ul> <li>Key point: you must be authenticated as the \"dba\" to run SHOW USERS.</li> </ul> <p>To find out what privileges a user has on a database:</p> <pre><code>&gt; SHOW GRANTS FOR \"nodered_user\"\ndatabase    privilege\n--------    ---------\nmydatabase1 WRITE\n</code></pre> <ul> <li>Key point: you must be authenticated as the \"dba\" to run SHOW GRANTS.</li> </ul> <p>To test grants, you can try things like this:</p> <pre><code>AUTH\nusername: nodered_user\npassword: \n&gt; USE \"mydatabase1\"\nUsing database mydatabase1\n&gt; INSERT example somefield=123\n</code></pre> <p>\"nodered_user\" has WRITE access to \"mydatabase1\".</p> <pre><code>&gt; SELECT * FROM example\nERR: error authorizing query: nodered_user not authorized to execute statement 'SELECT * FROM example', requires READ on mydatabase1\n</code></pre> <p>\"nodered_user\" does not have READ access to \"mydatabase1\".</p> <p>Authenticate as \"grafana_user\" and try the query again:</p> <pre><code>&gt; AUTH\nusername: grafana_user\npassword: \n&gt; SELECT * FROM example\nname: example\ntime                         somefield\n----                         ---------\n2020-09-19T01:41:09.6390883Z 123\n</code></pre> <p>\"grafana_user\" has READ access to \"mydatabase1\". Try an insertion as \"grafana_user\":</p> <pre><code>&gt; INSERT example somefield=456\nERR: {\"error\":\"\\\"grafana_user\\\" user is not authorized to write to database \\\"mydatabase1\\\"\"}\n</code></pre> <p>\"grafana_user\" does not have WRITE access to \"mydatabase1\".</p> <p>Change the privileges for \"nodered_user\" to ALL then try both an insertion and a query. Note that changing privileges requires first authenticating as \"dba\":</p> <pre><code>&gt; AUTH\nusername: dba\npassword: \n&gt; GRANT ALL ON \"mydatabase1\" TO \"nodered_user\"\n&gt; AUTH\nusername: nodered_user\npassword: \n&gt; INSERT example somefield=456\n&gt; SELECT * FROM example\nname: example\ntime                          somefield\n----                          ---------\n2020-09-19T01:41:09.6390883Z  123\n2020-09-19T01:42:36.85766382Z 456\n</code></pre> <p>\"nodered_user\" has both READ and WRITE access to \"mydatabase1\".</p>"},{"location":"Containers/InfluxDB/#authNotes","title":"notes","text":"<ol> <li> <p>Some inferences to draw from the above:</p> <ul> <li>user definitions are global rather than per-database. Grants are what tie users to particular databases.</li> <li>setting <code>INFLUXDB_HTTP_AUTH_ENABLED=true</code> is how authentication is activated and enforced. If it is false, all enforcement goes away (a handy thing to know if you lose passwords or need to recover from a mess).</li> <li>as the \"HTTP\" in <code>INFLUXDB_HTTP_AUTH_ENABLED</code> suggests, it applies to access via HTTP. This includes the influx CLI and processes like Node-Red and Grafana.</li> </ul> </li> <li> <p>Always keep in mind that the InfluxDB log is your friend:</p> <pre><code>$ docker logs influxdb\n</code></pre> </li> </ol>"},{"location":"Containers/InfluxDB/#authHints","title":"hints","text":"<p>After you enable authentication, there are a couple of ways of speeding-up your daily activities. You can pass the dba username and password on the end of the influx alias:</p> <pre><code>$ influx -database mydatabase1 -username dba -password supremo\n</code></pre> <p>but this is probably sub-optimal because of the temptation to hard-code your dba password into scripts. An alternative is to enable these environment variables:</p> <pre><code>- INFLUX_USERNAME=dba\n- INFLUX_PASSWORD=supremo\n</code></pre> <p>and then \"up\" the container as explained above to apply the changes.</p> <p>Misunderstandings about the scope and purpose of <code>INFLUX_USERNAME</code> and <code>INFLUX_PASSWORD</code> are quite common so make sure you realise that the variables:</p> <ul> <li>do not \"set\" any username or password within InfluxDB;</li> <li>only apply to starting the influx CLI\u00a0\u2013\u00a0they are just synonyms for the <code>-username</code> and <code>-password</code> parameters on the <code>influx</code> CLI command; and</li> <li>are not some kind of general-access credentials that apply to everything. They will not work from Node-RED or Grafana!</li> </ul> <p>In other words, with <code>INFLUX_USERNAME</code> and <code>INFLUX_PASSWORD</code> added to the environment, the following two commands are identical:</p> <pre><code>$ influx -database mydatabase1 -username dba -password supremo\n$ influx -database mydatabase1\n</code></pre> <p>The <code>INFLUX_USERNAME</code> and <code>INFLUX_PASSWORD</code> variables also work if you start a shell into the InfluxDB container and then invoke the influx CLI from there:</p> <pre><code>$ docker exec -it influxdb bash\n# influx\n&gt;\n</code></pre> <p>That is all the <code>INFLUX_USERNAME</code> and <code>INFLUX_PASSWORD</code> variables do.</p>"},{"location":"Containers/InfluxDB/#authCleanup","title":"cleaning up","text":"<p>To undo the steps in this tutorial, first set <code>INFLUXDB_HTTP_AUTH_ENABLED=false</code> and then \"up\" influxdb. Then:</p> <pre><code>$ influx\n&gt; DROP USER \"dba\"\n&gt; DROP USER \"nodered_user\"\n&gt; DROP USER \"grafana_user\"\n&gt; DROP DATABASE \"mydatabase1\"\n&gt; DROP DATABASE \"mydatabase2\"\n&gt; exit\n</code></pre>"},{"location":"Containers/InfluxDB/#udpSupport","title":"UDP support","text":"<p>Assumptions:</p> <ul> <li>you want to enable UDP support; and</li> <li>your goal is to log traffic arriving on UDP port 8086 into an InfluxDB database named \"udp\".</li> </ul>"},{"location":"Containers/InfluxDB/#udpAliases","title":"aliases","text":"<p>This tutorial uses the following aliases:</p> <ul> <li><code>influx</code> - explained earlier - see useful alias.</li> <li> <p><code>DPS</code> which is the equivalent of:</p> <pre><code>$ docker ps --format \"table {{.Names}}\\t{{.RunningFor}}\\t{{.Status}}\"\n</code></pre> <p>The focus is: what containers are running?</p> </li> <li> <p><code>DNET</code> which is the equivalent of:</p> <pre><code>$ docker ps --format \"table {{.Names}}\\t{{.Ports}}\"\n</code></pre> <p>The focus is: what ports are containers using?</p> <p>Any container where no ports are listed is either exposing no ports and/or is running in host mode.</p> </li> </ul> <p>Although both <code>DPS</code> &amp; <code>DNET</code> invoke <code>docker ps</code>, the formatting means the output usually fits on your screen without line wrapping.</p> <p>All three aliases are installed by IOTstackAliases.</p>"},{"location":"Containers/InfluxDB/#udpStep1","title":"confirm that UDP is not enabled","text":"<pre><code>$ DNET\nNAMES      PORTS\ninfluxdb   0.0.0.0:8086-&gt;8086/tcp\n</code></pre> <p>Interpretation: Docker is listening on TCP port 8086, and is routing the traffic to the same port on the influxdb container. There is no mention of UDP.</p>"},{"location":"Containers/InfluxDB/#udpStep2","title":"create a database to receive the traffic","text":"<p>This tutorial uses the database name of \"udp\".</p> <pre><code>$ influx\n&gt; create database udp\n&gt; exit\n&gt; $\n</code></pre>"},{"location":"Containers/InfluxDB/#udpStep3","title":"define a UDP port mapping","text":"<p>Edit <code>docker-compose.yml</code> to define a UDP port mapping (the second line in the <code>ports</code> grouping below):</p> <pre><code>influxdb:\n  \u2026\n  ports:\n    - \"8086:8086\"\n    - \"8086:8086/udp\"\n  \u2026\n</code></pre>"},{"location":"Containers/InfluxDB/#udpStep4","title":"enable UDP support","text":"<p>Edit your <code>docker-compose.yml</code> and change the InfluxDB environment variables to glue it all together:</p> <pre><code>environment:\n  - INFLUXDB_UDP_DATABASE=udp\n  - INFLUXDB_UDP_ENABLED=true\n  - INFLUXDB_UDP_BIND_ADDRESS=0.0.0.0:8086\n</code></pre> <p>In this context, the IP address \"0.0.0.0\" means \"this host\" (analogous to the way \"255.255.255.255\" means \"all hosts\").</p>"},{"location":"Containers/InfluxDB/#udpStep5","title":"rebuild the container","text":"<pre><code>$ cd ~/IOTstack\n$ docker-compose up -d influxdb\n\nRecreating influxdb ... done\n</code></pre> <p>The <code>up</code> causes <code>docker-compose</code> to notice that the environment has changed, and to rebuild the container with the new settings.</p>"},{"location":"Containers/InfluxDB/#udpStep6","title":"confirm that UDP is enabled","text":"<pre><code>$ DNET\nNAMES      PORTS\ninfluxdb   0.0.0.0:8086-&gt;8086/tcp, 0.0.0.0:8086-&gt;8086/udp\n</code></pre> <p>Interpretation: In addition to the TCP port, Docker is now listening on UDP port 8086, and is routing the traffic to the same port on the influxdb container.</p>"},{"location":"Containers/InfluxDB/#udpStep7","title":"check your work","text":"<p>Check the log: </p> <pre><code>$ docker logs influxdb\n</code></pre> <p>If you see a line like this:</p> <pre><code>ts=2020-09-18T03:09:26.154478Z lvl=info msg=\"Started listening on UDP\" log_id=0PJnqbK0000 service=udp addr=0.0.0.0:8086\n</code></pre> <p>then everything is probably working correctly. If you see anything that looks like an error message then you will need to follow your nose.</p>"},{"location":"Containers/InfluxDB/#udpStep8","title":"start sending traffic","text":"<p>Although the how-to is beyond the scope of this tutorial, you will need a process that can send \"line format\" payloads to InfluxDB using UDP port 8086.</p> <p>Once that is set up, you can inspect the results like this:</p> <pre><code>$ influx -database udp\n&gt; show measurements\n</code></pre> <p>If data is being received, you will get at least one measurement name. An empty list implies no data is being received.</p> <p>If you get at least one measurement name then you can inspect the data using:</p> <pre><code>&gt; select * from \u00abmeasurement\u00bb\n</code></pre> <p>where <code>\u00abmeasurement\u00bb</code> is one of the names in the <code>show measurements</code> list.</p>"},{"location":"Containers/InfluxDB/#flashWear","title":"Reducing flash wear-out","text":"<p>SSD-drives have pretty good controllers spreading out writes, so this isn't a this isn't really a concern for them.  But if you store data on an SD-card, flash wear may cause the card to fail prematurely. Flash memory has a limited number of erase-write cycles per physical block. These blocks may be multiple megabytes. You can use <code>sudo lsblk -D</code> to see how big the erase granularity is on your card. The goal is to avoid writing lots of small changes targeting the same physical blocks. Here are some tips to mitigate SD-card wear:</p> <ul> <li>Don't use short retention policies. This may mask heavy disk IO without increasing disk space usage. Depending on the flash card and file system used, new data may be re-written to the same blocks that were freed by the expiration, wearing them out.</li> <li>Take care not to add measurements too often. If possible no more often than once a minute. Add all measurements in one operation. Even a small write will physically write a whole new block and erase the previously used block.</li> <li>Adding measurements directly to Influxdb will cause a write on every operation. If your client code can't aggregate multiple measurements into one write, consider routing them via Telegraf. It has the <code>flush_interval</code>-option, which will combine the measurements into one write.</li> <li>All InfluxDB queries are logged by default and logs are written to the SD-card. To disable this, add into docker-compose.yml, next to the other INFLUXDB_* entries:</li> </ul> <pre><code>    - INFLUXDB_DATA_QUERY_LOG_ENABLED=false\n    - INFLUXDB_HTTP_LOG_ENABLED=false\n</code></pre> <p>This is especially important if you plan on having Grafana or Chronograf displaying up-to-date data on a dashboard, making queries all the time.</p>"},{"location":"Containers/InfluxDB/#debugging","title":"Debugging","text":""},{"location":"Containers/InfluxDB/#debugInspection","title":"Container won't start","text":"<p>Sometimes you need start the container without starting influxdb to access its maintenance tools. Usually when influx crashes on startup.</p> <p>Add a new line below <code>influxdb:</code> to your docker-compose.yml:</p> <pre><code>influxdb:\n  \u2026\n  entrypoint: sleep infinity\n</code></pre> <p>Recreate the container using the new entrypoint:</p> <pre><code>$ docker-compose up -d influxdb\nRecreating influxdb ... done\n</code></pre> <p>Now the container should start and you can get a shell to poke around and try the <code>influx_inspect</code> command:</p> <pre><code>$ docker exec -it influxdb bash\n# influx_inspect\nUsage: influx_inspect [[command] [arguments]]\n</code></pre> <p>Once you have finished poking around, you should undo the change by removing the custom entrypoint and <code>up -d</code> again to return to normal container behaviour where you can then test to see if your fixes worked.</p>"},{"location":"Containers/InfluxDB/#debugPackages","title":"Adding packages","text":"<p>The container is pretty bare-bones by default. It is OK to install additional tools. Start by running:</p> <pre><code># apt update\n</code></pre> <p>and then use <code>apt install</code> to add whatever you need. Packages you add will persist until the next time the container is re-created.  </p>"},{"location":"Containers/InfluxDB/#debugSniff","title":"Sniffing traffic","text":"<p>If you need to see the actual packets being sent to Influx for insertion into your database, you can set it up like this:</p> <pre><code>$ docker exec influxdb bash -c 'apt update &amp;&amp; apt install tcpdump -y'\n</code></pre> <p>That adds <code>tcpdump</code> to the running container and, as noted above, that will persist until you re-create the container.</p> <p>To capture traffic:</p> <pre><code>$ docker exec influxdb tcpdump -i eth0 -s 0 -n -c 100 -w /var/lib/influxdb/capture.pcap dst port 8086\n</code></pre> <p>Breaking that down:</p> <ul> <li><code>-i eth0</code> is the container's internal virtual Ethernet network interface (attached to the internal bridged network)</li> <li><code>-s 0</code> means \"capture entire packets\"</li> <li><code>-n</code> means \"do not try to resolve IP addresses to domain names</li> <li><code>-c 100</code> is optional and means \"capture 100 packets then stop\". If you omit this option, <code>tcpdump</code> will capture packets until you press control+C.</li> <li><code>-w /var/lib/influxdb/capture.pcap</code> is the internal path to the file where captured packets are written. You can, of course, substitute any filename you like for <code>capture.pcap</code>.</li> <li><code>dst port 8086</code> captures all packets where the destination port field is 8086, which is the InfluxDB internal port number.</li> </ul> <p>The internal path:</p> <pre><code>/var/lib/influxdb/capture.pcap\n</code></pre> <p>maps to the external path:</p> <pre><code>~/IOTstack/volumes/influxdb/data/capture.pcap\n</code></pre> <p>You can copy that file to another system where you have a tool like WireShark installed. WireShark will open the file and you can inspect packets and verify that the information being sent to InfluxDB is what you expect.</p> <p>Do not forget to clean-up any packet capture files:</p> <pre><code>$ cd ~/IOTstack/volumes/influxdb/data\n$ sudo rm capture.pcap\n</code></pre>"},{"location":"Containers/InfluxDB2/","title":"InfluxDB 2","text":""},{"location":"Containers/InfluxDB2/#references","title":"references","text":"<ul> <li>InfluxData home page</li> <li>DockerHub</li> <li>GitHub</li> </ul>"},{"location":"Containers/InfluxDB2/#assumptions","title":"assumptions","text":"<ol> <li> <p>Your Raspberry Pi is running full 64-bit Raspberry Pi OS Debian GNU/Linux 11 (bullseye).</p> <ul> <li>DockerHub does not have a 32-bit image for InfluxDB\u00a02 so you can't run this container until you have upgraded.</li> <li>Running full 64-bit is not the same as enabling the 64-bit kernel in <code>/boot/config.txt</code>. User-mode needs to be 64-bit capable as well. You must start from a full 64-bit image.</li> </ul> </li> <li> <p>Node-RED is your principal mechanism for feeding data to InfluxDB\u00a01.8.</p> <ul> <li>You may have other services feeding data to InfluxDB\u00a01.8 (eg Telegraf). The steps documented here will migrate all your existing data but do not discuss how to adapt services other than Node-RED to feed new data to InfluxDB\u00a02.</li> </ul> </li> <li> <p>Grafana is your principle mechanism for creating dashboards based on data stored in InfluxDB\u00a01.8.</p> <ul> <li>You may have other visualisation tools. You may gain insights from studying how Grafana needs to be changed to run Flux queries against InfluxDB\u00a02 buckets but this documentation does not explore alternatives.</li> </ul> </li> <li> <p>Node-RED, InfluxDB\u00a01.8 and Grafana are all running in non-host mode on the same Docker instance, and that it is your intention to deploy InfluxDB\u00a02 in non-host mode as well.</p> <ul> <li>If you are running any containers in host mode or have distributed the services across multiple Docker instances, you will have to adapt appropriately.</li> </ul> </li> </ol>"},{"location":"Containers/InfluxDB2/#terminology-database-vs-bucket","title":"terminology: database vs bucket","text":"<p>InfluxDB\u00a01.8 and InfluxDB\u00a02 are both database management systems (DBMS), sometimes referred to as \"engines\", optimised for storage and retrieval of time-series data. InfluxDB\u00a01.8 uses the term database to mean a collection of measurements. InfluxDB\u00a02 uses the term bucket to mean the same thing.</p> <p>When an InfluxDB\u00a01.8 database is migrated, it becomes an InfluxDB\u00a02 bucket. You will see this change in terminology in various places, such as the InfluxDB-out node in Node-RED. When that node is set to:</p> <ul> <li> <p>Version 1.x, the user interface has a \"Database\" field which travels with the connection. For example:</p> <ul> <li>[v1.x] influxdb:8086/power (set up in the connection sheet)</li> </ul> <p>This implies that you need one connection per database.</p> </li> <li> <p>Version 2.0, the user interface has a \"Bucket\" field which is independent of the connection. For example:</p> <ul> <li>[v2.0] influxdb2:8086 (set up in the connection sheet)</li> <li>Bucketpower/autogen (set up in the node)</li> </ul> <p>This implies that you need one connection per engine. It is a subtle but important difference.</p> </li> </ul>"},{"location":"Containers/InfluxDB2/#reference-service-definition","title":"reference service definition","text":"<p>The InfluxDB\u00a02 service definition is added to your compose file by the IOTstack menu.</p> <pre><code>influxdb2:\n  container_name: influxdb2\n  image: \"influxdb:latest\"\n  restart: unless-stopped\n  environment:\n    - TZ=Etc/UTC\n    - DOCKER_INFLUXDB_INIT_USERNAME=me\n    - DOCKER_INFLUXDB_INIT_PASSWORD=mypassword\n    - DOCKER_INFLUXDB_INIT_ORG=myorg\n    - DOCKER_INFLUXDB_INIT_BUCKET=mybucket\n    - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=my-super-secret-auth-token\n    - DOCKER_INFLUXDB_INIT_MODE=setup\n  # - DOCKER_INFLUXDB_INIT_MODE=upgrade\n  ports:\n    - \"8087:8086\"\n  volumes:\n    - ./volumes/influxdb2/data:/var/lib/influxdb2\n    - ./volumes/influxdb2/config:/etc/influxdb2\n    - ./volumes/influxdb2/backup:/var/lib/backup\n  # - ./volumes/influxdb.migrate/data:/var/lib/influxdb:ro\n  healthcheck:\n    test: [\"CMD\", \"influx\", \"ping\"]\n    interval: 30s\n    timeout: 10s\n    retries: 3\n    start_period: 30s\n</code></pre> <p>As an alternative to using the menu, you can copy and paste the service definition into your compose file from the template at:</p> <pre><code>~/IOTstack/.templates/influxdb2/service.yml\n</code></pre>"},{"location":"Containers/InfluxDB2/#required-edits","title":"required edits","text":"<p>Edit the service definition in your compose file to change the following variables:</p> <ul> <li> <p><code>TZ=</code>\u00abcountry\u00bb/\u00abcity\u00bb</p> </li> <li> <p><code>DOCKER_INFLUXDB_INIT_USERNAME=</code>\u00abusername\u00bb</p> <p>This name becomes the administrative user. It is associated with your \u00abpassword\u00bb and \u00abtoken\u00bb.</p> </li> <li> <p><code>DOCKER_INFLUXDB_INIT_PASSWORD=</code>\u00abpassword\u00bb</p> <p>Your \u00abusername\u00bb and \u00abpassword\u00bb form your login credentials when you administer InfluxDB\u00a02 using its web-based graphical user interface. The strength of your password is up to you.</p> </li> <li> <p><code>DOCKER_INFLUXDB_INIT_ORG=</code>\u00aborganisation\u00bb</p> <p>An organisation name is required. Examples:</p> <ul> <li>myorg</li> <li>my-house</li> <li>com.mydomain.myhouse</li> </ul> </li> <li> <p><code>DOCKER_INFLUXDB_INIT_BUCKET=</code>\u00abbucket\u00bb</p> <p>A default bucket name is required. The name does not matter because you won't actually be using it so you can accept the default of \"mybucket\". You can delete the unused bucket later if you want to be tidy.</p> </li> <li> <p><code>DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=</code>\u00abtoken\u00bb</p> <p>Although you can let InfluxDB\u00a02 generate your access token for you, it will keep things simple if you generate your own. Here are some possible approaches:</p> <ol> <li> <p>use a universally-unique ID:</p> <pre><code>$ uuidgen\n4fef85b4-2f56-480f-b143-fa5cb6e8f18a\n</code></pre> </li> <li> <p>use GnuPG to generate a random string:</p> <pre><code>$ gpg --gen-random -a 0 25\nbYS3EsnnY0AlRxJ2uk44Hzwm7GMKYu5unw==\n</code></pre> </li> <li> <p>use a password-generator of your choosing.</p> </li> </ol> </li> </ul> <p>Note:</p> <ul> <li>Unless a container's documentation explicitly states that it is supported, you should never use quote marks to encapsulate the values you supply via environment variables. InfluxDB\u00a02 treats quotes as being part of the value (eg a password of \"fred\" is the 6-character string that includes the quotes). If you put quote marks around anything as you were editing, please go back and remove them.</li> </ul>"},{"location":"Containers/InfluxDB2/#table-1-mode-specific-directives","title":"Table 1: mode-specific directives","text":"<p>InfluxDB 2 operates in three distinct modes which are controlled by the <code>DOCKER_INFLUXDB_INIT_MODE</code> environment variable. The table below summarises the variables and volumes mappings that need to be active in each mode.</p> <p></p>"},{"location":"Containers/InfluxDB2/#initialising-influxdb-2","title":"initialising InfluxDB 2","text":"<p>If you have only just included the template service definition in your compose file and performed the required edits, then you can follow the initialisation process below.</p> <p>However, if you want to re-initialise the container, go to re-initialising InfluxDB\u00a02.</p> <p>To initialise InfluxDB\u00a02:</p> <ol> <li>Confirm that the service definition directives are set as per the \"setup\" column of Table 1. </li> <li> <p>Be in the correct directory (assumed throughout):</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>Start the InfluxDB\u00a02 container:</p> <pre><code>$ docker-compose up -d influxdb2\n</code></pre> </li> <li> <p>InfluxDB\u00a02 will notice the following environment variable:</p> <pre><code>DOCKER_INFLUXDB_INIT_MODE=setup\n</code></pre> <p>This instructs the container to initialise the database engine structures based on a combination of defaults and the values you provide via the other environment variables.</p> </li> <li> <p>Confirm that the InfluxDB\u00a02 container is not in a restart loop and isn't reporting errors by using commands like:</p> <pre><code>$ docker ps\n$ docker logs influxdb2\n</code></pre> </li> </ol> <p>If you don't need to migrate any data from InfluxDB\u00a01.8 you can go straight to running InfluxDB\u00a02, otherwise follow the data-migration procedure instructions below.</p>"},{"location":"Containers/InfluxDB2/#data-migration-procedure","title":"data-migration procedure","text":"<p>Successful migration depends on the following assumptions being true:</p> <ul> <li>The InfluxDB\u00a02 container is running and has just been initialised as per initialising InfluxDB\u00a02.</li> <li> <p>The InfluxDB\u00a01.8 container is running, and is based on the IOTstack service definition (or reasonable facsimile) at:</p> <pre><code>~/IOTstack/.templates/influxdb/service.yml\n</code></pre> </li> </ul> <p>To migrate your InfluxDB\u00a01.8 data:</p> <ol> <li> <p>Be in the correct directory (assumed throughout):</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>InfluxDB\u00a01.8 runs as root and its persistent store is owned by root but not all files and folders in the persistent store are group or world readable. InfluxDB\u00a02 runs as user ID 1000 (user \"influxdb\" inside the container). Because of this, you need to give InfluxDB\u00a02 permission to read the InfluxDB\u00a01.8 persistent store.</p> <p>It is not a good idea to interfere with a persistent store while a container is running so best practice is to stop InfluxDB\u00a01.8 for long enough to make a copy of its persistent store:</p> <pre><code>$ sudo rm -rf ./volumes/influxdb.migrate\n$ docker-compose down influxdb\n$ sudo cp -a ./volumes/influxdb ./volumes/influxdb.migrate\n$ docker-compose up -d influxdb\n$ sudo chown -R 1000:1000 ./volumes/influxdb.migrate/data\n</code></pre> <p>see also if downing a container doesn't work</p> <p>In words:</p> <ol> <li>Ensure any previous attempts at migration are removed. Always be extremely careful with any <code>sudo rm</code> command. Check your work before you press return.</li> <li>Stop InfluxDB\u00a01.8.</li> <li>Make a copy of the InfluxDB\u00a01.8 persistent store.</li> <li>Start InfluxDB\u00a01.8 again.</li> <li>Change ownership of the copy of the InfluxDB\u00a01.8 persistent store.</li> </ol> </li> <li> <p>Edit your compose file as per the \"upgrade\" column of Table 1. The changes you need to make are:</p> <ol> <li> <p>Change the initialisation mode from <code>setup</code> to <code>upgrade</code>:</p> <ul> <li> <p>before editing:</p> <pre><code>    - DOCKER_INFLUXDB_INIT_MODE=setup\n  # - DOCKER_INFLUXDB_INIT_MODE=upgrade\n</code></pre> </li> <li> <p>after editing:</p> <pre><code>  # - DOCKER_INFLUXDB_INIT_MODE=setup\n    - DOCKER_INFLUXDB_INIT_MODE=upgrade\n</code></pre> </li> </ul> </li> <li> <p>Activate the volume mapping to give InfluxDB\u00a02 read-only access to the copy of the InfluxDB\u00a01.8 persistent store that you made in step 2:</p> <ul> <li> <p>before editing:</p> <pre><code>  # - ./volumes/influxdb.migrate/data:/var/lib/influxdb:ro\n</code></pre> </li> <li> <p>after editing:</p> <pre><code>    - ./volumes/influxdb.migrate/data:/var/lib/influxdb:ro\n</code></pre> </li> </ul> </li> </ol> <p>Save your work but do not execute any <code>docker-compose</code> commands.</p> </li> <li> <p>InfluxDB\u00a02 creates a \"bolt\" (lock) file to prevent accidental data-migrations. That file needs to be removed:</p> <pre><code>$ rm ./volumes/influxdb2/data/influxd.bolt\n</code></pre> </li> <li> <p>The InfluxDB\u00a02 container is still running. The following command causes the container to be recreated with the edits you made in step 3:</p> <pre><code>$ docker-compose up -d influxdb2\n</code></pre> </li> <li> <p>InfluxDB\u00a02 will notice the following environment variable:</p> <pre><code>DOCKER_INFLUXDB_INIT_MODE=upgrade\n</code></pre> <p>This, combined with the absence of the \"bolt\" file, starts the migration process. You need to wait until the migration is complete. The simplest way to do that is to watch the size of the persistent store for InfluxDB\u00a02 until it stops increasing. Experience suggests that the InfluxDB\u00a02 persistent store will usually be a bit larger than InfluxDB\u00a01.8. For example:</p> <ul> <li> <p>reference size for an InfluxDB\u00a01.8 installation:</p> <pre><code>$ sudo du -sh ./volumes/influxdb\n633M    ./volumes/influxdb\n</code></pre> </li> <li> <p>final size after migration to InfluxDB\u00a02:</p> <pre><code>$ sudo du -sh ./volumes/influxdb2\n721M    ./volumes/influxdb2\n</code></pre> </li> </ul> </li> <li> <p>Data migration is complete once the folder size stops changing.</p> </li> </ol> <p>Proceed to running InfluxDB\u00a02 below.</p>"},{"location":"Containers/InfluxDB2/#running-influxdb-2","title":"running InfluxDB 2","text":"<p>The container now needs to be instructed to run in normal mode.</p> <ol> <li> <p>Be in the correct directory (assumed throughout):</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>Edit your compose file as per the \"(omitted)\" column of Table 1. The changes are:</p> <ol> <li> <p>Deactivate all <code>DOCKER_INFLUXDB_INIT_</code> environment variables. After editing, the relevant lines should look like:</p> <pre><code>  # - DOCKER_INFLUXDB_INIT_USERNAME=me\n  # - DOCKER_INFLUXDB_INIT_PASSWORD=mypassword\n  # - DOCKER_INFLUXDB_INIT_ORG=myorg\n  # - DOCKER_INFLUXDB_INIT_BUCKET=mybucket\n  # - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=my-super-secret-auth-token\n  # - DOCKER_INFLUXDB_INIT_MODE=setup\n  # - DOCKER_INFLUXDB_INIT_MODE=upgrade\n</code></pre> </li> <li> <p>Deactivate the volume mapping if it is active. After editing, the line should look like:</p> <pre><code>  # - ./volumes/influxdb.migrate/data:/var/lib/influxdb:ro\n</code></pre> </li> </ol> <p>Save your work.</p> </li> <li> <p>The InfluxDB\u00a02 container is still running. The following command causes the container to be recreated with the edits you have just made:</p> <pre><code>$ docker-compose up -d influxdb2\n</code></pre> <p>The absence of an active <code>DOCKER_INFLUXDB_INIT_MODE</code> variable places InfluxDB\u00a02 into normal run mode.</p> </li> <li> <p>If you have just performed a data migration, you can remove the copy of the InfluxDB\u00a01.8 persistent store:</p> <pre><code>$ sudo rm -rf ./volumes/influxdb.migrate\n</code></pre> <p>always be extremely careful with any <code>sudo rm</code> command. Always check your work before you press return.</p> </li> </ol>"},{"location":"Containers/InfluxDB2/#re-initialising-influxdb-2","title":"re-initialising InfluxDB 2","text":"<p>If you need to start over from a clean slate:</p> <ol> <li> <p>Be in the correct directory (assumed throughout):</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>Terminate the InfluxDB\u00a02 container:</p> <pre><code>$ docker-compose down influxdb2\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Remove the persistent store:</p> <pre><code>$ sudo rm -rf ./volumes/influxdb2\n</code></pre> <p>always be extremely careful with any <code>sudo rm</code> command. Always check your work before you press return.</p> </li> <li> <p>Edit your compose file as per the \"setup\" column of Table 1. After editing, the relevant lines should look like this:</p> <pre><code>    - DOCKER_INFLUXDB_INIT_USERNAME=me\n    - DOCKER_INFLUXDB_INIT_PASSWORD=mypassword\n    - DOCKER_INFLUXDB_INIT_ORG=myorg\n    - DOCKER_INFLUXDB_INIT_BUCKET=mybucket\n    - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=my-super-secret-auth-token\n    - DOCKER_INFLUXDB_INIT_MODE=setup\n  # - DOCKER_INFLUXDB_INIT_MODE=upgrade\n</code></pre> </li> </ol> <p>Go to initialising InfluxDB\u00a02.</p>"},{"location":"Containers/InfluxDB2/#exploring-influxdb-2-data","title":"exploring InfluxDB 2 data","text":"<ol> <li> <p>Launch a browser and connect it to port 8087 on your Raspberry Pi. For example:</p> <pre><code>http://raspberrypi.local:8087\n</code></pre> <p>You can also use the IP address or domain name of your Raspberry Pi. In this context, 8087 is the external port number from the left hand side of the port mapping in the service definition:</p> <pre><code>  ports:\n    - \"8087:8086\"\n</code></pre> </li> <li> <p>Sign in to the InfluxDB\u00a02 instance using your \u00abusername\u00bb and \u00abpassword\u00bb.</p> </li> <li> <p>Click on \"Explore\" in the left-hand tool strip. That is marked [A] in the screen shot. In the area marked [B] you should be able to see a list of the buckets that were migrated from InfluxDB\u00a01.8 databases.</p> <p>In the screen shot, I clicked on other fields to create a query:</p> <ul> <li>In area [B], I selected the \"power/autogen\" bucket;</li> <li>In area [C], I selected the \"hiking2\" (electricity meter) measurement;</li> <li>In area [D], I selected the \"voltage\" field;</li> <li>The bucket in this test is a migrated copy of an InfluxDB\u00a01.8 database. It was not ingesting live data so I also needed to change the duration popup menu [E] to a time-span that included the most-recent insertions;</li> <li>Then I clicked the \"Submit\" button [F]; and</li> <li>The result was the graph in [G].</li> </ul> </li> </ol> <p>You can explore your own tables using similar techniques.</p>"},{"location":"Containers/InfluxDB2/#flux-queries-via-point-and-click","title":"Flux queries via point-and-click","text":"<p>Grafana does not (yet) seem to have the ability to let you build Flux queries via point-and-click like you can with InfluxQL queries. Until Grafana gains that ability, it's probably a good idea to learn how to build Flux queries in InfluxDB, so you can copy-and-paste the Flux statements into Grafana.</p> <p>Once you have constructed a query in the \"Query Builder\", click the \"Script Editor\" button [H] to switch to the editor view. </p> <p>For this example, the query text is:</p> <pre><code>from(bucket: \"power/autogen\")\n  |&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |&gt; filter(fn: (r) =&gt; r[\"_measurement\"] == \"hiking2\")\n  |&gt; filter(fn: (r) =&gt; r[\"_field\"] == \"voltage\")\n  |&gt; aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)\n  |&gt; yield(name: \"mean\")\n</code></pre> <p>Two important things to note here are:</p> <ol> <li>The bucket name: <code>power/autogen</code>; and</li> <li>The measurement name: <code>hiking2</code>.</li> </ol>"},{"location":"Containers/InfluxDB2/#example-adapting-node-red","title":"example: adapting Node-RED","text":"<ol> <li> <p>Assume you have an existing flow (eg a fairly standard 3-node flow) which is logging to an InfluxDB\u00a01.8 database. Your goal is to modify the flow to log the same data to the recently-migrated InfluxDB\u00a02 bucket. </p> </li> <li> <p>Start Node-RED if it is not running:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d nodered\n</code></pre> </li> <li> <p>Use a web browser to connect to your Node-RED instance.</p> </li> <li> <p>Drag a new InfluxDB-out node onto the canvas:</p> <ul> <li>This is exactly the same InfluxDB-out node that you have been using to write to your InfluxDB\u00a01.8 databases. There isn't a different node or package for InfluxDB\u00a02.</li> <li>Always drag a new InfluxDB-out node from the palette onto the canvas. Do not make the mistake of re-using an existing InfluxDB-out node (eg via copy and paste) because that is a very good way of breaking your flows.</li> </ul> </li> <li> <p>Double-click the InfluxDB-out node to open it:</p> <p></p> <ul> <li>At [A], give the node a sensible name.</li> <li> <p>Click the pencil icon [B] adjacent to the Server field:</p> <ul> <li>Leave the Name field [C] blank. This ensures that the title in the popup menu [D] automatically reflects the version and connection URL.</li> <li>Change the Version popup menu [E] to \"2.0\". </li> <li> <p>Set the URL [F] to point to your InfluxDB\u00a02 instance:</p> <pre><code>http://influxdb2:8086\n</code></pre> <p>In this context, \"influxdb2\" is the container name and 8086 is the container's internal port. Node-RED communicates with InfluxDB\u00a02 across the internal bridged network (see assumptions).</p> </li> <li> <p>Paste your \u00abtoken\u00bb into the Token field [G].</p> </li> <li>Click \"Update\" [H].</li> </ul> </li> <li> <p>Set the Organisation field [I] to your \u00aborganisation\u00bb.</p> </li> <li> <p>Set the Bucket [J] to the correct value. You can get that from either:</p> <ul> <li>area [B] in the Influx Explorer screen shot; or</li> <li>the bucket name from the saved Flux query.</li> </ul> <p>In this example, the bucket name is \"power/autogen\".</p> </li> <li> <p>Set the Measurement [K] to the measurement name. You can get that from either:</p> <ul> <li>area [C] in the Influx Explorer screen shot; or</li> <li>the measurement name  from the saved Flux query.</li> </ul> <p>In this example, the measurement name is \"hiking2\".</p> </li> <li> <p>Click Done [L].</p> </li> </ul> </li> <li> <p>Connect the outlet of the Change node to the inlet of the InfluxDB-out node.</p> </li> <li>Click Deploy.</li> <li>Watch the debug panel to make sure no errors are being reported.</li> <li> <p>Go back to the InfluxDB\u00a02 Data Explorer and click the refresh button \"I\". If everything has gone according to plan, you should see recent observations added to your graph. </p> <p>You may need to wait until your sensor has sent new data.</p> </li> </ol>"},{"location":"Containers/InfluxDB2/#example-adapting-grafana","title":"example: adapting Grafana","text":""},{"location":"Containers/InfluxDB2/#defining-an-influxdb-2-data-source","title":"defining an InfluxDB 2 data source","text":"<ol> <li> <p>Start Grafana if it is not running:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d grafana\n</code></pre> </li> <li> <p>Use a web browser to connect to your Grafana instance and login as an administrator.</p> </li> <li>Hover your mouse over the \"gear\" icon in the tool-strip on the left hand side, and choose \"Data sources\".</li> <li>Click the \"Add data source\" button.</li> <li>Select the \"InfluxDB\" option.</li> <li> <p>Configure as follows:</p> <p></p> <ul> <li>Change the Name [A] to a  meaningful title that reflects the bucket you are going to query. For example, \"InfluxDB\u00a02.0 power\".</li> <li> <p>Change the Query Language popup menu [B] to \"Flux\".</p> <p>Ignore the advice about Flux support being in beta.</p> </li> <li> <p>Change the URL [C] to point to your InfluxDB\u00a02 instance:</p> <pre><code>http://influxdb2:8086\n</code></pre> <p>In this context, \"influxdb2\" is the container name and 8086 is the container's internal port. Grafana communicates with InfluxDB\u00a02 across the internal bridged network (see assumptions).</p> </li> <li> <p>Turn off all the switches in the \"Auth\" group [D].</p> </li> <li>Set the Organisation [E] to your \u00aborganisation\u00bb.</li> <li> <p>Paste your \u00abtoken\u00bb into the Token field [F].</p> <p>ignore the fact that the prompt text says \"password\" - you need the token!</p> </li> <li> <p>Set the Default Bucket [G] to the bucket (database) you want to query. You can get that from either:</p> <ul> <li>area [B] in the Influx Explorer screen shot; or</li> <li>the bucket name from the saved Flux query.</li> </ul> <p>In this example, the value is \"power/autogen\".</p> </li> <li> <p>Click Save &amp; Test [H].</p> </li> </ul> </li> </ol>"},{"location":"Containers/InfluxDB2/#using-an-influxdb-2-data-source-in-a-dashboard","title":"using an InfluxDB 2 data source in a dashboard","text":"<ol> <li>Find the + icon in the tool-strip on the left hand side, hover your mouse over it and choose \"Create \u00bb dashboard\".</li> <li>Click \"Add a new panel\".</li> <li>Change the \"Data source\" popup to the bucket connection you created earlier (\"InfluxDB\u00a02.2 power\").</li> <li>The editor automatically switches into Flux mode.</li> <li>Paste the query text you saved earlier from the InfluxDB\u00a02 query inspector.</li> <li>If necessary, change the duration to a period that is likely to contain some data to display.</li> <li>Click the Refresh button.</li> <li>Click Apply.</li> </ol> <p>In the side-by-side screen shots below, observations before the straight-line (missing data) segment were imported from InfluxDB\u00a01.8 while observations after the straight-line segment were inserted by the new InfluxDB-out node in Node-RED.</p> <p></p>"},{"location":"Containers/InfluxDB2/#odds-and-ends","title":"odds and ends","text":"<ol> <li> <p>Forgot your token:</p> <pre><code>$ docker exec influxdb2 influx auth ls\n</code></pre> </li> <li> <p>Create a new user, password and token:</p> <pre><code>$ docker exec influxdb2 influx user create --name \u00abusername\u00bb --password \u00abpassword\u00bb\n$ docker exec influxdb2 influx auth create --user \u00abusername\u00bb --all-access\n</code></pre> </li> <li> <p>List available buckets:</p> <pre><code>$ docker exec influxdb2 influx bucket ls\n</code></pre> </li> <li> <p>Delete the default \u00abbucket\u00bb:</p> <pre><code>$ docker exec influxdb2 influx bucket delete --org \u00aborganisation\u00bb --name \u00abbucket\u00bb\n</code></pre> </li> </ol>"},{"location":"Containers/InfluxDB2/#migration-strategy","title":"migration strategy","text":"<p>From the fact that both InfluxDB\u00a01.8 and InfluxDB\u00a02 can run in parallel, with Node-RED feeding the same data to both, it should be self-evident that you can repeat the data-migration as often as necessary, simply by starting from re-initialising InfluxDB\u00a02.</p> <p>This implies that you can concentrate on one database at a time, adjusting Node-RED so that it writes each row of sensor data to both the InfluxDB\u00a01.8 database and corresponding InfluxDB\u00a02 bucket.</p> <p>Having the data going to both engines means you can take your time adjusting your Grafana dashboards to be based on Flux queries. You can either retrofit InfluxDB\u00a02 bucket sources and Flux queries to existing dashboards, or build parallel dashboards from the ground up.</p>"},{"location":"Containers/Kapacitor/","title":"Kapacitor","text":""},{"location":"Containers/Kapacitor/#references","title":"References","text":"<ul> <li>influxdata Kapacitor documentation</li> <li>GitHub: influxdata/influxdata-docker/kapacitor</li> <li>DockerHub: influxdata Kapacitor</li> </ul>"},{"location":"Containers/Kapacitor/#upgrading-kapacitor","title":"Upgrading Kapacitor","text":"<p>You can update the container via:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune\n</code></pre> <p>In words:</p> <ul> <li><code>docker-compose pull</code> downloads any newer images;</li> <li><code>docker-compose up -d</code> causes any newly-downloaded images to be instantiated as containers (replacing the old containers); and</li> <li>the <code>prune</code> gets rid of the outdated images.</li> </ul>"},{"location":"Containers/Kapacitor/#kapacitor-version-pinning","title":"Kapacitor version pinning","text":"<p>If you need to pin to a particular version:</p> <ol> <li>Use your favourite text editor to open <code>docker-compose.yml</code>.</li> <li> <p>Find the line:</p> <p><code>yaml    image: kapacitor:1.5</code></p> </li> <li> <p>Replace <code>1.5</code> with the version you wish to pin to. For example, to pin to version 1.5.9:</p> <p><code>yaml    image: kapacitor:1.5.9</code></p> <p>Note:</p> <ul> <li>Be cautious about using the <code>latest</code> tag. At the time of writing, there was no <code>linux/arm/v7</code> architecture support. </li> </ul> </li> <li> <p>Save the file and tell <code>docker-compose</code> to bring up the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d kapacitor\n$ docker system prune\n</code></pre> </li> </ol>"},{"location":"Containers/MJPEG-Streamer/","title":"Motion JPEG Streamer","text":"<p>The <code>mjpg-streamer</code> container lets you pass a video stream from a local camera to a <code>motioneye</code> container. The <code>mjpg-streamer</code> and <code>motioneye</code> containers can be running on the same or different hosts.</p> <p>Each <code>mjpg-streamer</code> container can process a stream from an official Raspberry Pi \"ribbon cable\" camera, or from a third-party USB-connected camera, such as those from Logitech.</p> <p>Using <code>mjpg-streamer</code> to handle your video streams gives you a consistent approach to supporting multiple cameras and camera types. You do not need to care about distinctions between \"ribbon\" or USB cameras, nor which hosts are involved.</p>"},{"location":"Containers/MJPEG-Streamer/#raspberry-pi-ribbon-camera","title":"Raspberry Pi Ribbon Camera","text":"<p>This section is only relevant if you are trying to use a camera that connects to your Raspberry Pi via a ribbon cable.</p> <p>Beginning with Raspberry Pi OS Bullseye, the Raspberry Pi Foundation introduced the LibCamera subsystem and withdrew support for the earlier <code>raspistill</code> and <code>raspivid</code> mechanisms which then became known as the legacy camera system.</p> <p>The introduction of the LibCamera subsystem triggered quite a few articles (and videos) on the topic, of which this is one example:</p> <ul> <li>How to use Raspberry Pi Cameras with Bullseye OS Update</li> </ul> <p>Although the LibCamera subsystem works quite well with \"native\" applications, it has never been clear whether it supports passing camera streams to Docker containers. At the time of writing (2023-10-23), this author has never been able to find any examples which demonstrate that such support exists.</p> <p>It is important to understand that:</p> <ol> <li>This only applies to the Raspberry Pi Ribbon Camera;</li> <li>In order to access a Raspberry Pi Ribbon Camera, the <code>mjpg-streamer</code> container depends on the legacy camera system; and</li> <li>The LibCamera subsystem and the legacy camera system are mutually exclusive.</li> </ol> <p>In other words, if you want to use the <code>mjpg-streamer</code> container to process a stream from a Raspberry Pi Ribbon Camera, you have to forgo using the LibCamera subsystem.</p>"},{"location":"Containers/MJPEG-Streamer/#preparing-your-raspberry-pi","title":"preparing your Raspberry Pi","text":"<p>If you have a Raspberry Pi Ribbon Camera, prepare your system like this:</p> <ol> <li> <p>Check the version of your system by running:</p> <pre><code>$ grep \"VERSION_CODENAME\" /etc/os-release\n</code></pre> <p>The answer should be one of \"buster\", \"bullseye\" or \"bookworm\".</p> </li> <li> <p>Configure camera support:</p> <ul> <li> <p>if your system is running Buster, run this command:</p> <pre><code>$ sudo raspi-config nonint do_camera 0\n</code></pre> <p>Buster pre-dates LibCamera so this is the same as enabling the legacy camera system. In this context, <code>0</code> means \"enable\" and <code>1</code> means \"disable\".</p> </li> <li> <p>if your system is running Bullseye or Bookworm, run these commands:</p> <pre><code>$ sudo raspi-config nonint do_camera 1\n$ sudo raspi-config nonint do_legacy 0\n</code></pre> <p>The first command is protective and turns off the LibCamera subsystem, while the second command enables the legacy camera system.</p> <p>When executed from the command line, both the <code>do_camera</code> and <code>do_legacy</code> commands are supported in the Bookworm version of <code>raspi-config</code>. However, neither command is available when <code>raspi-config</code> is invoked as a GUI in a Bookworm system. This likely implies that the commands have been deprecated and will be removed, in which case this documentation will break.</p> </li> </ul> </li> <li> <p>Reboot your system:</p> <pre><code>$ sudo reboot\n</code></pre> </li> <li> <p>Make a note that your ribbon camera will be accessible on <code>/dev/video0</code>.</p> </li> </ol>"},{"location":"Containers/MJPEG-Streamer/#third-party-cameras","title":"Third-party cameras","text":"<p>The simplest approach is:</p> <ol> <li>Connect your camera to a USB port.</li> <li> <p>Run: </p> <pre><code>$ ls -l /dev/v4l/by-id\n</code></pre> <p>This is an example of the response with a LogiTech \"C920 PRO FHD Webcam 1080P\" camera connected:</p> <pre><code>lrwxrwxrwx 1 root root 12 Oct 23 15:42 usb-046d_HD_Pro_Webcam_C920-video-index0 -&gt; ../../video1\nlrwxrwxrwx 1 root root 12 Oct 23 15:42 usb-046d_HD_Pro_Webcam_C920-video-index1 -&gt; ../../video2\n</code></pre> <p>In general, the device at <code>index0</code> is where your camera will be accessible, as in:</p> <pre><code>/dev/v4l/by-id/usb-046d_HD_Pro_Webcam_C920-video-index0\n</code></pre> </li> </ol> <p>If you don't get a sensible response to the <code>ls</code> command then try disconnecting and reconnecting your camera, and rebooting your system.</p>"},{"location":"Containers/MJPEG-Streamer/#container-variables","title":"Container variables","text":""},{"location":"Containers/MJPEG-Streamer/#environment-variables","title":"environment variables","text":"variable default remark <code>MJPG_STREAMER_USERNAME</code> container ID changes each time the container is recreated <code>MJPG_STREAMER_PASSWORD</code> random UUID changes each time the container restarts <code>MJPG_STREAMER_SIZE</code> <code>640x480</code> should be one of your camera's natural resolutions <code>MJPG_STREAMER_FPS</code> <code>5</code> frames per second"},{"location":"Containers/MJPEG-Streamer/#device-variable","title":"device variable","text":"variable default remark <code>MJPG_STREAMER_EXTERNAL_DEVICE</code> <code>/dev/video0</code> must be set to your video device"},{"location":"Containers/MJPEG-Streamer/#setting-your-variables","title":"Setting your variables","text":"<p>To initialise your environment, begin by using a text editor (eg <code>vim</code>, <code>nano</code>) to edit <code>~/IOTstack/.env</code> (which may or may not already exist):</p> <ol> <li> <p>If your <code>.env</code> file does not already define your time-zone, take the opportunity to set it. For example:</p> <pre><code>TZ=Australia/Sydney\n</code></pre> </li> <li> <p>The access credentials default to random values which change each time the container starts. This is reasonably secure but is unlikely to be useful in practice, so you need to invent some credentials of your own. Example:</p> <pre><code>MJPG_STREAMER_USERNAME=streamer\nMJPG_STREAMER_PASSWORD=oNfDG-d1kgzC\n</code></pre> </li> <li> <p>Define the external device path to your camera. Two examples have been given above:</p> <ul> <li> <p>a ribbon camera:</p> <pre><code>MJPG_STREAMER_EXTERNAL_DEVICE=/dev/video0\n</code></pre> </li> <li> <p>a Logitech C920 USB camera:</p> <pre><code>MJPG_STREAMER_EXTERNAL_DEVICE=/dev/v4l/by-id/usb-046d_HD_Pro_Webcam_C920-video-index\n</code></pre> </li> </ul> </li> <li> <p>If you know your camera supports higher resolutions, you can also set the size. Examples:</p> <ul> <li> <p>the ribbon camera can support:</p> <pre><code>MJPG_STREAMER_SIZE=1152x648\n</code></pre> </li> <li> <p>the Logitech C920 can support:</p> <pre><code>MJPG_STREAMER_SIZE=1920x1080\n</code></pre> </li> </ul> </li> <li> <p>If the <code>mjpg-streamer</code> and <code>motioneye</code> containers are going to be running on:</p> <ul> <li> <p>the same host, you can consider increasing the frame rate:</p> <pre><code>MJPG_STREAMER_FPS=30\n</code></pre> <p>Even though we are setting up a web camera, the traffic will never leave the host and will not traverse your Ethernet or WiFi networks.</p> </li> <li> <p>different hosts, you should probably leave the rate at 5 frames per second until you understand the impact on network traffic.</p> </li> </ul> </li> <li> <p>Save your work.</p> </li> </ol> <p>Tip:</p> <ul> <li>Do not use quote marks (either single or double quotes) to surround the values of your environment variables. This is because docker-compose treats the quotes as part of the string. If you used quotes, please go back and remove them.</li> </ul>"},{"location":"Containers/MJPEG-Streamer/#alternative-approach","title":"alternative approach","text":"<p>It is still a good idea to define <code>TZ</code> in your <code>.env</code> file. Most IOTstack containers now use the <code>TZ=${TZ:-Etc/UTC}</code> syntax so a single entry in your <code>.env</code> sets the timezone for all of your containers.</p> <p>However, if you prefer to keep most of your environment variables inline in your <code>docker-compose.yml</code> rather than in <code>.env</code>, you can do that. Example:</p> <pre><code>environment:\n  - TZ=${TZ:-Etc/UTC}\n  - MJPG_STREAMER_USERNAME=streamer\n  - MJPG_STREAMER_PASSWORD=oNfDG-d1kgzC\n  - MJPG_STREAMER_SIZE=1152x648\n  - MJPG_STREAMER_FPS=5\n</code></pre> <p>Similarly for the camera device mapping:</p> <pre><code>devices:\n  - \"/dev/v4l/by-id/usb-046d_HD_Pro_Webcam_C920-video-index:/dev/video0\"\n</code></pre>"},{"location":"Containers/MJPEG-Streamer/#about-variable-substitution-syntax","title":"about variable substitution syntax","text":"<p>If you're wondering about the syntax used for environment variables:</p> <pre><code>  - MJPG_STREAMER_USERNAME=${MJPG_STREAMER_USERNAME:-}\n</code></pre> <p>it means that <code>.env</code> will be checked for the presence of <code>MJPG_STREAMER_USERNAME=value</code>. If the key is found, its value will be used. If the key is not found, the value will be set to a null string. Then, inside the container, a null string is used as the trigger to apply the defaults listed in the table above.</p> <p>In the case of the camera device mapping, this syntax:</p> <pre><code>  - \"${MJPG_STREAMER_EXTERNAL_DEVICE:-/dev/video0}:/dev/video0\"\n</code></pre> <p>means that <code>.env</code> will be checked for the presence of <code>MJPG_STREAMER_EXTERNAL_DEVICE=path</code>. If the key is found, the path will be used. If the key is not found, the path will be set to <code>/dev/video0</code> on the assumption that a camera is present and the device exists.</p> <p>Regardless of whether a device path comes from <code>.env</code>, or is defined inline, or defaults to <code>/dev/video0</code>, if the device does not actually exist then <code>docker-compose</code> will refuse to start the container with the following error:</p> <pre><code>Error response from daemon: error gathering device information while adding custom device \"\u00abpath\u00bb\": no such file or directory\n</code></pre>"},{"location":"Containers/MJPEG-Streamer/#starting-the-container","title":"Starting the container","text":"<ol> <li> <p>Start the container like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d mjpg-streamer\n</code></pre> <p>The first time you do this triggers a fairly long process. First, a basic operating system image is downloaded from DockerHub, then a Dockerfile is run to add the streamer software and construct a local image, after which the local image is instantiated as your running container. Subsequent launches use the local image so the container starts immediately. See also container maintenance.</p> </li> <li> <p>Once the container is running, make sure it is behaving normally and has not gone into a restart loop:</p> <pre><code>$ docker ps -a --format \"table {{.Names}}\\t{{.RunningFor}}\\t{{.Status}}\"\n</code></pre> <p>The <code>docker ps</code> command produces a lot of output which generally results in line-wrapping and can be hard to read. The <code>--format</code> argument reduces this clutter by focusing on the interesting columns. If you have IOTstackAliases installed, you can use <code>DPS</code> instead of copy/pasting the above command.</p> <p>If the container is restarting, you will see evidence of that in the STATUS column. If that happens, re-check the values set in the <code>.env</code> file and \"up\" the container again. The container's log (see below) may also be helpful.</p> </li> <li> <p>Check the container's log:</p> <pre><code>$ docker logs mjpg-streamer\n i: Using V4L2 device.: /dev/video0\n i: Desired Resolution: 1152 x 648\n i: Frames Per Second.: 5\n i: Format............: JPEG\n i: TV-Norm...........: DEFAULT\n o: www-folder-path......: /usr/local/share/mjpg-streamer/www/\n o: HTTP TCP port........: 80\n o: HTTP Listen Address..: (null)\n o: username:password....: streamer:oNfDG-d1kgzC\n o: commands.............: enabled\n</code></pre> <p>Many of the values you set earlier using environment variables show up here so viewing the log is a good way of making sure everything is being passed to the container.</p> <p>Note:</p> <ul> <li>The <code>/dev/video0</code> in the first line of output is the internal device path (inside the container). This is not the same as the external device path associated with <code>MJPG_STREAMER_EXTERNAL_DEVICE</code>. The container doesn't know about the external device path so it has no way to display it.</li> </ul> </li> </ol>"},{"location":"Containers/MJPEG-Streamer/#connecting-the-camera-to-motioneye","title":"Connecting the camera to MotionEye","text":"<ol> <li>Use a browser to connect with MotionEye on port 8765.</li> <li>Authenticate as an administrator (the default is \"admin\" with no password).</li> <li>Click the \u2630 icon at the top, left of the screen so that it rotates 90\u00b0 and exposes the \"Camera\" popup menu.</li> <li>In the \"Camera\" popup menu field, click the \u25be and choose \"Add\u00a0Camera\u2026\".</li> <li>Change the \"Camera Type\" field to \"Network Camera\".</li> <li> <p>If the <code>motioneye</code> and <code>mjpg-streamer</code> containers are running on:</p> <ul> <li> <p>the same host, the URL should be:</p> <pre><code>http://mjpg-streamer:80/?action=stream\n</code></pre> <p>Here:</p> <ul> <li><code>mjpg-streamer</code> is the name of the container. Technically, it is a host name (rather than a domain name); and</li> <li> <p>port 80 is the internal port that the streamer process running inside the container is listening to. It comes from the right hand side of the port mapping in the service definition:</p> <pre><code>ports:\n- \"8980:80\"\n</code></pre> </li> </ul> </li> <li> <p>different hosts, the URL should be in this form:</p> <pre><code>http://\u00abname-or-ip\u00bb:8980/?action=stream\n</code></pre> <p>Here:</p> <ul> <li> <p><code>\u00abname-or-ip\u00bb</code> is the domain name or IP address of the host on which the <code>mjpg-streamer</code> container is running. Examples:</p> <pre><code>http://raspberrypi.local:8980/?action=stream\nhttp://my-spy.domain.com:8980/?action=stream\nhttp://192.168.200.200:8980/?action=stream\n</code></pre> </li> <li> <p>port 8980 is the external port that the host where the <code>mjpg-streamer</code> container is running is listening on behalf of the container. It comes from the left hand side of the port mapping in the service definition:</p> <pre><code>ports:\n- \"8980:80\"\n</code></pre> </li> </ul> </li> </ul> </li> <li> <p>Enter the Username (\"streamer\" in this example).</p> </li> <li>Enter the Password (\"oNfDG-d1kgzC\" in this example).</li> <li>Click in the Username field again. This causes MotionEye to retry the connection, after which the camera should appear in the Camera field.</li> <li>Click OK. The camera feed should start working.</li> </ol>"},{"location":"Containers/MJPEG-Streamer/#maintenance","title":"Container maintenance","text":"<p>Because it is built from a local Dockerfile, the <code>mjpg-streamer</code> does not get updated in response to a normal \"pull\". If you want to rebuild the container, proceed like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull mjpg-streamer\n$ docker-compose up -d mjpg-streamer\n$ docker system prune -f\n</code></pre> <p>If you have IOTstackAliases installed, the above is:</p> <pre><code>$ REBUILD mjpg-streamer\n$ UP mjpg-streamer\n$ PRUNE\n</code></pre>"},{"location":"Containers/MariaDB/","title":"MariaDB","text":""},{"location":"Containers/MariaDB/#source","title":"Source","text":"<ul> <li>Docker hub</li> <li>Webpage</li> </ul>"},{"location":"Containers/MariaDB/#about","title":"About","text":"<p>MariaDB is a fork of MySQL. This is an unofficial image provided by linuxserver.io because there is no official image for arm.</p>"},{"location":"Containers/MariaDB/#connecting-to-the-db","title":"Connecting to the DB","text":"<p>The port is 3306. It exists inside the docker network so you can connect via <code>mariadb:3306</code> for internal connections. For external connections use <code>&lt;your Pis IP&gt;:3306</code></p> <p></p>"},{"location":"Containers/MariaDB/#setup","title":"Setup","text":"<p>Before starting the stack, edit the <code>docker-compose.yml</code> file and check your environment variables. In particular:</p> <pre><code>  environment:\n    - TZ=Etc/UTC\n    - MYSQL_ROOT_PASSWORD=\n    - MYSQL_DATABASE=default\n    - MYSQL_USER=mariadbuser\n    - MYSQL_PASSWORD=\n</code></pre> <p>If you are running old-menu, you will have to set both passwords. Under new-menu, the menu may have allocated random passwords for you but you can change them if you like.</p> <p>You only get the opportunity to change the <code>MQSL_</code> prefixed environment variables before you bring up the container for the first time. If you decide to change these values after initialisation, you will either have to:</p> <ol> <li> <p>Erase the persistent storage area and start again. There are three steps:</p> <ul> <li> <p>Stop the container and remove the persistent storage area:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down mariadb\n$ sudo rm -rf ./volumes/mariadb\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Edit <code>docker-compose.yml</code> and change the variables.</p> </li> <li> <p>Bring up the container:</p> <pre><code>$ docker-compose up -d mariadb\n</code></pre> </li> </ul> </li> <li> <p>Open a terminal window within the container (see below) and change the values by hand.</p> <p>The how-to is beyond the scope of this documentation. Google is your friend!</p> </li> </ol>"},{"location":"Containers/MariaDB/#terminal","title":"Terminal","text":"<p>You can open a terminal session within the mariadb container via:</p> <pre><code>$ docker exec -it mariadb bash\n</code></pre> <p>To connect to the database: <code>mysql -uroot -p</code></p> <p>To close the terminal session, either:</p> <ul> <li>type \"exit\" and press return; or</li> <li>press control+d.</li> </ul>"},{"location":"Containers/MariaDB/#healthCheck","title":"Container health check","text":""},{"location":"Containers/MariaDB/#healthCheckTheory","title":"theory of operation","text":"<p>A script , or \"agent\", to assess the health of the MariaDB container has been added to the local image via the Dockerfile. In other words, the script is specific to IOTstack.</p> <p>The agent is invoked 30 seconds after the container starts, and every 30 seconds thereafter. The agent:</p> <ol> <li> <p>Runs the command:</p> <pre><code>mysqladmin ping -h localhost\n</code></pre> </li> <li> <p>If that command succeeds, the agent compares the response returned by the command with the expected response:</p> <pre><code>mysqld is alive\n</code></pre> </li> <li> <p>If the command returned the expected response, the agent tests the responsiveness of the TCP port the <code>mysqld</code> daemon should be listening on (see customising health-check).</p> </li> <li> <p>If all of those steps succeed, the agent concludes that MariaDB is functioning properly and returns \"healthy\".</p> </li> </ol>"},{"location":"Containers/MariaDB/#healthCheckMonitor","title":"monitoring health-check","text":"<p>Portainer's Containers display contains a Status column which shows health-check results for all containers that support the feature.</p> <p>You can also use the <code>docker ps</code> command to monitor health-check results. The following command narrows the focus to mariadb:</p> <pre><code>$ docker ps --format \"table {{.Names}}\\t{{.Status}}\"  --filter name=mariadb\n</code></pre> <p>Possible reply patterns are:</p> <ol> <li> <p>The container is starting and has not yet run the health-check agent:</p> <pre><code>NAMES     STATUS\nmariadb   Up 5 seconds (health: starting)\n</code></pre> </li> <li> <p>The container has been running for at least 30 seconds and the health-check agent has returned a positive result within the last 30 seconds:</p> <pre><code>NAMES     STATUS\nmariadb   Up 33 seconds (healthy)\n</code></pre> </li> <li> <p>The container has been running for more than 90 seconds but has failed the last three successive health-check tests:</p> <pre><code>NAMES     STATUS\nmariadb   Up About a minute (unhealthy)\n</code></pre> </li> </ol>"},{"location":"Containers/MariaDB/#healthCheckCustom","title":"customising health-check","text":"<p>You can customise the operation of the health-check agent by editing the <code>mariadb</code> service definition in your Compose file:</p> <ol> <li> <p>By default, the <code>mysqld</code> daemon listens to internal port 3306. If you need change that port, you also need to inform the health-check agent via an environment variable. For example, suppose you changed the internal port to 12345:</p> <pre><code>    environment:\n      - MYSQL_TCP_PORT=12345\n</code></pre> <p>Notes:</p> <ul> <li>The <code>MYSQL_TCP_PORT</code> variable is defined by MariaDB, not IOTstack, so changing this variable affects more than just the health-check agent.</li> <li> <p>If you are running \"old menu\", this change should be made in the file:</p> <pre><code>~/IOTstack/services/mariadb/mariadb.env\n</code></pre> </li> </ul> </li> <li> <p>The <code>mysqladmin ping</code> command relies on the root password supplied via the <code>MYSQL_ROOT_PASSWORD</code> environment variable in the Compose file. The command will not succeed if the root password is not correct, and the agent will return \"unhealthy\". </p> </li> <li> <p>If the health-check agent misbehaves in your environment, or if you simply don't want it to be active, you can disable all health-checking for the container by adding the following lines to its service definition:</p> <pre><code>    healthcheck:\n      disable: true\n</code></pre> <p>Note:</p> <ul> <li> <p>The mere presence of a <code>healthcheck:</code> clause in the <code>mariadb</code> service definition overrides the supplied agent. In other words, the following can't be used to re-enable the supplied agent:</p> <pre><code>    healthcheck:\n      disable: false\n</code></pre> <p>You must remove the entire <code>healthcheck:</code> clause.</p> </li> </ul> </li> </ol>"},{"location":"Containers/MariaDB/#keeping-mariadb-up-to-date","title":"Keeping MariaDB up-to-date","text":"<p>To update the <code>mariadb</code> container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull mariadb\n$ docker-compose up -d mariadb\n$ docker system prune\n$ docker system prune\n</code></pre> <p>The first \"prune\" removes the old local image, the second removes the old base image.</p>"},{"location":"Containers/Mosquitto/","title":"Mosquitto","text":"<p>This document discusses an IOTstack-specific version of Mosquitto built on top of Eclipse/Mosquitto using a Dockerfile.</p> <p>If you want the documentation for the original implementation of Mosquitto (just \"as it comes\" from DockerHub) please see Mosquitto.md on the old-menu branch.</p>"},{"location":"Containers/Mosquitto/#references","title":"References","text":"<ul> <li>Eclipse Mosquitto home</li> <li>GitHub: eclipse/mosquitto</li> <li>DockerHub: eclipse-mosquitto</li> <li>Setting up passwords (video)</li> <li>Tutorial: from MQTT to InfluxDB via Node-Red</li> </ul>"},{"location":"Containers/Mosquitto/#significant-directories-and-files","title":"Significant directories and files","text":"<pre><code>~/IOTstack\n\u251c\u2500\u2500 .templates\n\u2502   \u2514\u2500\u2500 mosquitto\n\u2502       \u251c\u2500\u2500 service.yml \u2776\n\u2502       \u251c\u2500\u2500 Dockerfile \u2777\n\u2502       \u251c\u2500\u2500 docker-entrypoint.sh \u2778\n\u2502       \u2514\u2500\u2500 iotstack_defaults \u2779\n\u2502           \u251c\u2500\u2500 config\n\u2502           \u2502   \u251c\u2500\u2500 filter.acl\n\u2502           \u2502   \u2514\u2500\u2500 mosquitto.conf\n\u2502           \u2514\u2500\u2500 pwfile\n\u2502               \u2514\u2500\u2500 pwfile\n\u251c\u2500\u2500 services\n\u2502   \u2514\u2500\u2500 mosquitto\n\u2502       \u2514\u2500\u2500 service.yml \u277a\n\u251c\u2500\u2500 docker-compose.yml \u277b\n\u2514\u2500\u2500 volumes\n    \u2514\u2500\u2500 mosquitto \u277c\n        \u251c\u2500\u2500 config\n        \u2502   \u251c\u2500\u2500 filter.acl \n        \u2502   \u2514\u2500\u2500 mosquitto.conf\n        \u251c\u2500\u2500 data\n        \u2502   \u2514\u2500\u2500 mosquitto.db\n        \u251c\u2500\u2500 log\n        \u2514\u2500\u2500 pwfile \n            \u2514\u2500\u2500 pwfile\n</code></pre> <ol> <li>The template service definition.</li> <li>The Dockerfile used to customise Mosquitto for IOTstack.</li> <li>A replacement for the Eclipse-Mosquitto script of the same name, extended to handle container self-repair.</li> <li>A standard set of defaults for IOTstack (used to initialise defaults on first run, and for container self-repair).</li> <li>The working service definition (only relevant to old-menu, copied from \u2776).</li> <li>The Compose file (includes \u2776).</li> <li> <p>The persistent storage area:</p> <ul> <li>Directories and files in \u277c are owned by userID 1883. This is enforced each time Mosquitto starts.</li> <li>You will normally need <code>sudo</code> to make changes in this area.</li> <li>Each time Mosquitto starts, it automatically replaces anything originating in \u2779 that has gone missing from \u277c. This \"self-repair\" function is intended to provide reasonable assurance that Mosquitto will at least start instead of going into a restart loop.</li> </ul> </li> </ol>"},{"location":"Containers/Mosquitto/#how-mosquitto-gets-built-for-iotstack","title":"How Mosquitto gets built for IOTstack","text":""},{"location":"Containers/Mosquitto/#mosquitto-source-code-github","title":"Mosquitto source code (GitHub)","text":"<p>The source code for Mosquitto lives at GitHub eclipse/mosquitto.</p>"},{"location":"Containers/Mosquitto/#mosquitto-images-dockerhub","title":"Mosquitto images (DockerHub)","text":"<p>Periodically, the source code is recompiled and the resulting image is pushed to eclipse-mosquitto on DockerHub.</p>"},{"location":"Containers/Mosquitto/#iotstack-menu","title":"IOTstack menu","text":"<p>When you select Mosquitto in the IOTstack menu, the template service definition is copied into the Compose file.</p> <p>Under old menu, it is also copied to the working service definition and then not really used.</p>"},{"location":"Containers/Mosquitto/#iotstack-first-run","title":"IOTstack first run","text":"<p>On a first install of IOTstack, you run the menu, choose Mosquitto as one of your containers, and are told to do this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p>See also the Migration considerations (below).</p> <p><code>docker-compose</code> reads the Compose file. When it arrives at the <code>mosquitto</code> fragment, it finds:</p> <pre><code>  mosquitto:\n    container_name: mosquitto\n    build:\n      context: ./.templates/mosquitto/.\n      args:\n      - MOSQUITTO_BASE=eclipse-mosquitto:latest\n    \u2026\n</code></pre> <p>Note:</p> <ul> <li> <p>Earlier versions of the Mosquitto service definition looked like this:</p> <pre><code>  mosquitto:\n    container_name: mosquitto\n    build: ./.templates/mosquitto/.\n    \u2026\n</code></pre> <p>The single-line <code>build</code> produces exactly the same result as the four-line <code>build</code>, save that the single-line form does not support pinning Mosquitto to a specific version.</p> </li> </ul> <p>The <code>./.templates/mosquitto/.</code> path associated with the <code>build</code> tells <code>docker-compose</code> to look for:</p> <pre><code>~/IOTstack/.templates/mosquitto/Dockerfile\n</code></pre> <p>The Dockerfile is in the <code>.templates</code> directory because it is intended to be a common build for all IOTstack users. This is different to the arrangement for Node-RED where the Dockerfile is in the <code>services</code> directory because it is how each individual IOTstack user's version of Node-RED is customised.</p> <p>The Dockerfile begins with:</p> <pre><code>ARG MOSQUITTO_BASE=eclipse-mosquitto:latest\nFROM $MOSQUITTO_BASE\n</code></pre> <p>The <code>FROM</code> statement tells the build process to pull down the base image from DockerHub.</p> <p>It is a base image in the sense that it never actually runs as a container on your Raspberry Pi.</p> <p>The remaining instructions in the Dockerfile customise the base image to produce a local image. The customisations are:</p> <ol> <li> <p>Add the <code>rsync</code> and <code>tzdata</code> packages.</p> <ul> <li><code>rsync</code> helps the container perform self-repair; while</li> <li><code>tzdata</code> enables Mosquitto to respect the \"TZ\" environment variable.</li> </ul> </li> <li> <p>Add a standard set of configuration defaults appropriate for IOTstack.</p> </li> <li> <p>Replace <code>docker-entrypoint.sh</code> with a version which:</p> <ul> <li>Calls <code>rsync</code> to perform self-repair if configuration files go missing; and</li> <li>Enforces 1883:1883 ownership in <code>~/IOTstack/volumes/mosquitto</code>.</li> </ul> </li> </ol> <p>The local image is instantiated to become your running container.</p> <p>When you run the <code>docker images</code> command after Mosquitto has been built, you may see two rows for Mosquitto:</p> <pre><code>$ docker images\nREPOSITORY                      TAG         IMAGE ID       CREATED        SIZE\niotstack_mosquitto              latest      cf0bfe1a34d6   4 weeks ago    11.6MB\neclipse-mosquitto               latest      46ad1893f049   4 weeks ago    8.31MB\n</code></pre> <ul> <li><code>eclipse-mosquitto</code> is the base image; and</li> <li><code>iotstack_mosquitto</code> is the local image.</li> </ul> <p>You may see the same pattern in Portainer, which reports the base image as \"unused\". You should not remove the base image, even though it appears to be unused.</p> <p>Whether you see one or two rows depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Mosquitto/#migration","title":"Migration considerations","text":"<p>Under the original IOTstack implementation of Mosquitto (just \"as it comes\" from DockerHub), the service definition expected the configuration files to be at:</p> <pre><code>~/IOTstack/services/mosquitto/mosquitto.conf\n~/IOTstack/services/mosquitto/filter.acl\n</code></pre> <p>Under this implementation of Mosquitto, the configuration files have moved to:</p> <pre><code>~/IOTstack/volumes/mosquitto/config/mosquitto.conf\n~/IOTstack/volumes/mosquitto/config/filter.acl\n</code></pre> <p>The change of location is one of the things that allows self-repair to work properly. </p> <p>The default versions of each configuration file are the same. Only the locations have changed. If you did not alter either file when you were running the original IOTstack implementation of Mosquitto, there will be no change in Mosquitto's behaviour when it is built from a Dockerfile.</p> <p>However, if you did alter either or both configuration files, then you should compare the old and new versions and decide whether you wish to retain your old settings. For example:</p> <pre><code>$ cd ~/IOTstack\n$ diff ./services/mosquitto/mosquitto.conf ./volumes/mosquitto/config/mosquitto.conf \n</code></pre> <p>You can also use the <code>-y</code> option on the <code>diff</code> command to see a side-by-side comparison of the two files.</p> <p>Using <code>mosquitto.conf</code> as the example, assume you wish to use your existing file instead of the default:</p> <ol> <li> <p>To move your existing file into the new location:</p> <pre><code>$ cd ~/IOTstack\n$ sudo mv ./services/mosquitto/mosquitto.conf ./volumes/mosquitto/config/mosquitto.conf\n</code></pre> <p>The move overwrites the default. At this point, the moved file will probably be owned by user \"pi\" but that does not matter.</p> </li> <li> <p>Mosquitto will always enforce correct ownership (1883:1883) on any restart but it will not overwrite permissions. If in doubt, use mode 644 as your default for permissions:</p> <pre><code>$ sudo chmod 644 ./services/mosquitto/mosquitto.conf\n</code></pre> </li> <li> <p>Restart Mosquitto:</p> <pre><code>$ docker-compose restart mosquitto\n</code></pre> </li> <li> <p>Check your work:</p> <pre><code>$ ls -l ./volumes/mosquitto/config/mosquitto.conf\n-rw-r--r-- 1 1883 1883 ssss mmm dd hh:mm ./volumes/mosquitto/config/mosquitto.conf\n</code></pre> </li> <li> <p>If necessary, repeat these steps with <code>filter.acl</code>.</p> </li> </ol>"},{"location":"Containers/Mosquitto/#logging","title":"Logging","text":"<p>Mosquitto logging is controlled by <code>mosquitto.conf</code>. This is the default configuration:</p> <pre><code>#log_dest file /mosquitto/log/mosquitto.log\nlog_dest stdout\nlog_timestamp_format %Y-%m-%dT%H:%M:%S\n# Reduce size and SD-card flash wear, safe to remove if using a SSD\nconnection_messages false\n</code></pre> <p>When <code>log_dest</code> is set to   <code>stdout</code>, you inspect Mosquitto's logs like this:</p> <pre><code>$ docker logs mosquitto\n</code></pre> <p>Logs written to <code>stdout</code> are stored and persisted to disk as managed by Docker. They are kept over reboots, but are lost when your Mosquitto container is removed or updated.</p> <p>The alternative, which may be more appropriate if you are running on an SSD or HD, is to change <code>mosquitto.conf</code> to be like this:</p> <pre><code>log_dest file /mosquitto/log/mosquitto.log\n#log_dest stdout\nlog_timestamp_format %Y-%m-%dT%H:%M:%S\n</code></pre> <p>and then restart Mosquitto:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart mosquitto\n</code></pre> <p>The path <code>/mosquitto/log/mosquitto.log</code> is an internal path. When this style of logging is active, you inspect Mosquitto's logs using the external path like this:</p> <pre><code>$ sudo tail ~/IOTstack/volumes/mosquitto/log/mosquitto.log\n</code></pre> <p>You need to use <code>sudo</code> because the log is owned by userID 1883 and Mosquitto creates it without \"world\" read permission.</p> <p>Logs written to <code>mosquitto.log</code> persist until you take action to prune the file.</p>"},{"location":"Containers/Mosquitto/#security","title":"Security","text":""},{"location":"Containers/Mosquitto/#configuring-security","title":"Configuring security","text":"<p>Mosquitto security is controlled by <code>mosquitto.conf</code>. These are the relevant directives:</p> <pre><code>#password_file /mosquitto/pwfile/pwfile\nallow_anonymous true\n</code></pre> <p>Mosquitto security can be in four different states, which are summarised in the following table:</p> <code>password_file</code> <code>allow_anonymous</code> security enforcement remark disabled true open access default disabled false all access denied not really useful enabled true credentials optional enabled false credentials required"},{"location":"Containers/Mosquitto/#password-file-management","title":"Password file management","text":"<p>The password file for Mosquitto is part of a mapped volume:</p> <ul> <li>The internal path is <code>/mosquitto/pwfile/pwfile</code></li> <li>The external path is <code>~/IOTstack/volumes/mosquitto/pwfile/pwfile</code></li> </ul> <p>A common problem with the previous version of Mosquitto for IOTstack occurred when the <code>password_file</code> directive was enabled but the <code>pwfile</code> was not present. Mosquitto went into a restart loop.</p> <p>The Mosquitto container performs self-repair each time the container is brought up or restarts. If <code>pwfile</code> is missing, an empty file is created as a placeholder. This prevents the restart loop. What happens next depends on <code>allow_anonymous</code>:</p> <ul> <li> <p>If <code>true</code> then:</p> <ul> <li>Any MQTT request without credentials will be permitted;</li> <li>Any MQTT request with credentials will be rejected (because <code>pwfile</code> is empty so there is nothing to match on).</li> </ul> </li> <li> <p>If <code>false</code> then all MQTT requests will be rejected.</p> </li> </ul>"},{"location":"Containers/Mosquitto/#create-username-and-password","title":"create username and password","text":"<p>To create a username and password, use the following as a template.</p> <pre><code>$ docker exec mosquitto mosquitto_passwd -b /mosquitto/pwfile/pwfile \u00abusername\u00bb \u00abpassword\u00bb \n</code></pre> <p>Replace \u00abusername\u00bb and \u00abpassword\u00bb with appropriate values, then execute the command. For example, to create the username \"hello\" with password \"world\":</p> <pre><code>$ docker exec mosquitto mosquitto_passwd -b /mosquitto/pwfile/pwfile hello world\n</code></pre> <p>Note:</p> <ul> <li>See also customising health-check. If you are creating usernames and passwords, you may also want to create credentials for the health-check agent.</li> </ul>"},{"location":"Containers/Mosquitto/#check-password-file","title":"check password file","text":"<p>There are two ways to verify that the password file exists and has the expected content:</p> <ol> <li> <p>View the file using its external path: </p> <pre><code>$ sudo cat ~/IOTstack/volumes/mosquitto/pwfile/pwfile \n</code></pre> <p><code>sudo</code> is needed because the file is neither owned nor readable by <code>pi</code>.</p> </li> <li> <p>View the file using its internal path:</p> <pre><code>$ docker exec mosquitto cat /mosquitto/pwfile/pwfile\n</code></pre> </li> </ol> <p>Each credential starts with the username and occupies one line in the file: </p> <pre><code>hello:$7$101$ZFOHHVJLp2bcgX+h$MdHsc4rfOAhmGG+65NpIEJkxY0beNeFUyfjNAGx1ILDmI498o4cVOaD9vDmXqlGUH9g6AgHki8RPDEgjWZMkDA==\n</code></pre>"},{"location":"Containers/Mosquitto/#remove-entry-from-password-file","title":"remove entry from password file","text":"<p>To remove an entry from the password file:</p> <pre><code>$ docker exec mosquitto mosquitto_passwd -D /mosquitto/pwfile/pwfile \u00abusername\u00bb\n</code></pre>"},{"location":"Containers/Mosquitto/#reset-the-password-file","title":"reset the password file","text":"<p>There are several ways to reset the password file. Your options are:</p> <ol> <li> <p>Remove the password file and restart Mosquitto:</p> <pre><code>$ cd ~/IOTstack\n$ sudo rm ./volumes/mosquitto/pwfile/pwfile\n$ docker-compose restart mosquitto \n</code></pre> <p>The result is an empty password file.</p> </li> <li> <p>Clear all existing passwords while adding a new password:</p> <pre><code>$ docker exec mosquitto mosquitto_passwd -c -b /mosquitto/pwfile/pwfile \u00abusername\u00bb \u00abpassword\u00bb\n</code></pre> <p>The result is a password file with a single entry.</p> </li> <li> <p>Clear all existing passwords in favour of a single dummy password which is then removed:</p> <pre><code>$ docker exec mosquitto mosquitto_passwd -c -b /mosquitto/pwfile/pwfile dummy dummy\n$ docker exec mosquitto mosquitto_passwd -D /mosquitto/pwfile/pwfile dummy\n</code></pre> <p>The result is an empty password file.</p> </li> </ol>"},{"location":"Containers/Mosquitto/#activate-mosquitto-security","title":"Activate Mosquitto security","text":"<ol> <li> <p>Use <code>sudo</code> and your favourite text editor to open the following file:</p> <pre><code>~/IOTstack/volumes/mosquitto/config/mosquitto.conf\n</code></pre> </li> <li> <p>Remove the comment indicator from the following line:</p> <pre><code>#password_file /mosquitto/pwfile/pwfile\n</code></pre> <p>so that it becomes:</p> <pre><code>password_file /mosquitto/pwfile/pwfile\n</code></pre> </li> <li> <p>Set <code>allow_anonymous</code> as required:</p> <pre><code>allow_anonymous true\n</code></pre> <p>If <code>true</code> then:</p> <ul> <li>Any MQTT request without credentials will be permitted;</li> <li>The validity of credentials supplied with any MQTT request will be enforced.</li> </ul> <p>If <code>false</code> then:</p> <ul> <li>Any MQTT request without credentials will be rejected;</li> <li>The validity of credentials supplied with any MQTT request will be enforced.</li> </ul> </li> <li> <p>Save the modified configuration file and restart Mosquitto:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart mosquitto\n</code></pre> </li> </ol>"},{"location":"Containers/Mosquitto/#testing-mosquitto-security","title":"Testing Mosquitto security","text":""},{"location":"Containers/Mosquitto/#assumptions","title":"assumptions","text":"<ol> <li>You have created at least one username (\"hello\") and password (\"world\").</li> <li><code>password_file</code> is enabled.</li> <li><code>allow_anonymous</code> is <code>false</code>.</li> </ol>"},{"location":"Containers/Mosquitto/#install-testing-tools","title":"install testing tools","text":"<p>If you do not have the Mosquitto clients installed on your Raspberry Pi (ie <code>$ which mosquitto_pub</code> does not return a path), install them using:</p> <pre><code>$ sudo apt install -y mosquitto-clients\n</code></pre>"},{"location":"Containers/Mosquitto/#test-anonymous-access-is-prohibited","title":"test: anonymous access is prohibited","text":"<p>Test without providing credentials:</p> <pre><code>$ mosquitto_pub -h 127.0.0.1 -p 1883 -t \"/password/test\" -m \"up up and away\"\nConnection Refused: not authorised.\nError: The connection was refused.\n</code></pre> <p>Note:</p> <ul> <li>The error is the expected result and shows that Mosquitto will not allow anonymous access.</li> </ul>"},{"location":"Containers/Mosquitto/#test-access-with-credentials-is-permitted","title":"test: access with credentials is permitted","text":"<p>Test with credentials</p> <pre><code>$ mosquitto_pub -h 127.0.0.1 -p 1883 -t \"/password/test\" -m \"up up and away\" -u hello -P world\n$ \n</code></pre> <p>Note:</p> <ul> <li>The absence of any error message means the message was sent. Silence = success!</li> </ul>"},{"location":"Containers/Mosquitto/#test-round-trip-with-credentials-is-permitted","title":"test: round-trip with credentials is permitted","text":"<p>Prove round-trip connectivity will succeed when credentials are provided. First, set up a subscriber as a background process. This mimics the role of a process like Node-Red:</p> <pre><code>$ mosquitto_sub -v -h 127.0.0.1 -p 1883 -t \"/password/test\" -F \"%I %t %p\" -u hello -P world &amp;\n[1] 25996\n</code></pre> <p>Repeat the earlier test:</p> <pre><code>$ mosquitto_pub -h 127.0.0.1 -p 1883 -t \"/password/test\" -m \"up up and away\" -u hello -P world\n2021-02-16T14:40:51+1100 /password/test up up and away\n</code></pre> <p>Note:</p> <ul> <li>the second line above is coming from the <code>mosquitto_sub</code> running in the background.</li> </ul> <p>When you have finished testing you can kill the background process (press return twice after you enter the <code>kill</code> command):</p> <pre><code>$ kill %1\n$\n[1]+  Terminated              mosquitto_sub -v -h 127.0.0.1 -p 1883 -t \"/password/test\" -F \"%I %t %p\" -u hello -P world\n</code></pre>"},{"location":"Containers/Mosquitto/#container-health-check","title":"Container health check","text":""},{"location":"Containers/Mosquitto/#theory-of-operation","title":"theory of operation","text":"<p>A script , or \"agent\", to assess the health of the Mosquitto container has been added to the local image via the Dockerfile. In other words, the script is specific to IOTstack.</p> <p>The agent is invoked 30 seconds after the container starts, and every 30 seconds thereafter. The agent:</p> <ul> <li> <p>Publishes a retained MQTT message to the broker running in the same container. The message payload is the current date and time, and the default topic string is:</p> <pre><code>iotstack/mosquitto/healthcheck\n</code></pre> </li> <li> <p>Subscribes to the same broker for the same topic for a single message event.</p> </li> <li>Compares the payload sent with the payload received. If the payloads (ie time-stamps) match, the agent concludes that the Mosquitto broker (the process running inside the same container) is functioning properly for round-trip messaging.</li> </ul>"},{"location":"Containers/Mosquitto/#healthCheckMonitor","title":"monitoring health-check","text":"<p>Portainer's Containers display contains a Status column which shows health-check results for all containers that support the feature.</p> <p>You can also use the <code>docker ps</code> command to monitor health-check results. The following command narrows the focus to mosquitto:</p> <pre><code>$ docker ps --format \"table {{.Names}}\\t{{.Status}}\"  --filter name=mosquitto\n</code></pre> <p>Possible reply patterns are:</p> <ol> <li> <p>The container is starting and has not yet run the health-check agent:</p> <pre><code>NAMES       STATUS\nmosquitto   Up 3 seconds (health: starting)\n</code></pre> </li> <li> <p>The container has been running for at least 30 seconds and the health-check agent has returned a positive result within the last 30 seconds:</p> <pre><code>NAMES       STATUS\nmosquitto   Up 34 seconds (healthy)\n</code></pre> </li> <li> <p>The container has been running for more than 90 seconds but has failed the last three successive health-check tests:</p> <pre><code>NAMES       STATUS\nmosquitto   Up About a minute (unhealthy)\n</code></pre> </li> </ol> <p>You can also subscribe to the same topic that the health-check agent is using to view the retained messages as they are published:</p> <pre><code>$ mosquitto_sub -v -h localhost -p 1883 -t \"iotstack/mosquitto/healthcheck\" -F \"%I %t %p\"\n</code></pre> <p>Notes:</p> <ul> <li>This assumes you are running the command outside container-space on the same host as your Mosquitto container. If you run this command from another host, replace <code>localhost</code> with the IP address or domain name of the host where your Mosquitto container is running.</li> <li>The <code>-p 1883</code> is the external port. You will need to adjust this if you are using a different external port for your MQTT service.</li> <li>If you enable authentication for your Mosquitto broker, you will need to add <code>-u \u00abuser\u00bb</code> and <code>-P \u00abpassword\u00bb</code> parameters to this command.</li> <li>You should expect to see a new message appear approximately every 30 seconds. That indicates the health-check agent is functioning normally. Use control+c to terminate the command.</li> </ul>"},{"location":"Containers/Mosquitto/#healthCheckCustom","title":"customising health-check","text":"<p>You can customise the operation of the health-check agent by editing the <code>mosquitto</code> service definition in your Compose file:</p> <ol> <li> <p>By default, the mosquitto broker listens to internal port 1883. If you need change that port, you also need to inform the health-check agent via an environment variable. For example, suppose you changed the internal port to 12345:</p> <pre><code>    environment:\n      - HEALTHCHECK_PORT=12345\n</code></pre> </li> <li> <p>If the default topic string used by the health-check agent causes a name-space collision, you can override it. For example, you could use a Universally-Unique Identifier (UUID):</p> <pre><code>    environment:\n      - HEALTHCHECK_TOPIC=4DAA361F-288C-45D5-9540-F1275BDCAF02\n</code></pre> <p>Note:</p> <ul> <li>You will also need to use the same topic string in the <code>mosquitto_sub</code> command shown at monitoring health-check.</li> </ul> </li> <li> <p>If you have enabled authentication for your Mosquitto broker service, you will need to provide appropriate credentials for your health-check agent:</p> <pre><code>    environment:\n      - HEALTHCHECK_USER=healthyUser\n      - HEALTHCHECK_PASSWORD=healthyUserPassword\n</code></pre> </li> <li> <p>If the health-check agent misbehaves in your environment, or if you simply don't want it to be active, you can disable all health-checking for the container by adding the following lines to its service definition:</p> <pre><code>    healthcheck:\n      disable: true\n</code></pre> <p>Notes:</p> <ul> <li>The directives to disable health-checking are independent of the environment variables. If you want to disable health-checking temporarily, there is no need to remove any <code>HEALTHCHECK_</code> environment variables that may already be in place.</li> <li> <p>Conversely, the mere presence of a <code>healthcheck:</code> clause in the <code>mosquitto</code> service definition overrides the supplied agent. In other words, the following can't be used to re-enable the supplied agent:</p> <pre><code>    healthcheck:\n      disable: false\n</code></pre> <p>You must remove the entire <code>healthcheck:</code> clause.</p> </li> </ul> </li> </ol>"},{"location":"Containers/Mosquitto/#upgrading-mosquitto","title":"Upgrading Mosquitto","text":"<p>You can update most containers like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune\n</code></pre> <p>In words:</p> <ul> <li><code>docker-compose pull</code> downloads any newer images;</li> <li><code>docker-compose up -d</code> causes any newly-downloaded images to be instantiated as containers (replacing the old containers); and</li> <li>the <code>prune</code> gets rid of the outdated images.</li> </ul> <p>This strategy doesn't work when a Dockerfile is used to build a local image on top of a base image downloaded from DockerHub. The local image is what is running so there is no way for the <code>pull</code> to sense when a newer version becomes available.</p> <p>The only way to know when an update to Mosquitto is available is to check the eclipse-mosquitto tags page on DockerHub.</p> <p>Once a new version appears on DockerHub, you can upgrade Mosquitto like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull mosquitto\n$ docker-compose up -d mosquitto\n$ docker system prune\n$ docker system prune\n</code></pre> <p>Breaking it down into parts:</p> <ul> <li><code>build</code> causes the named container to be rebuilt;</li> <li><code>--no-cache</code> tells the Dockerfile process that it must not take any shortcuts. It really must rebuild the local image;</li> <li><code>--pull</code> tells the Dockerfile process to actually check with DockerHub to see if there is a later version of the base image and, if so, to download it before starting the build;</li> <li><code>mosquitto</code> is the named container argument required by the <code>build</code> command.</li> </ul> <p>Your existing Mosquitto container continues to run while the rebuild proceeds. Once the freshly-built local image is ready, the <code>up</code> tells <code>docker-compose</code> to do a new-for-old swap. There is barely any downtime for your MQTT broker service.</p> <p>The <code>prune</code> is the simplest way of cleaning up. The first call removes the old local image. The second call cleans up the old base image. Whether an old base image exists depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Mosquitto/#versionPinning","title":"Mosquitto version pinning","text":"<p>If an update to Mosquitto introduces a breaking change, you can revert to an earlier know-good version by pinning to that version. Here's how:</p> <ol> <li> <p>Use your favourite text editor to open:</p> <pre><code>~/IOTstack/docker-compose.yml\n</code></pre> </li> <li> <p>Find the Mosquitto service definition. If your service definition contains this line:</p> <pre><code>build: ./.templates/mosquitto/.\n</code></pre> <p>then replace that line with the following four lines:</p> <pre><code>build:\n  context: ./.templates/mosquitto/.\n  args:\n    - MOSQUITTO_BASE=eclipse-mosquitto:latest\n</code></pre> <p>Notes:</p> <ul> <li>The four-line form of the <code>build</code> directive is now the default for Mosquitto so those lines may already be present in your compose file.</li> <li>Remember to use spaces, not tabs, when editing compose files.</li> </ul> </li> <li> <p>Replace <code>latest</code> with the version you wish to pin to. For example, to pin to version 2.0.13:</p> <pre><code>    - MOSQUITTO_BASE=eclipse-mosquitto:2.0.13\n</code></pre> </li> <li> <p>Save the file and tell <code>docker-compose</code> to rebuild the local image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull mosquitto\n$ docker-compose up -d mosquitto\n$ docker system prune\n</code></pre> <p>The new local image is built, then the new container is instantiated based on that image. The <code>prune</code> deletes the old local image.</p> </li> <li> <p>Images built in this way will always be tagged with \"latest\", as in:</p> <pre><code>$ docker images iotstack_mosquitto\nREPOSITORY           TAG       IMAGE ID       CREATED              SIZE\niotstack_mosquitto   latest    8c0543149b9b   About a minute ago   16.2MB\n</code></pre> <p>You may find it useful to assign an explicit tag to help you remember the version number used for the build. For example:</p> <pre><code>$ docker tag iotstack_mosquitto:latest iotstack_mosquitto:2.0.13\n$ docker images iotstack_mosquitto\nREPOSITORY           TAG       IMAGE ID       CREATED              SIZE\niotstack_mosquitto   2.0.13    8c0543149b9b   About a minute ago   16.2MB\niotstack_mosquitto   latest    8c0543149b9b   About a minute ago   16.2MB\n</code></pre> <p>You can also query the image metadata to discover version information:</p> <pre><code>$ docker image inspect iotstack_mosquitto:latest | jq .[0].Config.Labels\n{\n  \"com.github.SensorsIot.IOTstack.Dockerfile.based-on\": \"https://github.com/eclipse/mosquitto\",\n  \"com.github.SensorsIot.IOTstack.Dockerfile.build-args\": \"eclipse-mosquitto:2.0.13\",\n  \"description\": \"Eclipse Mosquitto MQTT Broker\",\n  \"maintainer\": \"Roger Light &lt;roger@atchoo.org&gt;\"\n}\n</code></pre> </li> </ol>"},{"location":"Containers/Mosquitto/#about-port-9001","title":"About Port 9001","text":"<p>Earlier versions of the IOTstack service definition for Mosquitto included two port mappings:</p> <pre><code>ports:\n  - \"1883:1883\"\n  - \"9001:9001\"\n</code></pre> <p>Issue 67 explored the topic of port 9001 and showed that:</p> <ul> <li>The base image for Mosquitto did not expose port 9001; and</li> <li>The running container was not listening to port 9001.</li> </ul> <p>On that basis, the mapping for port 9001 was removed from <code>service.yml</code>.</p> <p>If you have a use-case that needs port 9001, you can re-enable support by:</p> <ol> <li> <p>Inserting the port mapping under the <code>mosquitto</code> definition in <code>docker-compose.yml</code>:</p> <pre><code>- \"9001:9001\"\n</code></pre> </li> <li> <p>Inserting the additional listener in <code>mosquitto.conf</code>:</p> <pre><code>listener 1883\nlistener 9001\n</code></pre> <p>You need both lines. If you omit 1883 then Mosquitto will stop listening to port 1883 and will only listen to port 9001.</p> </li> <li> <p>Restarting the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart mosquitto\n</code></pre> </li> </ol> <p>Please consider raising an issue to document your use-case. If you think your use-case has general application then please also consider creating a pull request to make the changes permanent.</p>"},{"location":"Containers/MotionEye/","title":"MotionEye","text":""},{"location":"Containers/MotionEye/#about","title":"About","text":"<p>MotionEye is a web frontend for the Motion project.</p>"},{"location":"Containers/MotionEye/#references","title":"References","text":"<ul> <li>MotionEye:<ul> <li>Wiki</li> <li>GitHub</li> <li>DockerHub</li> </ul> </li> <li>Motion project:<ul> <li>Documentation</li> <li>GitHub</li> </ul> </li> </ul>"},{"location":"Containers/MotionEye/#service-definition","title":"Service Definition","text":"<p>This is the default service definition:</p> <pre><code>motioneye:\n  image: dontobi/motioneye.rpi:latest\n  container_name: \"motioneye\"\n  restart: unless-stopped\n  ports:\n    - \"8765:8765\"\n    - \"8766:8081\"\n  environment:\n    - TZ=${TZ:-Etc/UTC}\n  volumes:\n    - ./volumes/motioneye/etc_motioneye:/etc/motioneye\n    - ./volumes/motioneye/var_lib_motioneye:/var/lib/motioneye\n</code></pre>"},{"location":"Containers/MotionEye/#administrative-interface","title":"Administrative interface","text":"<p>MotionEye's administrative interface is available on port 8765. For example:</p> <pre><code>http://raspberrypi.local:8765\n</code></pre> <p>The default username is <code>admin</code> (all lower case) with no password.</p>"},{"location":"Containers/MotionEye/#camera-streams","title":"Camera streams","text":"<p>The first camera you define in the administrative interface is assigned to internal port 8081. The default service definition maps that to port 8766:</p> <pre><code>- \"8766:8081\"\n</code></pre> <p>You can access the stream with a web browser on port 8766. For example:</p> <pre><code>http://raspberrypi.local:8766\n</code></pre> <p>Each subsequent camera you define in the administrative interface will be assigned a new internal port number:</p> <ul> <li>Camera 2 will be internal port 8082, then</li> <li>Camera 3 will be internal port 8083,</li> <li>and so on.</li> </ul> <p>Each camera you define after the first will need its own port mapping in the service definition in your compose file. For example:</p> <pre><code>- \"8767:8082\"\n- \"8768:8083\"\n- \u2026\n</code></pre> <p>Key points:</p> <ol> <li>You do not have to make camera streams available outside the container. It is optional.</li> <li>You do not have to accept the default internal port assignments of 8081, 8082 and so on. You can change internal ports in the administrative interface if you wish. If you do this, remember to update the internal (right hand side) ports in the service definition in your compose file.</li> <li>You do not have to adopt the external port sequence 8766, 8767 and so on. Port 8766 is the default for the first camera only because it does not conflict with any other IOTstack template.</li> </ol>"},{"location":"Containers/MotionEye/#clip-storage","title":"Clip Storage","text":"<p>By default local camera data is stored at the internal path:</p> <pre><code>/var/lib/motioneye/\u00abcamera_name\u00bb\n</code></pre> <p>That maps to the external path:</p> <pre><code>~/IOTstack/volumes/motioneye/var_lib_motioneye/\u00abcamera_name\u00bb\n</code></pre> <p>Tips:</p> <ul> <li>The automatic mapping to <code>\u00abcamera_name\u00bb</code> can be unreliable. After defining a camera, it is a good idea to double-check the actual path in the \"Root Directory\" field of the \"File Storage\" section in the administrative interface.</li> <li>Movie clips are kept forever by default. Depending on other settings, this can quickly run your Pi out of disk space so it's a good idea to tell MotionEye to discard old footage using the \"Preserve Movies\" field of the \"Movies\" section in the administrative interface.</li> </ul>"},{"location":"Containers/MotionEye/#backup-considerations","title":"Backup considerations","text":"<p>Although it depends on your exact settings, MotionEye's video storage can represent a significant proportion of your backup files. If you want to constrain your backup files to reasonable sizes, consider excluding the video storage from your routine backups by changing where MotionEye videos are kept. This is one approach:  </p> <ol> <li> <p>Be in the appropriate directory:</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>Terminate the motioneye container:</p> <pre><code>$ docker-compose down motioneye\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Move the video storage folder:</p> <pre><code>$ sudo mv ./volumes/motioneye/var_lib_motioneye ~/motioneye-videos\n</code></pre> </li> <li> <p>Open your <code>docker-compose.yml</code> in a text editor. Find this line in your <code>motioneye</code> service definition:</p> <pre><code>- ./volumes/motioneye/var_lib_motioneye:/var/lib/motioneye\n</code></pre> <p>and change it to be:</p> <pre><code>- /home/pi/motioneye-videos:/var/lib/motioneye\n</code></pre> <p>then save the edited compose file.</p> </li> <li> <p>Start the container again:</p> <pre><code>$ docker-compose up -d motioneye\n</code></pre> </li> </ol> <p>This change places video storage outside of the usual <code>~/IOTstack/volumes</code> path, where IOTstack backup scripts will not see it.</p> <p>An alternative approach is to omit the volume mapping for <code>/var/lib/motioneye</code> entirely. Clips will be still be recorded inside the container and you will be able to play and download the footage using the administrative interface. However, any saved clips will disappear each time the container is re-created (not just restarted). Clips stored inside the container also will not form part of any backup.</p> <p>If you choose this method, make sure you configure MotionEye to discard old footage using the \"Preserve Movies\" field of the \"Movies\" section in the administrative interface. This is a per-camera setting so remember to do it for all your cameras. If you do not do this, you are still at risk of running your Pi out of disk space, and it's a difficult problem to diagnose.</p>"},{"location":"Containers/MotionEye/#remote-motioneye","title":"Remote motioneye","text":"<p>If you have connected to a remote motion eye note that the directory is on that device and has nothing to do with the container.</p>"},{"location":"Containers/NextCloud/","title":"Nextcloud","text":""},{"location":"Containers/NextCloud/#serviceDefinition","title":"Service definition","text":"<p>This is the core of the IOTstack Nextcloud service definition:</p> <pre><code>nextcloud:\n  container_name: nextcloud\n  image: nextcloud\n  restart: unless-stopped\n  environment:\n    - TZ=${TZ:-Etc/UTC}\n    - MYSQL_HOST=nextcloud_db\n    - MYSQL_PASSWORD=%randomMySqlPassword%\n    - MYSQL_DATABASE=nextcloud\n    - MYSQL_USER=nextcloud\n  ports:\n    - \"9321:80\"\n    - \"9343:443\"\n  volumes:\n    - ./volumes/nextcloud/html:/var/www/html\n  depends_on:\n    - nextcloud_db\n  networks:\n    - default\n    - nextcloud\n\nnextcloud_db:\n  container_name: nextcloud_db\n  build: ./.templates/mariadb/.\n  restart: unless-stopped\n  environment:\n    - TZ=${TZ:-Etc/UTC}\n    - PUID=1000\n    - PGID=1000\n    - MYSQL_ROOT_PASSWORD=%randomPassword%\n    - MYSQL_PASSWORD=%randomMySqlPassword%\n    - MYSQL_DATABASE=nextcloud\n    - MYSQL_USER=nextcloud\n  volumes:\n    - ./volumes/nextcloud/db:/config\n    - ./volumes/nextcloud/db_backup:/backup\n  networks:\n    - nextcloud\n</code></pre> <p>There are two containers, one for the cloud service itself, and the other for the database. Both containers share the same persistent storage area in the volumes subdirectory so they are treated as a unit. This will not interfere with any other MariaDB containers you might wish to run.</p> <p>Key points:</p> <ul> <li>You do not need to select MariaDB in the IOTstack menu just to run NextCloud. Some tutorials suggest you do. They are wrong!</li> <li>If you choose to select MariaDB in the IOTstack menu, understand that it is a separate instance of the relational database management system. It has no relationship with NextCloud.  </li> </ul> <p>Under old-menu, you are responsible for setting passwords. The passwords are \"internal use only\" and it is unlikely that you will need them unless you plan to go ferreting-about in the database using SQL. The rules are:</p> <ul> <li>The two instances of <code>\u00abuser_password\u00bb</code> must be the same.</li> <li>The instance of <code>\u00abroot_password\u00bb</code> should be different from <code>\u00abuser_password\u00bb</code>.</li> </ul> <p>Under new-menu, the menu can generate random passwords for you. You can either use that feature or roll your own using the old-menu approach by replacing:</p> <ul> <li>Two instances of <code>%randomMySqlPassword%</code> (the <code>\u00abuser_password\u00bb</code>)</li> <li>One instance of <code>%randomPassword%</code> (the <code>\u00abroot_password\u00bb</code>)</li> </ul> <p>The passwords need to be set before you bring up the Nextcloud service for the first time. However, the following initialisation steps assume you might not have done that and always start from a clean slate.</p>"},{"location":"Containers/NextCloud/#initialisation","title":"Initialising Nextcloud","text":"<ol> <li> <p>Be in the correct directory:</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>If the stack is running, take it down:</p> <pre><code>$ docker-compose down\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Erase the persistent storage area for Nextcloud (double-check the command before you hit return):</p> <pre><code>$ sudo rm -rf ./volumes/nextcloud\n</code></pre> <p>This is done to force re-initialisation. In particular, it gives you assurance that the passwords in your <code>docker-compose.yml</code> are the ones that are actually in effect.</p> </li> <li> <p>Bring up the stack:</p> <pre><code>$ docker-compose up -d\n</code></pre> </li> <li> <p>Check for errors:</p> <p>Repeat the following command two or three times at 10-second intervals:</p> <pre><code>$ docker ps\n</code></pre> <p>You are looking for evidence that the <code>nextcloud</code> and <code>nextcloud_db</code> containers are up, stable, and not restarting. If you see any evidence of restarts, try to figure out why using:</p> <pre><code>$ docker logs nextcloud\n</code></pre> </li> <li> <p>On a computer that is not the device running Nextcloud, launch a browser and point to the device running Nextcloud using your chosen connection method. Examples:</p> <pre><code>http://192.168.203.200:9321\nhttp://myrpi.mydomain.com:9321\nhttp://myrpi.local:9321\nhttp://myrpi:9321\n</code></pre> <p>The expected result is:</p> <p></p> </li> <li> <p>Create an administrator account and then click \"Install\" and wait for the loading to complete.</p> </li> <li> <p>Eventually, the dashboard will appear. Then the dashboard will be obscured by the \"Nextcloud Hub\" floating window which you can dismiss:</p> <p></p> </li> <li> <p>Congratulations. Your IOTstack implementation of Nextcloud is ready to roll:</p> <p></p> </li> </ol>"},{"location":"Containers/NextCloud/#untrustedDomain","title":"\"Access through untrusted domain\"","text":"<p>If you are reading this because you are staring at an \"access through untrusted domain\" message then you have come to the right place.</p> <p>Let's assume the following:</p> <ul> <li>You used <code>raspi-config</code> to give your Raspberry Pi the name \"myrpi\".</li> <li>Your Raspberry Pi has the fixed IP address \"192.168.203.200\" (via either a static binding in your DHCP server or a static IP address on your Raspberry Pi).</li> </ul> <p>Out of the box, a Raspberry Pi participates in multicast DNS so it will also have the mDNS name:</p> <ul> <li>\"myrpi.local\"</li> </ul> <p>Let's also assume you have a local Domain Name System server where your Raspberry Pi:</p> <ul> <li>has the canonical name (A record) \"myrpi.mydomain.com\"; plus</li> <li>an alias (CNAME record) of \"nextcloud.mydomain.com\".</li> </ul> <p>Rolling all that together, you would expect your Nextcloud service to be reachable at any of the following URLs:</p> <ul> <li><code>http://192.168.203.200:9321</code></li> <li><code>http://myrpi.local:9321</code></li> <li><code>http://myrpi.mydomain.com:9321</code></li> <li><code>http://nextcloud.mydomain.com:9321</code></li> </ul> <p>To tell Nextcloud that all of those URLs are valid, you need to use <code>sudo</code> and your favourite text editor to edit this file:</p> <pre><code>~/IOTstack/volumes/nextcloud/html/config/config.php\n</code></pre> <p>Hint:</p> <ul> <li> <p>It is a good idea to make a backup of any file before you edit it. For example:</p> <pre><code>$ cd ~/IOTstack/volumes/nextcloud/html/config/\n$ sudo cp config.php config.php.bak\n</code></pre> </li> </ul> <p>Search for \"trusted_domains\". To tell Nextcloud to trust all of the URLs above, edit the array structure like this:</p> <pre><code>  'trusted_domains' =&gt;\n  array (\n    0 =&gt; '192.168.203.200:9321',\n    1 =&gt; 'myrpi.local:9321',\n    2 =&gt; 'myrpi.mydomain.com:9321',\n    3 =&gt; 'nextcloud.mydomain.com:9321',\n  ),\n</code></pre> <p>Note: all the trailing commas are intentional!</p> <p>Once you have finished editing the file, save your work then restart Nextcloud:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart nextcloud\n</code></pre> <p>Use <code>docker ps</code> to check that the container has restarted properly and hasn't gone into a restart loop.</p> <p>See also:</p> <ul> <li>Nextcloud documentation - trusted domains.</li> </ul>"},{"location":"Containers/NextCloud/#dnsAlias","title":"Using a DNS alias for your Nextcloud service","text":"<p>The information in this section may be out of date. Recent tests suggest it is no longer necessary to add a <code>hostname</code> clause to your <code>docker-compose.yml</code> to silence warnings when using DNS aliases to reach your NextCloud service. This section is being left here so you will know what to do if you encounter the problem.</p> <p>The examples above include using a DNS alias (a CNAME record) for your Nextcloud service. If you decide to do that, you may see this warning in the log:</p> <pre><code>Could not reliably determine the server's fully qualified domain name\n</code></pre> <p>You can silence the warning by editing the Nextcloud service definition in <code>docker-compose.yml</code> to add your fully-qualified DNS alias using a <code>hostname</code> directive. For example:</p> <pre><code>    hostname: nextcloud.mydomain.com\n</code></pre>"},{"location":"Containers/NextCloud/#security","title":"Security considerations","text":"<p>Nextcloud traffic is not encrypted. Do not expose it to the web by opening a port on your home router. Instead, use a VPN like Wireguard to provide secure access to your home network, and let your remote clients access Nextcloud over the VPN tunnel.</p> <p>The IOTstack service definition for NextCloud reserves port 9343 for HTTPS access but leaves it as an exercise for the reader to figure out how to make it work. You may get some guidance here.</p>"},{"location":"Containers/NextCloud/#healthCheck","title":"Container health check","text":"<p>A script , or \"agent\", to assess the health of the MariaDB container has been added to the local image via the Dockerfile. In other words, the script is specific to IOTstack.</p> <p>Because it is an instance of MariaDB, Nextcloud_DB inherits the health-check agent. See the IOTstack MariaDB documentation for more information.</p>"},{"location":"Containers/NextCloud/#updatingNextcloud","title":"Keeping Nextcloud up-to-date","text":"<p>To update the <code>nextcloud</code> container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull nextcloud\n$ docker-compose up -d nextcloud\n$ docker system prune\n</code></pre> <p>To update the <code>nextcloud_db</code> container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull nextcloud_db\n$ docker-compose up -d nextcloud_db\n$ docker system prune\n</code></pre> <p>You may need to run the <code>prune</code> command twice if you are using a 1.x version of <code>docker-compose</code>.</p>"},{"location":"Containers/NextCloud/#backups","title":"Backups","text":"<p>Nextcloud is currently excluded from the IOTstack-supplied backup scripts due to its potential size.</p> <p>Paraphraser/IOTstackBackup includes backup and restore for NextCloud.</p> <p>If you want to take a backup, something like the following will get the job done:</p> <pre><code>$ cd ~/IOTstack\n$ BACKUP_TAR_GZ=$PWD/backups/$(date +\"%Y-%m-%d_%H%M\").$HOSTNAME.nextcloud-backup.tar.gz\n$ touch \"$BACKUP_TAR_GZ\"\n$ docker-compose down nextcloud nextcloud_db\n$ sudo tar -czf \"$BACKUP_TAR_GZ\" -C \"./volumes/nextcloud\" .\n$ docker-compose up -d nextcloud\n</code></pre> <p>Notes:</p> <ul> <li>A baseline backup takes over 400MB and about 2 minutes. Once you start adding your own data, it will take even more time and storage.</li> <li>The <code>up</code> of the NextCloud container implies the <code>up</code> of the Nextcloud_DB container.</li> <li>See also if downing a container doesn't work</li> </ul> <p>To restore, you first need to identify the name of the backup file by looking in the <code>backups</code> directory. Then:</p> <pre><code>$ cd ~/IOTstack\n$ RESTORE_TAR_GZ=$PWD/backups/2021-06-12_1321.sec-dev.nextcloud-backup.tar.gz\n$ docker-compose down nextcloud nextcloud_db\n$ sudo rm -rf ./volumes/nextcloud/*\n$ sudo tar -x --same-owner -z -f \"$RESTORE_TAR_GZ\" -C \"./volumes/nextcloud\"\n$ docker-compose up -d nextcloud\n</code></pre> <p>If you are running from an SD card, it would be a good idea to mount an external drive to store the data. Something like:</p> <p></p> <p>The external drive will have to be an ext4 formatted drive because smb, fat32 and NTFS can't handle Linux file permissions. If the permissions aren't set to \"www-data\" then the container won't be able to write to the disk.</p> <p>Finally, a warning:</p> <ul> <li>If your database gets corrupted then your Nextcloud is pretty much stuffed.</li> </ul>"},{"location":"Containers/NextCloud/#networkModel","title":"Network Model","text":"<p>A walkthrough of a network model may help you to understand how Nextcloud and its database communicate. To help set the scene, the following model shows a Raspberry Pi with Docker running four containers:</p> <ul> <li><code>nextcloud</code> and <code>nextcloud_db</code> - both added when you select \"NextCloud\"</li> <li><code>mariadb</code> - optional container added when you select \"MariaDB\"</li> <li><code>wireguard</code> - optional container added when you select \"WireGuard\"</li> </ul> <p></p> <p>The first thing to understand is that the <code>nextcloud_db</code> and <code>mariadb</code> containers are both instances of MariaDB. They are instantiated from the same image but they have completely separate existences. They have different persistent storage areas (ie databases) and they do not share data.</p> <p>The second thing to understand is how the networks inside the \"Docker\" rectangle shown in the model are created. The <code>networks</code> section of your compose file defines the networks:</p> <pre><code>networks:\n\n  default:\n    driver: bridge\n    ipam:\n      driver: default\n\n  nextcloud:\n    driver: bridge\n    internal: true\n    ipam:\n      driver: default\n</code></pre> <p>At run time, the lower-case representation of the directory containing the compose file (ie \"iotstack\") is prepended to the network names, resulting in:</p> <ul> <li><code>default</code> \u27f9 <code>iotstack_default</code></li> <li><code>nextcloud</code> \u27f9 <code>iotstack_nextcloud</code></li> </ul> <p>Each network is assigned a /16 IPv4 subnet. Unless you override it, the subnet ranges are chosen at random. This model assumes:</p> <ul> <li><code>iotstack_default</code> is assigned 172.18.0.0/16</li> <li><code>iotstack_nextcloud</code> is assigned 172.19.0.0/16</li> </ul> <p>The logical router on each network takes the <code>.0.1</code> address.</p> <p>The reason why two octets are devoted to the host address is because a /16 network prefix implies a 16-bit host portion. Each octet describes 8 bits.</p> <p>As each container is brought up, the network(s) it joins are governed by the following rules:</p> <ol> <li>If there is an explicit <code>networks:</code> clause in the container's service definition then the container joins the network(s) listed in the body of the clause; otherwise</li> <li>The container joins the <code>default</code> network.</li> </ol> <p>Assuming that the <code>mariadb</code> and <code>wireguard</code> containers do not have <code>networks:</code> clauses, the result of applying those rules is shown in the following table.</p> <p></p> <p>Each container is assigned an IPv4 address on each network it joins. In general, the addresses are assigned in the order in which the containers start.</p> <p>No container can easily predict either the network prefix of the networks it joins or the IP address of any other container. However, Docker provides a mechanism for any container to reach any other container with which it shares a network by using the destination container's name.</p> <p>In this model there are two MariaDB instances, one named <code>nextcloud_db</code> and the other named <code>mariadb</code>. How does the <code>nextcloud</code> container know which name to use? Simple. It's passed in an environment variable:</p> <pre><code>environment:\n  - MYSQL_HOST=nextcloud_db\n</code></pre> <p>At runtime, the <code>nextcloud</code> container references <code>nextcloud_db:3306</code>. Docker resolves <code>nextcloud_db</code> to 172.19.0.2 so the traffic traverses the 172.19/16 internal bridged network and arrives at the <code>nextcloud_db</code> container.</p> <p>The <code>nextcloud</code> container could reach the <code>mariadb</code> container via <code>mariadb:3306</code>. There's no ambiguity because Docker resolves <code>mariadb</code> to 172.18.0.2, which is a different subnet and an entirely different internal bridged network. </p> <p>There would still be no ambiguity even if all containers attached to the <code>iotstack_default</code> network because each container name still resolves to a distinct IP address.</p> <p>In terms of external ports, only <code>mariadb</code> exposes port 3306. Any external process trying to reach 192.168.203.60:3306 will always be port-forwarded to the <code>mariadb</code> container. The <code>iotstack_nextcloud</code> network is declared \"internal\" which means it is unreachable from beyond the Raspberry Pi. Any port-mappings associated with that network are ignored.</p>"},{"location":"Containers/Node-RED/","title":"Node-RED","text":""},{"location":"Containers/Node-RED/#references","title":"References","text":"<ul> <li>nodered.org home</li> <li>GitHub: node-red/node-red-docker</li> <li>DockerHub: nodered/node-red</li> <li>Tutorial: from MQTT to InfluxDB via Node-Red</li> </ul>"},{"location":"Containers/Node-RED/#significant-files","title":"Significant files","text":"<pre><code>~/IOTstack\n\u251c\u2500\u2500 .templates\n\u2502   \u2514\u2500\u2500 nodered\n\u2502       \u2514\u2500\u2500 service.yml \u2776\n\u251c\u2500\u2500 services\n\u2502   \u2514\u2500\u2500 nodered\n\u2502       \u251c\u2500\u2500 Dockerfile \u2777\n\u2502       \u2514\u2500\u2500 service.yml \u2778\n\u251c\u2500\u2500 docker-compose.yml \u2779\n\u2514\u2500\u2500 volumes\n    \u2514\u2500\u2500 nodered \u277a\n        \u251c\u2500\u2500 data \u277b\n        \u2514\u2500\u2500 ssh \u277c\n</code></pre> <ol> <li>Template service definition.</li> <li>The Dockerfile.</li> <li>Working service definition (old-menu only, copied from \u2776).</li> <li>The Compose file (includes \u2776)</li> <li>Persistent storage area.</li> <li>Data directory (mapped volume).</li> <li>SSH directory (mapped volume).</li> </ol>"},{"location":"Containers/Node-RED/#iotstackBuild","title":"How Node-RED gets built for IOTstack","text":""},{"location":"Containers/Node-RED/#gitHubSource","title":"Node-RED source code (GitHub)","text":"<p>The source code for Node-RED lives at GitHub node-red/node-red-docker.</p>"},{"location":"Containers/Node-RED/#dockerHubImages","title":"Node-RED images (DockerHub)","text":"<p>Periodically, the source code is recompiled and pushed to nodered/node-red on DockerHub. See Node-RED and <code>node.js</code> versions for an explanation of the versioning tags associated with images on DockerHub.</p>"},{"location":"Containers/Node-RED/#iotstackMenu","title":"IOTstack menu","text":"<p>When you select Node-RED in the IOTstack menu, the template service definition \u2776 is copied into the Compose file \u2779.</p> <p>Under old menu, it is also copied to the working service definition \u2778 and then not really used.</p> <p>You choose add-on nodes from a supplementary menu. We recommend accepting the default nodes, and adding others that you think you are likely to need. Node-RED will not build if you do not select at least one add-on node.</p> <p>Key points: </p> <ul> <li>Under new menu, you must press the right arrow to access the supplementary menu. Under old menu, the list of add-on nodes is displayed automatically. </li> <li>Do not be concerned if you can't find an add-on node you need in the list. You can also add nodes via Manage Palette once Node-RED is running. See component management.</li> </ul> <p>Choosing add-on nodes in the menu causes the Dockerfile \u2777 to be created.</p>"},{"location":"Containers/Node-RED/#iotstackFirstRun","title":"IOTstack first run","text":"<p>On a first install of IOTstack, you are told to do this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p><code>docker-compose</code> reads the Compose file \u2779. When it arrives at the <code>nodered</code> service definition, it finds : <pre><code>  nodered:\n    container_name: nodered\n    build:\n      context: ./services/nodered/.\n      args:\n      - DOCKERHUB_TAG=latest\n      - EXTRA_PACKAGES=\n</code></pre> <p>Note:</p> <ul> <li> <p>Prior to July 2022, IOTstack used the following one-line syntax for the <code>build</code> directive:</p> <pre><code>    build: ./services/nodered/.\n</code></pre> <p>The older syntax meant all local customisations (version-pinning and adding extra packages) needed manual edits to the Dockerfile \u2777. Those edits would be overwritten each time the menu was re-run to alter the selected add-on nodes. The newer multi-line syntax avoids that problem.</p> <p>See also updating to July 2022 syntax.</p> </li> </ul> <p>In either case, the path <code>./services/nodered/.</code> tells <code>docker-compose</code> to look for \u2777:</p> <pre><code>~/IOTstack/services/nodered/Dockerfile\n</code></pre> <p>which contains instructions to download a base image from DockerHub and then apply local customisations such as the add-on nodes you chose in the IOTstack menu. The result is a local image which is instantiated to become your running container.</p> <p>Notes:</p> <ol> <li>During the build you may see warnings and deprecation notices. You may also see messages about \"vulnerabilities\" along with recommendations to run <code>npm audit fix</code>. You should ignore all such messages. There is no need to take any action.</li> <li> <p>If SQLite is in your list of nodes, be aware that it needs to be compiled from its source code. It takes a long time, outputs an astonishing number of warnings and, from time to time, will look as if it has gotten stuck. Be patient.</p> <p>Acknowledgement: Successful installation of the SQLite node is thanks to @fragolinux.</p> </li> </ol> <p>When you run the <code>docker images</code> command after Node-RED has been built, you will see something like this:</p> <pre><code>$ docker images\nREPOSITORY               TAG       IMAGE ID       CREATED        SIZE\niotstack-nodered         latest    9feeb87019cd   11 days ago    945MB\n</code></pre> <p>The image name <code>iotstack-nodered</code> is the concatenation of two components:</p> <ol> <li>The <code>docker-compose</code> project name. This is the all-lower-case representation of the name of the folder containing <code>docker-compose.yml</code>. In a default clone of IOTstack, the folder name is <code>IOTstack</code> so the project name is <code>iotstack</code>.</li> <li>The name of the service definition which, for Node-RED is <code>nodered</code>.</li> </ol> <p>When you install Node-RED for the first time, the entire process of downloading a base image from Dockerhub, building a local image by running your local Dockerfile \u2777, and then instantiating that local image as your running container, is all completely automatic.</p> <p>However, after that first build, your local image is essentially frozen and it needs special action on your part to keep it up-to-date. See maintaining Node-RED and, in particular:</p> <ul> <li>Re-building the local image if you change the Dockerfile; and</li> <li>Upgrading Node-RED if you want to reconstruct your local image based on an updated base image which has become available on DockerHub.</li> </ul>"},{"location":"Containers/Node-RED/#securingNodeRed","title":"Securing Node-RED","text":""},{"location":"Containers/Node-RED/#encryptionKey","title":"Setting an encryption key for your credentials","text":"<p>After you install Node-RED, you should set an encryption key. Completing this step will silence the warning you will see when you run:</p> <pre><code>$ docker logs nodered\n\u2026\n---------------------------------------------------------------------\nYour flow credentials file is encrypted using a system-generated key.\n\nIf the system-generated key is lost for any reason, your credentials\nfile will not be recoverable, you will have to delete it and re-enter\nyour credentials.\n\nYou should set your own key using the 'credentialSecret' option in\nyour settings file. Node-RED will then re-encrypt your credentials\nfile using your chosen key the next time you deploy a change.\n---------------------------------------------------------------------\n\u2026\n</code></pre> <p>Setting an encryption key also means that any credentials you create will be portable, in the sense that you can backup Node-RED on one machine and restore it on another.</p> <p>The encryption key can be any string. For example, if you have UUID support installed (<code>sudo apt install -y uuid-runtime</code>), you could generate a UUID as your key:</p> <pre><code>$ uuidgen\n2deb50d4-38f5-4ab3-a97e-d59741802e2d\n</code></pre> <p>Once you have defined your encryption key, use <code>sudo</code> and your favourite text editor to open this file:</p> <pre><code>~/IOTstack/volumes/nodered/data/settings.js\n</code></pre> <p>Search for <code>credentialSecret</code>:</p> <pre><code>    //credentialSecret: \"a-secret-key\",\n</code></pre> <p>Un-comment the line and replace <code>a-secret-key</code> with your chosen key. Do not remove the comma at the end of the line. The result should look something like this:</p> <pre><code>    credentialSecret: \"2deb50d4-38f5-4ab3-a97e-d59741802e2d\",\n</code></pre> <p>Save the file and then restart Node-RED:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart nodered\n</code></pre>"},{"location":"Containers/Node-RED/#credentials","title":"Setting a username and password for Node-RED","text":"<p>To secure Node-RED you need a password hash. Run the following command, replacing <code>PASSWORD</code> with your own password:</p> <pre><code>$ docker exec nodered node -e \"console.log(require('bcryptjs').hashSync(process.argv[1], 8));\" PASSWORD\n</code></pre> <p>You will get an answer that looks something like this:</p> <pre><code>$2a$08$gTdx7SkckJVCw1U98o4r0O7b8P.gd5/LAPlZI6geg5LRg4AUKuDhS\n</code></pre> <p>Copy that text to your clipboard, then follow the instructions at Node-RED User Guide - Securing Node-RED - Username &amp; Password-based authentication.</p>"},{"location":"Containers/Node-RED/#containerNames","title":"Referring to other containers","text":"<p>Node-RED can run in two modes. By default, it runs in \"non-host mode\" but you can also move the container to \"host mode\" by editing the Node-RED service definition in your Compose file to:</p> <ol> <li> <p>Add the following directive:</p> <pre><code>network_mode: host\n</code></pre> </li> <li> <p>Remove the <code>ports</code> directive and the mapping of port 1880.</p> </li> </ol>"},{"location":"Containers/Node-RED/#nonHostMode","title":"When Node-RED is not in host mode","text":"<p>Most examples on the web assume Node-RED and other services in the MING (Mosquitto, InfluxDB, Node-RED, Grafana) stack have been installed natively, rather than in Docker containers. Those examples typically include the loopback address + port syntax, like this:</p> <pre><code>127.0.0.1:1883\n</code></pre> <p>The loopback address will not work when Node-RED is in non-host mode. This is because each container behaves like a self-contained computer. The loopback address means \"this container\". It does not mean \"this Raspberry Pi\".</p> <p>You refer to other containers by their container name. For example, a flow subscribing to an MQTT feed provided by the mosquitto container uses:</p> <pre><code>mosquitto:1883\n</code></pre> <p>Similarly, if a flow writes to an InfluxDB database maintained by the influxdb container, the flow uses:</p> <pre><code>influxdb:8086\n</code></pre> <p>Behind the scenes, Docker maintains a table, similar to an <code>/etc/hosts</code> file, mapping container names to the IP addresses on the internal bridged network that are assigned, dynamically, by Docker, when it spins up each container.</p>"},{"location":"Containers/Node-RED/#hostmode","title":"When Node-RED is in host mode","text":"<p>This is where you use loopback+port syntax, such as the following to communicate with Mosquitto:</p> <pre><code>127.0.0.1:1883\n</code></pre> <p>What actually occurs is that Docker is listening to external port 1883 on behalf of Mosquitto. It receives the packet and routes it (layer three) to the internal bridged network, performing network address translation (NAT) along the way to map the external port to the internal port. Then the packet is delivered to Mosquitto. The reverse happens when Mosquitto replies. It works but is less efficient than when all containers are in non-host mode. </p>"},{"location":"Containers/Node-RED/#hostReference","title":"Referring to the host","text":"<p>When the container is running in non-host mode, there are several ways in which it can refer to the host on which the container is running:</p> <ol> <li>via the IP address of one of the host's interfaces;</li> <li>via the fully-qualified domain name of the host (ie same as the above but via the Domain Name System)</li> <li>via the default gateway on the Docker bridge network.</li> </ol> <p>The problem with the first two is that they tie your flows to the specific host.</p> <p>The third method is portable, meaning a flow can conceptually refer to \"this\" host and be independent of the actual host on which the container is running.</p>"},{"location":"Containers/Node-RED/#defaultBridge","title":"Bridge network - default gateway","text":"<ul> <li> <p>Method 1</p> <p>The default gateway on the Docker bridge network is usually \"172.17.0.1\". You can confirm the IP address by running:</p> <pre><code>$ docker network inspect bridge | jq .[0].IPAM.Config[0].Gateway\n\"172.17.0.1\"\n</code></pre> <p>If <code>jq</code> is not installed on your system, you can install it by running <code>sudo apt install -y jq</code>.</p> <p>If you use this method, your flows can refer to \"this\" host using the IP address \"172.17.0.1\".</p> </li> <li> <p>Method 2</p> <p>Alternatively, you can add the following lines to your Node-RED service definition:</p> <pre><code>extra_hosts:\n  - \"host.docker.internal:host-gateway\"\n</code></pre> <p>If you use this method, your flows can refer to \"this\" host using the domain name \"host.docker.internal\".</p> <p>Generally the second method is recommended for IOTstack. That is because your flows will continue to work even if the 172.17.0.1 IP address changes. However, it does come with the disadvantage that, if you publish a flow containing this domain name, the flow will not work unless the recipient also adds the <code>extra_hosts</code> clause.</p> </li> </ul>"},{"location":"Containers/Node-RED/#accessGPIO","title":"GPIO Access","text":"<p>To communicate with your Raspberry Pi's GPIO you need to do the following:</p> <ol> <li> <p>Install dependencies:</p> <pre><code>$ sudo apt update\n$ sudo apt install pigpio python-pigpio python3-pigpio\n</code></pre> <p>Notes:</p> <ul> <li><code>pigpio</code> and <code>python3-pigpio</code> are usually installed by default in standard releases of Raspberry Pi OS.</li> <li>Only <code>pigpio</code> is actually required.</li> <li>The Python packages are optional.</li> </ul> </li> <li> <p>Install the <code>node-red-node-pi-gpiod</code> node. See component management. It allows you to connect to multiple Pis from the same Node-RED service.</p> <p>Note:</p> <ul> <li>Unless you explicitly removed <code>node-red-node-pi-gpiod</code> from the list of add-on nodes added to your Dockerfile by the IOTstack menu, it will be installed already. You can confirm this by examining your Node-RED Dockerfile\u00a0\u2777.</li> </ul> </li> <li> <p>Configure the <code>pigpdiod</code> daemon:</p> <ul> <li> <p>copy the following text to the clipboard:</p> <pre><code>[Unit]\nRequires=default.target\nAfter=default.target\n[Service]\nExecStart=\nExecStart=/usr/bin/pigpiod\n[Install]\nWantedBy=\nWantedBy=default.target\n</code></pre> <p>Acknowledgement: some of the above from joan2937/pigpio issue 554</p> </li> <li> <p>execute the following commands:</p> <pre><code>$ sudo systemctl stop pigpiod\n$ sudo systemctl revert pigpiod\n$ sudo systemctl edit pigpiod\n</code></pre> </li> <li> <p>follow the on-screen instructions and paste the contents of the clipboard into the blank area between the lines. The final result should be (lines 4\u202612 are the pasted material):</p> <pre><code>### Editing /etc/systemd/system/pigpiod.service.d/override.conf\n### Anything between here and the comment below will become the new contents of the file\n\n[Unit]\nRequires=default.target\nAfter=default.target\n[Service]\nExecStart=\nExecStart=/usr/bin/pigpiod\n[Install]\nWantedBy=\nWantedBy=default.target\n\n### Lines below this comment will be discarded\n\n### /lib/systemd/system/pigpiod.service\n# [Unit]\n# Description=Daemon required to control GPIO pins via pigpio\n# [Service]\n# ExecStart=/usr/bin/pigpiod -l\n# ExecStop=/bin/systemctl kill pigpiod\n# Type=forking\n# [Install]\n# WantedBy=multi-user.target\n</code></pre> </li> <li> <p>Save your work by pressing:</p> <ul> <li>control+O (letter O not zero)</li> <li>return</li> <li>control+X</li> </ul> </li> <li> <p>Check your work by running:</p> <pre><code>$ sudo systemctl cat pigpiod\n</code></pre> <p>The expected result is:</p> <pre><code># /lib/systemd/system/pigpiod.service\n[Unit]\nDescription=Daemon required to control GPIO pins via pigpio\n[Service]\nExecStart=/usr/bin/pigpiod -l\nExecStop=/bin/systemctl kill pigpiod\nType=forking\n[Install]\nWantedBy=multi-user.target\n\n# /etc/systemd/system/pigpiod.service.d/override.conf\n[Unit]\nRequires=default.target\nAfter=default.target\n[Service]\nExecStart=\nExecStart=/usr/bin/pigpiod\n[Install]\nWantedBy=\nWantedBy=default.target\n</code></pre> <p>Lines 12\u202620 should be those you copied to the clipboard at the start of this step. If you do not see the expected result, go back and start from the beginning of this step.</p> </li> <li> <p>Activate the daemon:</p> <pre><code>$ sudo systemctl enable pigpiod\n$ sudo systemctl start pigpiod\n</code></pre> </li> <li> <p>Reboot.</p> </li> <li> <p>Check that the daemon is running:</p> <pre><code>$ sudo systemctl status pigpiod\n</code></pre> <p>Once you have configured <code>pigpiod</code> correctly and it has come up after a reboot, you should not need to worry about it again.</p> <p><code>pigpiod</code> provides open access to your Raspberry Pi's GPIO via port 8888. Consult the <code>man</code> pages if you want to make it more secure. Once you have decided what to do, start over from the beginning of this step, and add your parameters to the line:</p> <pre><code>ExecStart=/usr/bin/pigpiod\n</code></pre> </li> </ul> </li> <li> <p>Drag a <code>pi gpio</code> node onto the canvas. Configure it according to your needs.</p> <p>The <code>Host</code> field should be set to one of:</p> <ul> <li><code>172.17.0.1</code>; or</li> <li><code>host.docker.internal</code></li> </ul> <p>See also Bridge network - default gateway.</p> <p>Don't try to use 127.0.0.1 because that is the loopback address of the Node-RED container.</p> </li> </ol>"},{"location":"Containers/Node-RED/#accessSerial","title":"Serial Devices","text":""},{"location":"Containers/Node-RED/#usbSerial","title":"USB devices","text":"<p>Node-RED running in a container can communicate with serial devices attached to your Raspberry Pi's USB ports. However, it does not work \"out of the box\". You need to set it up.</p> <p>Let's make an assumption. A device connected to one of your Raspberry Pi's USB ports presents itself as:</p> <pre><code>/dev/ttyUSB0\n</code></pre> <p>You have three basic options:</p> <ol> <li> <p>You can map the device into the container using that name:</p> <pre><code>devices:\n  - \"/dev/ttyUSB0:/dev/ttyUSB0\"\n</code></pre> <p>This is simple and effective but it suffers from a few problems:</p> <ul> <li>If the device is disconnected while the container is running, there's a good chance the container will crash.</li> <li><code>docker-compose</code> will not start your container if the device is not present when you bring up your stack.</li> <li>You can't guarantee that the device will always enumerate as \"ttyUSB0\". It might come up as \"ttyUSB1\".</li> </ul> <p>You can deal with the last problem by using the device's \"by-id\" path. There's an example of this in the Zigbee2MQTT documentation.</p> <p>Options 2 and 3 (below) deal with the first two problems in the sense that:</p> <ul> <li>a device disconnection is unlikely to cause the container to crash (the flow might);</li> <li><code>docker-compose</code> will always start the container, irrespective of whether devices are actually attached to your USB ports.</li> </ul> <p>Options 2 and 3 (below) can't provide a workaround for devices being given different names via enumeration but you can still deal with that by using the device's \"by-id\" path (as explained above).</p> </li> <li> <p>You can map a class of devices:</p> <ul> <li> <p>modify the <code>volumes</code> clause to add a read-only mapping for <code>/dev</code>:</p> <pre><code>volumes:\n  - /dev:/dev:ro\n</code></pre> <p>The \"read-only\" flag (<code>:ro</code>) prevents the container from doing dangerous things like destroying your Raspberry Pi's SD or SSD. Please don't omit that flag!</p> </li> <li> <p>discover the major number for your device:</p> <pre><code>$ ls -l /dev/ttyUSB0\ncrw-rw---- 1 root dialout 188, 0 Feb 18 15:30 /dev/ttyUSB0\n</code></pre> <p>In the above, the <code>188, 0</code> string means the major number for ttyUSB0 is \"188\" and \"0\" the minor number.</p> </li> <li> <p>add two device CGroup rules:</p> <pre><code>device_cgroup_rules:\n  - 'c 1:* rw' # access to devices like /dev/null\n  - 'c 188:* rmw' # change numbers to your device\n</code></pre> <p>In the above:</p> <ul> <li> <p>\"188\" is the major number for ttyUSB0 and you should substitute accordingly if your device has a different major number.</p> </li> <li> <p>the \"*\" is a wildcard for the minor number.</p> </li> </ul> </li> </ul> </li> <li> <p>Use the \"privileged\" flag by adding the following to your Node-RED service definition:</p> <pre><code>privileged: true\n</code></pre> <p>Please make sure you read the following references BEFORE you select this option:</p> <ul> <li>Privileged vs root</li> <li>Mind the 'privileged' flag</li> </ul> </li> </ol>"},{"location":"Containers/Node-RED/#nodeSerial","title":"node-red-node-serialport","text":"<p>At the time of writing (Feb 2023), it was not possible to add <code>node-red-node-serialport</code> to the list of nodes in your Dockerfile. Attempting to do so crashed the Node-RED container with a segmentation fault. The workaround is to build the node from source by adding an extra line at the end of your Dockerfile: </p> <pre><code>RUN npm install node-red-node-serialport --build-from-source\n</code></pre>"},{"location":"Containers/Node-RED/#piSerial","title":"hardware serial port","text":"<p>Historically, <code>/dev/ttyAMA0</code> referred to the Raspberry Pi's serial port. The situation became less straightforward once Pis gained Bluetooth capabilities:</p> <ul> <li> <p>On Pis without Bluetooth hardware:</p> <ul> <li><code>/dev/ttyAMA0</code> means the serial port; and</li> <li><code>/dev/serial0</code> is a symlink to <code>/dev/ttyAMA0</code></li> </ul> </li> <li> <p>On Pis with Bluetooth capabilities:</p> <ul> <li><code>/dev/ttyS0</code> means the serial port; and</li> <li><code>/dev/serial0</code> is a symlink to <code>/dev/ttyS0</code></li> </ul> <p>In addition, whether <code>/dev/ttyS0</code> (and, therefore, <code>/dev/serial0</code>) are present at runtime depends on adding the following line to <code>config.txt</code>:</p> <pre><code>enable_uart=1\n</code></pre> <p>And, if that isn't sufficiently confusing, the location of <code>config.txt</code> depends on the OS version:</p> <ul> <li>Bullseye (and earlier): <code>/boot/config.txt</code></li> <li>Bookworm: <code>/boot/firmware/config.txt</code></li> </ul> </li> </ul> <p>Rolling all that together, if you want access to the hardware serial port from Node-RED, you need to:</p> <ol> <li>Add <code>enable_uart=1</code> to <code>config.txt</code>.</li> <li>Reboot.</li> <li> <p>Add a device-mapping to Node-RED's service definition:</p> <pre><code>devices:\n  - /dev/serial0:/dev/\u00abinternalDevice\u00bb\n</code></pre> <p>where <code>\u00abinternalDevice\u00bb</code> is whatever device the add-on node you're using is expecting, such as <code>ttyAMA0</code>.</p> </li> <li> <p>Recreate the Node-RED container by running:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d nodered\n</code></pre> </li> </ol>"},{"location":"Containers/Node-RED/#bluetoothSupport","title":"Bluetooth device","text":"<p>If you enable the <code>node-red-contrib-generic-ble</code> add on node, you will also need to make the following changes:</p> <ol> <li> <p>If you are running Bookworm, you will need to use <code>sudo</code> to edit this file:</p> <pre><code>/boot/firmware/config.txt\n</code></pre> <p>You need to add this line to the end of the file:</p> <pre><code>dtparam=krnbt=off\n</code></pre> <p>You then need to reboot. This adds the Bluetooth device to <code>/dev</code>.</p> </li> <li> <p>Find the the Node-RED service definition in your <code>docker-compose.yml</code>:</p> <ul> <li> <p>Add the following mapping to the <code>volumes:</code> clause:</p> <pre><code>- /var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket\n</code></pre> </li> <li> <p>Add the following <code>devices:</code> clause:</p> <pre><code>devices:\n  - \"/dev/serial1:/dev/serial1\"\n  - \"/dev/vcio:/dev/vcio\"\n  - \"/dev/gpiomem:/dev/gpiomem\"\n</code></pre> </li> </ul> </li> <li> <p>Recreate the Node-RED container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d nodered\n</code></pre> </li> </ol> <p>Notes:</p> <ul> <li>These changes are specific to the Raspberry Pi. If you need Bluetooth support on non-Pi hardware, you will need to figure out the details for your chosen platform.</li> <li> <p>Historically, <code>/dev/ttyAMA0</code> meant the serial interface. Subsequently, it came to mean the Bluetooth interface but only where Bluetooth hardware was present, otherwise it still meant the serial interface.</p> <p>On Bookworm and later, if it is present, <code>/dev/ttyAMA1</code> means the Bluetooth Interface.</p> <p>On Bullseye and later, <code>/dev/serial1</code> is a symbolic link pointing to whichever of <code>/dev/ttyAMA0</code> or <code>/dev/ttyAMA1</code> means the Bluetooth interface. This means that <code>/dev/serial1</code> is the most reliable way of referring to the Bluetooth Interface. That's why it appears in the <code>devices:</code> clause above.</p> </li> </ul>"},{"location":"Containers/Node-RED/#fileSharing","title":"Sharing files between Node-RED and the Raspberry Pi","text":"<p>Containers run in a sandboxed environment. A process running inside a container can't see the Raspberry Pi's file system. Neither can a process running outside a container access files inside the container.</p> <p>This presents a problem if you want write to a file outside a container, then read from it inside the container, or vice-versa.</p> <p>IOTstack containers have been set up with shared volume mappings. Each volume mapping associates a specific directory in the Raspberry Pi file system with a specific directory inside the container. If you write to files in a shared directory (or one of its sub-directories), both the host and the container can see the same sub-directories and files.</p> <p>Key point:</p> <ul> <li>Files and directories in the shared volume are persistent between restarts. If you save your data anywhere else inside the container, it will be lost when the container is rebuilt.</li> </ul> <p>The Node-RED service definition in the Compose file includes the following:</p> <pre><code>volumes:\n  - ./volumes/nodered/data:/data\n</code></pre> <p>That decomposes into:</p> <ul> <li>external path = <code>./volumes/nodered/data</code></li> <li>internal path = <code>/data</code></li> </ul> <p>The leading \".\" on the external path implies \"the folder containing the Compose file so it actually means:</p> <ul> <li>external path = <code>~/IOTstack/volumes/nodered/data</code></li> <li>internal path = <code>/data</code></li> </ul> <p>If you write to the internal path from inside the Node-RED container, the Raspberry Pi will see the results at the external path, and vice versa. Example:</p> <pre><code>$ docker exec -it nodered bash\n# echo \"The time now is $(date)\" &gt;/data/example.txt\n# cat /data/example.txt \nThe time now is Thu Apr  1 11:25:56 AEDT 2021\n# exit\n$ cat ~/IOTstack/volumes/nodered/data/example.txt \nThe time now is Thu Apr  1 11:25:56 AEDT 2021\n$ sudo rm ~/IOTstack/volumes/nodered/data/example.txt\n</code></pre> <p>In words:</p> <ol> <li> <p>Open a shell into the Node-RED container. Two things happen:</p> <ul> <li>You are now inside the container. Any commands you execute while in this shell are run inside the container; and</li> <li>The prompt changes to a \"#\" indicating that you are running as the \"root\" user, meaning you don't need <code>sudo</code> for anything.</li> </ul> </li> <li> <p>Use the <code>echo</code> command to create a small file which embeds the current timestamp. The path is in the <code>/data</code> directory which is mapped to the Raspberry Pi's file system.</p> </li> <li>Show that the file has been created inside the container.</li> <li>Exit the shell:<ul> <li>You can either type the <code>exit</code> command and press return, or press Control+D.</li> <li>Exiting the shell drops you out of the container so the \"$\" prompt returns, indicating that you are outside the Node-Red container, running as a non-root user (\"pi\").</li> </ul> </li> <li>Show that the same file can be seen from outside the container.</li> <li>Tidy-up by removing the file. You need <code>sudo</code> to do that because the persistent storage area at the external path is owned by root, and you are running as user \"pi\".</li> </ol> <p>You can do the same thing from within a Node-RED flow.</p> <p></p> <p>The flow comprises:</p> <ul> <li> <p>An Inject node, wired to a Template node.</p> <ul> <li>When an Inject node's input tab is clicked, it sets the message payload to the number of seconds since 1/1/1970 UTC and triggers the flow.</li> </ul> </li> <li> <p>A Template node, wired to both a Debug node and a File node. The template field is set to:</p> <pre><code>The time at the moment is {{payload}} seconds since 1/1/1970 UTC !\n</code></pre> <ul> <li>When this node runs, it replaces <code>{{payload}}</code> with the seconds value supplied by the Inject node.</li> </ul> </li> <li> <p>A Debug node.</p> <ul> <li>When this node runs, it displays the payload in the debug window on the right hand side of the Node-RED GUI.</li> </ul> </li> <li> <p>A File node. The \"Filename\" field of the node is set to write to the path:</p> <pre><code>/data/flow-example.txt\n</code></pre> <ul> <li>When this node runs, it writes the payload to the specified file. Remember that <code>/data</code> is an internal path within the Node-RED container.</li> </ul> </li> </ul> <p>Deploying the flow and clicking on the Inject node results in the debug message shown on the right hand side of the screen shot. The embedded terminal window shows that the same information is accessible from outside the container.</p> <p>You can reverse this process. Any file you place within the path <code>~/IOTstack/volumes/nodered/data</code> can be read by a \"File in\" node.</p>"},{"location":"Containers/Node-RED/#sshOutside","title":"Executing commands outside the Node-RED container","text":"<p>A reasonably common requirement in a Node-RED flow is the ability to execute a command on the host system. The standard tool for this is an \"exec\" node.</p> <p>An \"exec\" node works as expected when Node-RED is running as a native service but not when Node-RED is running in a container. That's because the command spawned by the \"exec\" node runs inside the container.</p> <p>To help you understand the difference, consider this command:</p> <pre><code>$ grep \"^PRETTY_NAME=\" /etc/os-release\n</code></pre> <p>When you run that command on a Raspberry Pi outside container-space, the answer will be something like:</p> <pre><code>PRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"\n</code></pre> <p>If you run the same command inside a Node-RED container, the output will reflect the operating system upon which the container is based, such as:</p> <pre><code>PRETTY_NAME=\"Alpine Linux v3.16\"\n</code></pre> <p>The same thing will happen if a Node-RED \"exec\" node executes that <code>grep</code> command when Node-RED is running in a container. It will see the \"Alpine Linux\" answer.</p> <p>Docker doesn't provide any mechanism for a container to execute an arbitrary command outside of its container. A workaround is to utilise SSH. This remainder of this section explains how to set up the SSH scaffolding so that \"exec\" nodes running in a Node-RED container can invoke arbitrary commands outside container-space.</p>"},{"location":"Containers/Node-RED/#sshTaskGoal","title":"Task Goal","text":"<p>Be able to use a Node-RED \"exec\" node to perform the equivalent of:</p> <pre><code>$ ssh host.docker.internal \u00abCOMMAND\u00bb\n</code></pre> <p>where <code>\u00abCOMMAND\u00bb</code> is any command known to the target host.</p> <p>This section uses <code>host.docker.internal</code> throughout. That name comes from method 2 of bridge network - default gateway but, in principle, you can refer to the host using any mechanism described in referring to the host.</p>"},{"location":"Containers/Node-RED/#sshAssumptions","title":"Assumptions","text":"<ul> <li>SensorsIot/IOTstack is installed on your Raspberry Pi.</li> <li>The Node-RED container is running.</li> <li>The user name of the account on the host where you want Node-RED flows to be able to run commands is \"pi\". This user name is not mandatory. Simply substitute your own user name wherever you see \"pi\" in these examples.</li> </ul> <p>These instructions are specific to IOTstack but the underlying concepts should apply to any installation of Node-RED in a Docker container. </p>"},{"location":"Containers/Node-RED/#dockerExec","title":"Executing commands \"inside\" a container","text":"<p>These instructions make frequent use of the ability to run commands \"inside\" the Node-RED container. For example, suppose you want to execute:</p> <pre><code>$ grep \"^PRETTY_NAME=\" /etc/os-release\n</code></pre> <p>You have several options:</p> <ol> <li> <p>You can do it from the normal Raspberry Pi command line using a Docker command. The basic syntax is:</p> <pre><code>$ docker exec {-it} \u00abcontainerName\u00bb \u00abcommand and parameters\u00bb\n</code></pre> <p>The actual command you would need would be:</p> <pre><code>$ docker exec nodered grep \"^PRETTY_NAME=\" /etc/os-release\n</code></pre> <p>Note:</p> <ul> <li>The <code>-it</code> flags are optional. They mean \"interactive\" and \"allocate pseudo-TTY\". Their presence tells Docker that the command may need user interaction, such as entering a password or typing \"yes\" to a question.</li> </ul> </li> <li> <p>You can open a shell into the container, run as many commands as you like inside the container, and then exit. For example:</p> <pre><code>$ docker exec -it nodered bash\n# grep \"^PRETTY_NAME=\" /etc/os-release\n# whoami\n# exit\n$\n</code></pre> <p>In words:</p> <ul> <li>Run the <code>bash</code> shell inside the Node-RED container. You need to be able to interact with the shell to type commands so the <code>-it</code> flag is required.</li> <li>The \"#\" prompt is coming from <code>bash</code> running inside the container. It also signals that you are running as the root user inside the container.</li> <li>You run the <code>grep</code>, <code>whoami</code> and any other commands.</li> <li>You finish with the <code>exit</code> command (or Control+D).</li> <li>The \"$\" prompt means you have left the container and are back at the normal Raspberry Pi command line.</li> </ul> </li> <li> <p>Run the command from Portainer by selecting the container, then clicking the \"&gt;_ console\" link. This is identical to opening a shell.</p> </li> </ol>"},{"location":"Containers/Node-RED/#sshStep1","title":"Step 1: Generate SSH key-pair for Node-RED (one time)","text":"<p>Create a key-pair for Node-RED. This is done by executing the <code>ssh-keygen</code> command inside the container:</p> <pre><code>$ docker exec -it nodered ssh-keygen -q -t ed25519 -C \"Node-RED container key-pair\" -N \"\"\n</code></pre> <p>Notes:</p> <ul> <li>The \"ed25519\" elliptic curve algorithm is recommended (generally described as quicker and more secure than RSA) but you can use the default RSA algorithm if you prefer.</li> <li>Respond to the \"Enter file in which to save the key\" prompt by pressing return to accept the default location.</li> <li>If <code>ssh-keygen</code> displays an \"Overwrite (y/n)?\" message, it implies that a key-pair already exists. You will need to decide what to do:<ul> <li>press y to overwrite (and lose the old keys)</li> <li>press n to terminate the command, after which you can investigate why a key-pair already exists.</li> </ul> </li> </ul>"},{"location":"Containers/Node-RED/#sshStep2","title":"Step 2: Exchange keys with target hosts (once per target host)","text":"<p>Node-RED's public key needs to be copied to the \"pi\" user account on the host where you want a Node-RED \"exec\" node to be able to execute commands. At the same time, the Node-RED container needs to learn the host's public key. The <code>ssh-copy-id</code> command does both steps. The command is:</p> <pre><code>$ docker exec -it nodered ssh-copy-id pi@host.docker.internal\n</code></pre> <p>The output will be something similar to the following:</p> <pre><code>/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"/root/.ssh/id_ed25519.pub\"\nThe authenticity of host 'host.docker.internal (172.17.0.1)' can't be established.\nED25519 key fingerprint is SHA256:gHMlhvArbUPJ807vh5qNEuyRCeNUQQTKEkmDS6qKY6c.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\n</code></pre> <p>Respond to the prompt by typing \"yes\" and pressing return.</p> <p>The output continues:</p> <p><pre><code>/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\nexpr: warning: '^ERROR: ': using '^' as the first character\nof a basic regular expression is not portable; it is ignored\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\npi@host.docker.internal's password: \n</code></pre> The response may look like it contains errors but those can be ignored. </p> <p>Enter the password you use to login as \"pi\" on the host and press return.</p> <p>Normal completion looks similar to this:</p> <pre><code>Number of key(s) added: 1\n\nNow try logging into the machine, with:   \"ssh 'pi@host.docker.internal'\"\nand check to make sure that only the key(s) you wanted were added.\n</code></pre> <p>If you do not see an indication that a key has been added, you may need to retrace your steps.</p>"},{"location":"Containers/Node-RED/#sshStep3","title":"Step 3: Perform the recommended test","text":"<p>The output above recommends a test. The test needs to be run inside the Node-RED container so the syntax is:</p> <pre><code>$ docker exec -it nodered ssh pi@host.docker.internal ls -1 /home/pi/IOTstack\n</code></pre> <p>You should not be prompted for a password. If you are, you may need to retrace your steps.</p> <p>If everything works as expected, you should see a list of the files in your IOTstack folder.</p> <p>Assuming success, think about what just happened? You told SSH inside the Node-RED container to run the <code>ls</code> command outside the container on your Raspberry Pi. You broke through the containerisation.</p>"},{"location":"Containers/Node-RED/#sshWhatsWhere","title":"Understanding what's where and what each file does","text":""},{"location":"Containers/Node-RED/#sshFileLocations","title":"What files are where","text":"<p>Six files are relevant to Node-RED's ability to execute commands outside of container-space:</p> <ul> <li> <p>in <code>/etc/ssh</code>:</p> <ul> <li><code>ssh_host_ed25519_key</code> is the Raspberry Pi's private host key</li> <li> <p><code>ssh_host_ed25519_key.pub</code> is the Raspberry Pi's public host key</p> <p>Those keys were created when your Raspberry Pi was initialised. They are unique to the host.</p> <p>Unless you take precautions, those keys will change whenever your Raspberry Pi is rebuilt from scratch and that will prevent a Node-RED \"exec\" node from being able to invoke SSH to call out of the container.</p> <p>You can recover by re-running <code>ssh-copy-id</code>.</p> </li> </ul> </li> <li> <p>in <code>~/IOTstack/volumes/nodered/ssh</code>:</p> <ul> <li><code>id_ed25519</code> is the Node-RED container's private key </li> <li> <p><code>id_ed25519.pub</code> is the Node-RED container's public key</p> <p>Those keys were created when you generated the SSH key-pair for Node-RED.</p> <p>They are unique to Node-RED but will follow the container in backups and will work on the same machine, or other machines, if you restore the backup.</p> <p>It does not matter if the Node-RED container is rebuilt or if a new version of Node-RED comes down from DockerHub. These keys will remain valid until lost or overwritten.</p> <p>If you lose or destroy these keys, that will prevent a Node-RED \"exec\" node from being able to invoke SSH to call out of the container.</p> <p>You can recover by generating new keys and then re-running <code>ssh-copy-id</code>.</p> </li> <li> <p><code>known_hosts</code></p> <p>The <code>known_hosts</code> file contains a copy of the Raspberry Pi's public host key. It was put there by <code>ssh-copy-id</code>.</p> <p>If you lose this file or it gets overwritten, invoking SSH inside the container will still work but it will re-prompt for authorisation to connect. You will see the prompt if you run commands via <code>docker exec -it</code> but not when invoking SSH from an \"exec\" node.</p> <p>Note that authorising the connection at the command line (\"Are you sure you want to continue connecting?\") will auto-repair the <code>known_hosts</code> file.</p> </li> </ul> </li> <li> <p>in <code>~/.ssh/</code>:</p> <ul> <li> <p><code>authorized_keys</code></p> <p>That file contains a copy of the Node-RED container's public key. It was put there by <code>ssh-copy-id</code>.</p> <p>Pay attention to the path. It implies that there is one <code>authorized_keys</code> file per user, per target host.</p> <p>If you lose this file or it gets overwritten, SSH will still work but will ask for the password for \"pi\". This works when you are running commands from <code>docker exec -it</code> but not when invoking SSH from an \"exec\" node.</p> <p>Note that providing the correct password at the command line will auto-repair the <code>authorized_keys</code> file.</p> </li> </ul> </li> </ul>"},{"location":"Containers/Node-RED/#sshFilePurpose","title":"What each file does","text":"<p>SSH running inside the Node-RED container uses the Node-RED container's private key to provide assurance to SSH running outside the container that it (the Node-RED container) is who it claims to be.</p> <p>SSH running outside container-space verifies that assurance by using its copy of the Node-RED container's public key in <code>authorized_keys</code>.</p> <p>SSH running outside container-space uses the Raspberry Pi's private host key to provide assurance to SSH running inside the Node-RED container that it (the RPi) is who it claims to be.</p> <p>SSH running inside the Node-RED container verifies that assurance by using its copy of the Raspberry Pi's public host key stored in <code>known_hosts</code>.</p>"},{"location":"Containers/Node-RED/#sshConfig","title":"Config file (optional)","text":"<p>You don't have to do this step but it will simplify your exec node commands and reduce your maintenance problems if you do.</p> <p>At this point, SSH commands can be executed from inside the container using this syntax:</p> <pre><code># ssh pi@host.docker.internal \u00abCOMMAND\u00bb\n</code></pre> <p>A <code>config</code> file is needed to achieve the task goal of the simpler syntax:</p> <pre><code># ssh host.docker.internal \u00abCOMMAND\u00bb\n</code></pre> <p>The goal is to set up this file:</p> <pre><code>-rw-r--r-- 1 root root ~/IOTstack/volumes/nodered/ssh/config\n</code></pre> <p>The file needs the ownership and permissions shown. There are several ways of going about this and you are free to choose the one that works for you. The method described here creates the file first, then sets correct ownership and permissions, and then moves the file into place.</p> <p>Start in a directory where you can create a file without needing <code>sudo</code>. The IOTstack folder is just as good as anywhere else:</p> <pre><code>$ cd ~/IOTstack\n$ touch config\n</code></pre> <p>Select the following text, copy it to the clipboard.</p> <pre><code>host host.docker.internal\n  user pi\n  IdentitiesOnly yes\n  IdentityFile /root/.ssh/id_ed25519\n</code></pre> <p>Open <code>~/IOTstack/config</code> in your favourite text editor and paste the contents of the clipboard. Save the file. Change the config file's ownership and permissions, and move it into the correct directory:</p> <pre><code>$ chmod 644 config\n$ sudo chown root:root config\n$ sudo mv config ./volumes/nodered/ssh\n</code></pre>"},{"location":"Containers/Node-RED/#sshConfigTest","title":"Re-test with config file in place","text":"<p>The previous test used this syntax:</p> <pre><code>$ docker exec nodered ssh pi@host.docker.internal ls -1 /home/pi/IOTstack\n</code></pre> <p>Now that the config file is in place, the syntax changes to:</p> <pre><code>$ docker exec nodered ssh host.docker.internal ls -1 /home/pi/IOTstack\n</code></pre> <p>The result should be the same as the earlier test. </p>"},{"location":"Containers/Node-RED/#sshTestFlow","title":"A test flow","text":"<p>In the Node-RED GUI:</p> <ol> <li>Click the \"+\" to create a new, empty flow.</li> <li>Drag the following nodes onto the canvas:<ul> <li>One \"inject\" node</li> <li>Two \"exec\" nodes</li> <li>Two \"debug\" nodes</li> </ul> </li> <li>Wire the outlet of the \"inject\" node to the inlet of both \"exec\" nodes.</li> <li>Wire the uppermost \"stdout\" outlet of the first \"exec\" node to the inlet of the first \"debug\" node.</li> <li>Repeat step 4 with the other \"exec\" and \"debug\" node.</li> <li> <p>Open the first \"exec\" node and:</p> <ul> <li> <p>set the \"command\" field to:</p> <p><pre><code>grep \"^PRETTY_NAME=\" /etc/os-release\n</code></pre>     - turn off the \"append msg.payload\" checkbox     - set the timeout to a reasonable value (eg 10 seconds)     - click \"Done\". 7. Repeat step 6 with the other \"exec\" node, with one difference:     - set the \"command\" field to:</p> <pre><code>ssh host.docker.internal grep \"^PRETTY_NAME=\" /etc/os-release\n</code></pre> </li> </ul> </li> <li> <p>Click the Deploy button.</p> </li> <li>Set the right hand panel to display debug messages.</li> <li>Click the touch panel of the \"inject\" node to trigger the flow.</li> <li> <p>Inspect the result in the debug panel. You should see payload differences similar to the following:</p> <pre><code>PRETTY_NAME=\"Alpine Linux v3.16\"\"\nPRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"\n</code></pre> <p>The first line is the result of running the command inside the Node-RED container. The second line is the result of running the same command outside the Node-RED container on the Raspberry Pi.</p> </li> </ol>"},{"location":"Containers/Node-RED/#maintainNodeRed","title":"Maintaining Node-RED","text":""},{"location":"Containers/Node-RED/#startNodeRed","title":"Starting Node-RED","text":"<p>Use these commands to:</p> <ol> <li>Start the container; or</li> <li>Re-create the container if you have made a material change to the container's service definition in your Compose file.</li> </ol> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d nodered\n</code></pre> <p>The first time you execute this command, the base image of Node-RED is downloaded from DockerHub, and then the Dockerfile is run to produce a local image. The local image is then instantiated to become the running container.</p>"},{"location":"Containers/Node-RED/#stopNodeRed","title":"Stopping Node-RED","text":"<p>To stop the running container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down nodered\n</code></pre> <p>see also if downing a container doesn't work</p> <p>Alternatively, you can stop the entire stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down\n</code></pre>"},{"location":"Containers/Node-RED/#restartNodeRed","title":"Restarting Node-RED","text":"<p>The <code>restart</code> command sends a signal to the processes running within the container. The container itself does not stop.</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart nodered\n</code></pre>"},{"location":"Containers/Node-RED/#rebuildNodeRed","title":"Re-building the local image","text":"<p>You need to rebuild the local image if you do any of the following:</p> <ol> <li>Change either of the build arguments (<code>DOCKERHUB_TAG</code> or <code>EXTRA_PACKAGES</code>) in your Compose file.</li> <li>Make a material change to your Node-RED Dockerfile, such as re-running the menu to change your selection of add-on nodes.</li> </ol> <p>To rebuild your local image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up --build -d nodered\n$ docker system prune -f\n</code></pre> <p>Think of these commands as \"re-running the Dockerfile\". The only time a base image will be downloaded from DockerHub is when a base* image with a tag matching the value of <code>DOCKERHUB_TAG</code> can't be found on your Raspberry Pi.</p> <p>Your existing Node-RED container continues to run while the rebuild proceeds. Once the freshly-built local image is ready, the <code>up</code> tells <code>docker-compose</code> to do a new-for-old swap. There is barely any downtime for your Node-RED service.</p>"},{"location":"Containers/Node-RED/#updateNodeRed","title":"Checking for Node-RED updates","text":"<p>IOTstack provides a convenience script which can help you work out if a new version of Node-RED is available. You can run it like this:</p> <pre><code>$ ~/IOTstack/scripts/nodered_version_check.sh\n</code></pre> <p>The script is not infallible. It works by comparing the version number in the Node-RED image on your system with a version number stored on GitHub.</p> <p>GitHub is always updated before a new image appears on DockerHub. Sometimes there is a delay of weeks between the two events. For that reason, the script should be viewed more like a meteorological forecast than hard fact.</p> <p>The script assumes that your local image builds as <code>iotstack-nodered:latest</code>. If you use different tags, you can pass that information to the script. Example:</p> <pre><code>$ ~/IOTstack/scripts/nodered_version_check.sh iotstack-nodered:3.0.2\n</code></pre>"},{"location":"Containers/Node-RED/#upgradeNodeRed","title":"Upgrading Node-RED","text":"<p>The only way to know, for certain, when an update to Node-RED is available is to check the nodered/node-red tags page on DockerHub.</p> <p>Once a new version appears on DockerHub, you can upgrade Node-RED like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull nodered\n$ docker-compose up -d nodered\n$ docker system prune -f\n</code></pre> <p>Breaking it down into parts:</p> <ul> <li><code>build</code> causes the named container to be rebuilt;</li> <li><code>--no-cache</code> tells the Dockerfile process that it must not take any shortcuts. It really must rebuild the local image;</li> <li><code>--pull</code> tells the Dockerfile process to actually check with DockerHub to see if there is a later version of the base image and, if so, to download it before starting the build;</li> <li><code>nodered</code> is the named container argument required by the <code>build</code> command.</li> </ul> <p>Your existing Node-RED container continues to run while the rebuild proceeds. Once the freshly-built local image is ready, the <code>up</code> tells <code>docker-compose</code> to do a new-for-old swap. There is barely any downtime for your Node-RED service.</p> <p>The <code>prune</code> is the simplest way of cleaning up old images. Sometimes you need to run this twice, the first time to clean up the old local image, the second time for the old base image. Whether an old base image exists depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Node-RED/#containerVersions","title":"Node-RED and <code>node.js</code> versions","text":""},{"location":"Containers/Node-RED/#checkingVersions","title":"Checking versions","text":"<p>You can use the <code>npm version</code> command to check which versions of Node-RED and <code>node.js</code> are running in your container:</p> <pre><code>$ docker exec nodered npm version\n{\n  'node-red-docker': '2.2.2',\n  npm: '6.14.15',\n  ares: '1.18.1',\n  brotli: '1.0.9',\n  cldr: '37.0',\n  http_parser: '2.9.4',\n  icu: '67.1',\n  llhttp: '2.1.4',\n  modules: '72',\n  napi: '8',\n  nghttp2: '1.41.0',\n  node: '12.22.8',\n  openssl: '1.1.1m',\n  tz: '2019c',\n  unicode: '13.0',\n  uv: '1.40.0',\n  v8: '7.8.279.23-node.56',\n  zlib: '1.2.11'\n}\n</code></pre> <p>In the above:</p> <ul> <li><code>'node-red-docker': '2.2.2'</code> indicates that version 2.2.2 of Node-RED is running. This is the version number you see at the bottom of the main menu when you click on the \"hamburger\" icon (\"\u2261\") at the top, right of the Node-Red window in your browser.</li> <li><code>node: '12.22.8'</code> indicates that version 12.x of <code>node.js</code> is installed.</li> </ul>"},{"location":"Containers/Node-RED/#versionControl","title":"Controlling versions","text":"<p>IOTstack uses a service definition for Node-RED that includes these lines:</p> <pre><code>    build:\n      context: ./services/nodered/.\n      args:\n      - DOCKERHUB_TAG=latest\n</code></pre> <p>If you do not see this structure in your Compose file, refer to updating to July 2022 syntax.</p> <p>The value of the <code>DOCKERHUB_TAG</code> gives you the ability to control, from your Compose file, which versions of Node-RED and <code>node.js</code> run within your Node-RED container.</p> <p>The allowable values of <code>DOCKERHUB_TAG</code> can be found on the DockerHub Node-RED tags page. The table below contains examples of tags that were available on DockerHub at the time of writing (2022-07-06):</p> tag Node-RED version <code>node.js</code> version latest 2.2.2 14.x latest-14 2.2.2 14.x \ud83d\udccc 2.2.2 2.2.2 \ud83d\udccc 14.x 2.2.2-14 2.2.2 \ud83d\udccc 14.x \ud83d\udccc <p>Interpreting the tag:</p> <ol> <li> <p>The sub-string to the left of the hyphen determines the version of Node-RED:</p> <ul> <li>\"latest\" means the most up-to-date version, implying that the actual version number can change any time you follow the process to upgrade Node-RED.</li> <li>\"2.2.2\" pins your container to that specific version of Node-RED, implying that the version number will be frozen until you change the pin.</li> </ul> </li> <li> <p>The sub-string to the right of the hyphen determines the version of <code>node.js</code>:</p> <ul> <li>\"-14\" refers to <code>node.js</code> version 14.x and pins your container to that specific version of <code>node.js</code>.</li> <li>If the hyphen and suffix are omitted, it implies that the actual version of <code>node.js</code> can change any time you follow the process to upgrade Node-RED.</li> </ul> </li> </ol> <p>In short:</p> <ul> <li>If you pin both sides to specific values (eg \"2.2.2-14\") then all decisions about when to upgrade and which versions to use are under your control; but</li> <li>If you use \"latest\" then all timing and version decisions are under the control of the maintainers of the DockerHub images.</li> </ul> <p>IOTstack defaults to \"latest\". Although this appears to cede control to the maintainers of the DockerHub images, in practice it is no different to any other container where you pull its image directly from DockerHub using the <code>latest</code> tag (irrespective of whether <code>latest</code> is explicit or implied by omission).</p> <p>The <code>DOCKERHUB_TAG</code> argument for Node-RED merely gives you the ability to pin to specific versions of Node-RED from within your Compose file, in the same way as you can use tags on <code>image</code> directives for other containers.</p> <p>For example, suppose you wanted to pin to Node-RED version 2.2.2 with <code>node.js</code> version 12:</p> <ol> <li> <p>Edit your Compose file so that the <code>DOCKERHUB_TAG</code> looks like this:</p> <pre><code>- DOCKERHUB_TAG=2.2.2-12\n</code></pre> </li> <li> <p>Run the re-building the local Node-RED image commands.</p> </li> </ol> <p>Changing a pinned version and rebuilding may result in a new base image being downloaded from DockerHub.</p>"},{"location":"Containers/Node-RED/#componentManagement","title":"Component management","text":""},{"location":"Containers/Node-RED/#viaDockerfile","title":"via Dockerfile","text":"<p>You can install components by adjusting the Node-RED Dockerfile. This can be done by:</p> <ul> <li>Running the IOTstack menu and changing the selected Node-RED nodes; or</li> <li>Editing your Node-RED Dockerfile using a text editor.</li> </ul> <p>Using the IOTstack menu limits your choice of components to those presented in the menu. Editing the Dockerfile with a text editor is more flexible but carries the risk that your changes could be lost if you subsequently use the menu method.</p> <p>To apply changes made to your Dockerfile, run the re-building the local Node-RED image commands.</p>"},{"location":"Containers/Node-RED/#viaManagePalette","title":"via Manage Palette","text":"<p>You can add, remove or update components in Manage Palette. Node-RED will remind you to restart Node-RED and that is something you have to do by hand:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart nodered\n</code></pre> <p>Note:</p> <ul> <li> <p>Some users have reported misbehaviour from Node-RED if they do too many iterations of:</p> <ul> <li>make a change in Manage Palette</li> <li>restart Node-RED</li> </ul> <p>It is better to make all the changes you intend to make, and only then restart Node-RED.</p> </li> </ul>"},{"location":"Containers/Node-RED/#viaNPM","title":"via <code>npm</code>","text":"<p>You can also run <code>npm</code> inside the container to install any component that could be installed by <code>npm</code> in a non-container environment. This is the basic syntax:</p> <pre><code>$ cd ~/IOTstack\n$ docker exec -w /data nodered npm \u00abcommand\u00bb \u00abarguments\u2026\u00bb\n$ docker-compose restart nodered\n</code></pre> <p>Examples:</p> <ul> <li> <p>To add the \"find my iphone\" node:</p> <pre><code>$ docker exec -w /data nodered npm install find-my-iphone-node\n$ docker-compose restart nodered\n</code></pre> </li> <li> <p>To remove the \"find my iphone\" node:</p> <pre><code>$ docker exec -w /data nodered npm uninstall find-my-iphone-node\n$ docker-compose restart nodered\n</code></pre> </li> </ul> <p>Note:</p> <ul> <li>You must include <code>-w /data</code> on each command. Any formula you find on the web will not include this. You have to remember to do it yourself!</li> <li>Many web examples include the <code>--save</code> flag on the <code>npm</code> command. That flag is not needed (it is ignored because the behaviour it used to control has been the default since NPM version 5. Node-RED containers have been using NPM version 6 for some time.</li> <li>See also the note above about restarting too frequently.</li> <li> <p>You can use this approach if you need to force the installation of a specific version (which you don't appear to be able to do in Manage Palette). For example, to install version 4.0.0 of the \"moment\" node:</p> <pre><code>$ docker exec -w /data nodered npm install node-red-contrib-moment@4.0.0\n$ docker-compose restart nodered\n</code></pre> </li> </ul>"},{"location":"Containers/Node-RED/#viaWhich","title":"Comparison of methods","text":"<p>In terms of outcome, there is no real difference between the various methods. However, some nodes (eg \"node-red-contrib-generic-ble\" and \"node-red-node-sqlite\") must be installed by Dockerfile. The only way of finding out if a component must be installed via Dockerfile is to try Manage Palette and find that it doesn't work.</p> <p>Aside from the exception cases that require Dockerfile or where you need to force a specific version, it is quicker to install nodes via Manage Palette and applying updates is a bit easier too. But it's really up to you.</p> <p>If you're wondering about \"backup\", nodes installed via:</p> <ul> <li>Dockerfile \u2013 implicitly backed up when the Dockerfile is backed-up.</li> <li>Manage Palette or <code>npm install</code> \u2013 explicitly backed up when the <code>~/IOTstack/volumes</code> directory is backed-up.</li> </ul> <p>Basically, if you're running IOTstack backups then your add-on nodes will be backed-up.</p>"},{"location":"Containers/Node-RED/#componentPrecedence","title":"Component precedence","text":"<p>Components that are installed via Dockerfile wind up at the internal path:</p> <pre><code>/usr/src/node-red\n</code></pre> <p>Components installed via Manage Palette or <code>docker exec -w /data</code> wind up at the internal path:</p> <pre><code>/data\n</code></pre> <p>which is the same as the external path:</p> <pre><code>~/IOTstack/volumes/nodered/data\n</code></pre> <p>Because there are two places, this invites the question of what happens if a given component is installed in both? The answer is that components installed in <code>/data</code> take precedence.</p> <p>Or, to put it more simply: in any contest between methods, Dockerfile comes last.</p>"},{"location":"Containers/Node-RED/#fixDuplicateNodes","title":"Resolving node duplication","text":"<p>Sometimes, even when you are 100% certain that you didn't do it, a component will turn up in both places. There is probably some logical reason for this but I don't know what it is.</p> <p>The problem this creates is that a later version of a component installed via Dockerfile will be blocked by the presence of an older version of that component installed by a different method.</p> <p>The <code>nodered_list_installed_nodes.sh</code> script helps discover when this situation exists. For example:</p> <pre><code>$ nodered_list_installed_nodes.sh \n\nFetching list of candidates installed via Dockerfile\n\nComponents built into the image (via Dockerfile)\n  ACTIVE: node-red-admin\n  ACTIVE: node-red-configurable-ping\n  ACTIVE: node-red-contrib-boolean-logic\n  ACTIVE: node-red-contrib-generic-ble\n  ACTIVE: node-red-contrib-influxdb\n  ACTIVE: node-red-dashboard\n BLOCKED: node-red-node-email\n  ACTIVE: node-red-node-pi-gpiod\n  ACTIVE: node-red-node-rbe\n  ACTIVE: node-red-node-sqlite\n  ACTIVE: node-red-node-tail\n\nFetching list of candidates installed via Manage Palette or npm\n\nComponents in persistent store at\n /home/pi/IOTstack/volumes/nodered/data/node_modules\n  node-red-contrib-boolean-logic-ultimate\n  node-red-contrib-chartjs\n  node-red-node-email\n  node-red-contrib-md5\n  node-red-contrib-moment\n  node-red-contrib-pushsafer\n</code></pre> <p>Notice how the <code>node-red-node-email</code> instance installed in the Dockerfile is being blocked. To fix this problem:</p> <pre><code>$ cd ~/IOTstack\n$ docker exec -w /data nodered npm uninstall node-red-node-email\n$ docker-compose restart nodered\n</code></pre>"},{"location":"Containers/Node-RED/#packageManagement","title":"Package management","text":"<p>As well as providing the Node-RED service, the nodered container is an excellent testbed. Installing the DNS tools, Mosquitto clients and tcpdump will help you to figure out what is going on inside container-space.</p> <p>There are two ways to add extra packages. The first method is to add them to the running container. For example, to add the Mosquitto clients:</p> <pre><code>$ docker exec nodered apk add --no-cache mosquitto-clients\n</code></pre> <p>The \"apk\" implies that the Node-RED container is based on Alpine Linux. Keep that in mind when you search for instructions on installing packages.</p> <p>Packages installed this way will persist until the container is re-created (eg a <code>down</code> and <code>up</code> of the stack, or a reboot of your Raspberry Pi). This is a good choice if you only want to run a quick experiment.</p> <p>The second method adds the packages to your local image every time you rebuild. Because the packages are in the local image, they are always in the running container. For example, to include the Mosquitto clients in every build:</p> <ol> <li> <p>Edit your Compose file to include the package on the <code>EXTRA_PACKAGES</code> argument:</p> <pre><code>- EXTRA_PACKAGES=mosquitto-clients\n</code></pre> <p>If you do not see the <code>EXTRA_PACKAGES</code> argument in your Compose file, refer to updating to July 2022 syntax.</p> </li> <li> <p>Rebuild your local image by running the re-building the local Node-RED image commands.</p> </li> </ol> <p>You can specify multiple packages on the same line. For example:</p> <pre><code>- EXTRA_PACKAGES=mosquitto-clients bind-tools tcpdump\n</code></pre> <p>Notes:</p> <ol> <li>Use a space to separate package names.</li> <li>Do not encapsulate the list in quote marks.</li> </ol>"},{"location":"Containers/Node-RED/#july2022syntax","title":"Updating to July 2022 syntax","text":"<p>The primary benefit of the new syntax is that you no longer risk the IOTstack menu overwriting any custom changes you may have made to your Node-RED Dockerfile.</p> <p>If you install a clean copy of IOTstack, run the menu, enable Node-RED and select one or more add-on nodes then both your Compose file and Dockerfile will use the latest syntax automatically.</p> <p>If you have an older version of IOTstack installed, the syntax used in your Compose file and Dockerfile will depend on when you last ran the menu and manipulated Node-RED.</p> <p>To avoid any uncertainties, you can use a text editor to update your existing Compose file and Dockerfile to adopt the latest syntax.</p>"},{"location":"Containers/Node-RED/#july2022compose","title":"Updating your Compose file","text":"<ul> <li> <p>Step 1: Implement the new syntactic scaffolding:</p> <p>The first three lines of the old syntax are:</p> <pre><code>  nodered:\n    container_name: nodered\n    build: ./services/nodered/.\n</code></pre> <p>Replace line 3 (the one-line <code>build:</code> directive) with the following lines:</p> <pre><code>    build:\n      context: ./services/nodered/.\n      args:\n      - DOCKERHUB_TAG=latest\n      - EXTRA_PACKAGES=\n</code></pre> </li> <li> <p>Step 2: Pin to the desired version (optional):</p> <p>If your existing Dockerfile pins to a specific version, edit the value of <code>DOCKERHUB_TAG</code> (line 6 of your updated Compose file) to use the tag from your Dockerfile. For example, if your existing Dockerfile begins with:</p> <pre><code>FROM nodered/node-red:latest-12\n</code></pre> <p>then line 6 of your Compose file should be:</p> <pre><code>      - DOCKERHUB_TAG=latest-12\n</code></pre> <p>Note:</p> <ul> <li>IOTstack switched to <code>latest-12</code> in March 2021. The default for July 2022 syntax is <code>latest</code>. At the time of writing, that is the same as <code>latest-14</code>, which is what is recommended by Node-RED. If any of your flows has a dependence on <code>node.js</code> version 12 (or if you do not want to take the risk), use <code>latest-12</code>.</li> </ul> </li> <li> <p>Step 3: Define extra packages (optional):</p> <p>If your existing Dockerfile includes extra packages, edit the value of <code>EXTRA_PACKAGES</code> (line 7 of your updated Compose file) to list the same packages. For example, if your existing Dockerfile includes:</p> <pre><code>RUN apk update &amp;&amp; apk add --no-cache eudev-dev mosquitto-clients bind-tools tcpdump\n</code></pre> <p>then everything after <code>eudev-dev</code> should appear on line 7 of your Compose file: </p> <pre><code>      - EXTRA_PACKAGES=mosquitto-clients bind-tools tcpdump\n</code></pre> <p>Notes:</p> <ul> <li>use spaces between package names.</li> <li>do not enclose the list of packages in quotes.</li> <li>do not include <code>eudev-dev</code> (it is specified in the updated Dockerfile).</li> </ul> </li> </ul>"},{"location":"Containers/Node-RED/#july2022dockerfile","title":"Updating your Dockerfile","text":"<p>The first four lines of your existing Dockerfile will have a structure similar to this:</p> <pre><code>FROM nodered/node-red:latest-12\nUSER root\nRUN apk update &amp;&amp; apk add --no-cache eudev-dev\nUSER node-red\n</code></pre> <p>The actual text will depend on whether you have modified the tag in the first line or added extra packages to the third line.</p> <p>Replace the first four lines of your Dockerfile with the following lines:</p> <pre><code># reference argument - omitted defaults to latest\nARG DOCKERHUB_TAG=latest\n\n# Download base image\nFROM nodered/node-red:${DOCKERHUB_TAG}\n\n# reference argument - omitted defaults to null\nARG EXTRA_PACKAGES\nENV EXTRA_PACKAGES=${EXTRA_PACKAGES}\n\n# default user is node-red - need to be root to install packages\nUSER root\n\n# install packages\nRUN apk update &amp;&amp; apk add --no-cache eudev-dev ${EXTRA_PACKAGES}\n\n# switch back to default user\nUSER node-red\n\n# variable not needed inside running container\nENV EXTRA_PACKAGES=\n\n# add-on nodes follow\n</code></pre> <p>All remaining lines of your original Dockerfile should be left as-is.</p>"},{"location":"Containers/Node-RED/#july2022build","title":"Applying the new syntax","text":"<p>Run the re-building the local Node-RED image commands.</p>"},{"location":"Containers/Node-RED/#linuxDistro","title":"Alpine vs Debian","text":"<p>The first part of IOTstack's default service definition for Node-RED is shown at IOTstack first run. Although it is not immediately obvious, this results in a container which is based on the Alpine Linux distribution. You can confirm this by running:</p> <pre><code>$ docker exec nodered grep \"PRETTY_NAME\" /etc/os-release\nPRETTY_NAME=\"Alpine Linux v3.20\"\n</code></pre> <p>Historically, Node-RED has been distributed on on Dockerhub as two distinct sets of Node-RED images:</p> <ul> <li>Those based on the Alpine Linux distribution; and</li> <li>Those based on the Debian Linux distribution.</li> </ul> <p>In general, Node-RED images have tracked Alpine releases more consistently than they have Debian. For example, at the time of writing (July 2024):</p> Image Tag Distro Image OS Current <code>latest</code> Alpine v3.20 v3.20 <code>latest-debian</code> Debian 11 (bullseye) 12 (bookworm) <p>In addition, Node-RED images based on Alpine have offered a greater range of options when it comes to the embedded version of Node.js. At the time of writing:</p> <ul> <li>image variants based on Alpine Linux include <code>latest-18</code>, <code>latest-20</code> and <code>latest-22</code>, implying a choice of Node.js versions 18, 20 and 22, with version 20 being the default;  while</li> <li>the single image variant for Debian Linux is <code>latest-debian</code> which comes with Node.js version 20.</li> </ul> <p>Naturally, this situation could change at any time! This information is only here to make the point that, historically, Node-RED images based on Debian have lagged behind Alpine and have only supported a single version of Node.js. This is also the main reason why IOTstack defaults to Alpine images.</p> <p>However, there may be circumstances where you decide it is appropriate to run a Node-RED image based on Debian. The purpose of this section is not to explore scenarios nor weigh the pros and cons, merely to explain how to adapt your Node-RED service definition to accomplish it. Proceed as follows:</p> <ol> <li> <p>Make a copy of your existing Dockerfile:</p> <pre><code>$ cd ~/IOTstack/services/nodered\n$ cp Dockerfile Debian.Dockerfile\n</code></pre> <p>The reason for making a copy is to preserve your existing (Alpine-aware) Dockerfile so you can easily switch back if you break something.</p> </li> <li> <p>Open <code>Debian.Dockerfile</code> in a text editor and make the following changes:</p> <ul> <li> <p>Find the line:</p> <pre><code>ARG DOCKERHUB_TAG=latest\n</code></pre> <p>Replace that line with:</p> <pre><code>ARG DOCKERHUB_TAG=latest-debian\n</code></pre> </li> <li> <p>Find the line:</p> <pre><code>RUN apk update &amp;&amp; apk add --no-cache eudev-dev ${EXTRA_PACKAGES}\n</code></pre> <p>Replace that line with:</p> <pre><code>RUN apt update &amp;&amp; apt install -y udev ${EXTRA_PACKAGES}\n</code></pre> <p><code>apk</code> is the Alpine package manager whereas <code>apt</code> is the Debian package manager.</p> </li> <li> <p>Save your work.</p> </li> </ul> </li> <li> <p>Make a copy of your existing compose file:</p> <pre><code>$ cd ~/IOTstack\n$ cp docker-compose.yml docker-compose.yml.bak\n</code></pre> <p>The reason for making a copy is to preserve your existing (Alpine-aware) service definition so you can easily switch back if you break something.</p> </li> <li> <p>Open <code>docker-compose.yml</code> in a text editor and make the following changes:</p> <ul> <li> <p>Change the Node-RED <code>build</code> clause so that it looks like this:</p> <pre><code>    build:\n      context: ./services/nodered/.\n      dockerfile: Debian.Dockerfile\n      args:\n        - DOCKERHUB_TAG=latest-debian\n        - EXTRA_PACKAGES=\n</code></pre> <p>There are two key edits:</p> <ol> <li>Insert the <code>dockerfile</code> line (as line 5).</li> <li>Change the right hand side of the <code>DOCKERHUB_TAG</code> argument from <code>latest</code> to <code>latest-debian</code> (line 7).</li> </ol> </li> <li> <p>If you have any <code>EXTRA_PACKAGES</code> specified, you will need to allow for any package-name differences between Alpine and Debian. For example, suppose you are using this list of extra packages with Alpine:</p> <pre><code>- EXTRA_PACKAGES=mosquitto-clients bind-tools tcpdump tree\n</code></pre> <p>The <code>mosquitto-clients</code>, <code>tcpdump</code> and <code>tree</code> packages have the same names in the <code>apk</code> (Alpine) package manager as they do in <code>apt</code> (Debian) whereas <code>bind-tools</code> is named <code>dnsutils</code> in the Debian repositories. Thus the extra packages list for a Debian build would need to be:</p> <pre><code>- EXTRA_PACKAGES=mosquitto-clients dnsutils tcpdump tree\n</code></pre> </li> <li> <p>Save your work.</p> </li> </ul> </li> <li> <p>Rebuild Node-RED:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull nodered\n</code></pre> <p>If the build process reports any errors, go back and check your work.</p> </li> <li> <p>Start the new container:</p> <pre><code>$ docker-compose up -d nodered\n</code></pre> </li> <li> <p>Check that the new container is running properly and hasn't gone into a restart loop:</p> <pre><code>$ docker ps -a --format \"table {{.Names}}\\t{{.RunningFor}}\\t{{.Status}}\\t{{.Size}}\" --filter name=nodered\nNAMES     CREATED          STATUS                    SIZE\nnodered   32 seconds ago   Up 31 seconds (healthy)   0B (virtual 945MB)\n</code></pre> <p>Providing the STATUS column reports \"healthy\" after roughly 30 seconds of runtime, it is usually safe to assume that the container is behaving normally.</p> </li> <li> <p>Verify the base Linux distribution being used by the container:</p> <pre><code>$ docker exec nodered grep \"PRETTY_NAME\" /etc/os-release\nPRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"\n</code></pre> </li> <li> <p>Check your Node-RED and Node.js versions:</p> <pre><code>$ docker exec nodered npm version --json | jq -r '[.[\"node-red-docker\"],.[\"node\"]] | @tsv'\n4.0.2   20.15.0\n</code></pre> <p>Interpretation - the container is running:</p> <ul> <li>Node-RED version 4.0.2, with</li> <li>Node.js version 20.15.0</li> </ul> </li> </ol> <p>The actual version numbers you see in the last two steps will depend (obviously) on whatever the good folks who maintain Node-RED thought was appropriate at the time they released whatever <code>latest-debian</code> variant is present on DockerHub at the moment when you perform the migration.</p> <p>Please keep in mind that none of this affects the IOTstack menu. Re-running the menu is likely to revert your Node-RED service definition to be based on Alpine images.</p>"},{"location":"Containers/Octoprint/","title":"OctoPrint \u2013 the snappy web interface for your 3D printer","text":""},{"location":"Containers/Octoprint/#references","title":"References","text":"<ul> <li>OctoPrint home page</li> <li>OctoPrint Community Forum</li> <li>DockerHub octoprint/octoprint</li> <li>GitHub OctoPrint/octoprint-docker</li> </ul>"},{"location":"Containers/Octoprint/#3d-printer-device-mapping","title":"3D Printer device mapping","text":"<p>The first time you try to bring up the OctoPrint container, you should expect to see the following error:</p> <pre><code>parsing ~/IOTstack/docker-compose.yml: error while interpolating services.octoprint.devices.[]: required variable OCTOPRINT_DEVICE_PATH is missing a value: eg echo OCTOPRINT_DEVICE_PATH=/dev/serial0 &gt;&gt;~/IOTstack/.env\n</code></pre> <p>The message is telling you that you need to define the device path to your 3D Printer. </p> <p>You need to work out how your printer presents itself and define the external device accordingly.</p>"},{"location":"Containers/Octoprint/#option-1-devttyusbn","title":"option 1 - <code>/dev/ttyUSBn</code>","text":"<p>Using \"ttyUSBn\" will \"work\" but, because of the inherent variability in the name, this approach is not recommended.</p> <p>The \"n\" in the \"ttyUSBn\" can vary depending on which USB devices are attached to your Raspberry Pi and the order in which they are attached. The \"n\" may also change as you add and remove devices.</p> <p>If the OctoPrint container is up when the device number changes, the container will crash, and it will either go into a restart loop if you try to bring it up when the expected device is not \"there\", or will try to communicate with a device that isn't your 3D printer.</p> <p>Suppose you choose this method and your 3D Printer mounts as <code>/dev/ttyUSB0</code>, you would define your printer like this:</p> <pre><code>$ echo OCTOPRINT_DEVICE_PATH=/dev/ttyUSB0 &gt;&gt;~/IOTstack/.env\n</code></pre>"},{"location":"Containers/Octoprint/#option-2-devserialby-idxxxxxxxx","title":"option 2 - <code>/dev/serial/by-id/xxxxxxxx</code>","text":"<p>The \"xxxxxxxx\" is (usually) unique to your 3D printer. To find it, connect your printer to your Raspberry Pi, then run the command:</p> <pre><code>$ ls -1 /dev/serial/by-id\n</code></pre> <p>You will get an answer like this:</p> <pre><code>usb-Silicon_Labs_CP2102N_USB_to_UART_Bridge_Controller_3b14eaa48a154d5e87032d59459d5206-if00-port0\n</code></pre> <p>Suppose you choose this method and your 3D Printer mounts as shown above. You would define your printer like this:</p> <pre><code>$ echo OCTOPRINT_DEVICE_PATH=/dev/serial/by-id/usb-Silicon_Labs_CP2102N_USB_to_UART_Bridge_Controller_3b14eaa48a154d5e87032d59459d5206-if00-port0 &gt;&gt;~/IOTstack/.env\n</code></pre> <p>Note:</p> <ul> <li>If you have multiple serial devices attached, you will get multiple lines in the output. It is up to you to sort out which one belongs to your 3D printer, possibly by disconnecting and re-attaching the printer and observing how the list changes.</li> <li>The uniqueness of device IDs is under the control of the device manufacturer. Each manufacturer should ensure their devices are unique but some manufacturers are more diligent than others.</li> <li>device by-id names follow the device. In other words, if you have two or more Raspberry Pis and a collection of serial devices (3D printers, Zigbee adapters, UARTs, and so on), a 3D printer will always get the same by-id name, irrespective of which Raspberry Pi it is attached to.</li> <li>device by-id names do not persist if the physical device is disconnected. If you switch off your 3D printer or disconnect the USB cable while the OctoPrint container is running, the container will crash.</li> </ul>"},{"location":"Containers/Octoprint/#option-3-devhumanreadablename","title":"option 3 - <code>/dev/humanReadableName</code>","text":"<p>Suppose your 3D printer is a MasterDisaster5000Pro, and that you would like to be able to set up the device to use a human-readable name like:</p> <pre><code>/dev/MasterDisaster5000Pro\n</code></pre> <p>Start by disconnecting your 3D printer from your Raspberry Pi. Next, run this command:</p> <pre><code>$ tail -f /var/log/messages\n</code></pre> <p>Connect your 3D printer and observe the log output. You are interested in messages that look like this:</p> <pre><code>mmm dd hh:mm:ss mypi kernel: [423839.626522] cp210x 1-1.1.3:1.0: device disconnected\nmmm dd hh:mm:ss mypi kernel: [431265.973308] usb 1-1.1.3: new full-speed USB device number 10 using dwc_otg\nmmm dd hh:mm:ss mypi kernel: [431266.109418] usb 1-1.1.3: New USB device found, idVendor=dead, idProduct=beef, bcdDevice= 1.00\nmmm dd hh:mm:ss mypi kernel: [431266.109439] usb 1-1.1.3: New USB device strings: Mfr=1, Product=2, SerialNumber=3\nmmm dd hh:mm:ss mypi kernel: [431266.109456] usb 1-1.1.3: Product: CP2102N USB to UART Bridge Controller\nmmm dd hh:mm:ss mypi kernel: [431266.109471] usb 1-1.1.3: Manufacturer: Silicon Labs\nmmm dd hh:mm:ss mypi kernel: [431266.109486] usb 1-1.1.3: SerialNumber: cafe80facefeed\nmmm dd hh:mm:ss mypi kernel: [431266.110657] cp210x 1-1.1.3:1.0: cp210x converter detected\nmmm dd hh:mm:ss mypi kernel: [431266.119225] usb 1-1.1.3: cp210x converter now attached to ttyUSB0\n</code></pre> <p>and, in particular, these two lines:</p> <pre><code>\u2026 New USB device found, idVendor=dead, idProduct=beef, bcdDevice= 1.00\n\u2026 SerialNumber: cafe80facefeed\n</code></pre> <p>Terminate the <code>tail</code> command by pressing Control+C.</p> <p>Use this line as a template:</p> <pre><code>SUBSYSTEM==\"tty\", ATTRS{idVendor}==\"\u00abidVendor\u00bb\", ATTRS{idProduct}==\"\u00abidProduct\u00bb\", ATTRS{serial}==\"\u00abSerialNumber\u00bb\", SYMLINK+=\"\u00absensibleName\u00bb\"\n</code></pre> <p>Replace the \u00abdelimited\u00bb values with those you see in the log output. For example, given the above log output, and the desire to associate your 3D printer with the human-readable name of \"MasterDisaster5000Pro\", the result would be:</p> <pre><code>SUBSYSTEM==\"tty\", ATTRS{idVendor}==\"dead\", ATTRS{idProduct}==\"beef\", ATTRS{serial}==\"cafe80facefeed\", SYMLINK+=\"MasterDisaster5000Pro\"\n</code></pre> <p>Next, ensure the required file exists by executing the following command:</p> <pre><code>$ sudo touch /etc/udev/rules.d/99-usb-serial.rules\n</code></pre> <p>If the file does not exist already, the <code>touch</code> command creates an empty file, owned by root, with mode 644 (rw-r--r--) permissions (all of which are correct).</p> <p>Use <code>sudo</code> and your favourite text editor to edit <code>/etc/udev/rules.d/99-usb-serial.rules</code> and insert the \"SUBSYSTEM==\" line you prepared earlier into that file, then save the file.</p> <p>Rules files are read on demand so there is no <code>start</code> or <code>reload</code> command to execute.</p> <p>Check your work by disconnecting, then re-connecting your 3D printer, and then run:</p> <pre><code>$ ls /dev\n</code></pre> <p>You should expect to see the human-readable name you chose in the list of devices.</p> <p>You would then define your printer like this:</p> <pre><code>$ echo OCTOPRINT_DEVICE_PATH=/dev/MasterDisaster5000Pro &gt;&gt;~/IOTstack/.env\n</code></pre> <p>Notes:</p> <ul> <li>device names follow the device. In other words, if you have two or more Raspberry Pis and a collection of serial devices (3D printers, Zigbee adapters, UARTs, and so on), you can build a single <code>99-usb-serial.rules</code> file that you install on all of your Raspberry Pis. Then, you can attach a named device to any of your Raspberry Pis and it will always get the same name.</li> <li>device names do not persist if the physical device is disconnected. If you switch off your 3D printer or disconnect the USB cable while the OctoPrint container is running, the container will crash.</li> </ul>"},{"location":"Containers/Octoprint/#the-devvideo0devvideo0-mapping","title":"the <code>/dev/video0:/dev/video0</code> mapping","text":"<p>By default, video camera support is disabled. This is because it is unsafe to assume a camera is present on <code>/dev/video0</code>.</p> <p>See the Webcams topic of the Octoprint Community Forum for help configuring other kinds of cameras.</p> <p>The OctoPrint docker image includes an MJPG streamer. You do not need to run another container with a streamer unless you want to.</p> <p>To activate a Raspberry Pi camera attached via ribbon cable:</p> <ol> <li>Follow the instructions at raspberrypi.org to connect and test the camera. There are guides on YouTube (example) if you need help working out how to insert the ribbon cable.</li> <li>Confirm the presence of <code>/dev/video0</code>.</li> <li> <p>Edit <code>docker-compose.yml</code> and uncomment all of the commented-out lines in the following:</p> <pre><code>environment:\n  # - ENABLE_MJPG_STREAMER=true\n  # - MJPG_STREAMER_INPUT=-r 640x480 -f 10 -y\n  # - CAMERA_DEV=/dev/video0\n\ndevices:\n  # - /dev/video0:/dev/video0\n</code></pre> <p>Note:</p> <ul> <li>The device path on the right hand side of the <code>CAMERA_DEV</code> environment variable corresponds with the right hand side (ie after the colon) of the device mapping. There should be no reason to change either.</li> </ul> </li> </ol> <p>The \"640x480\" <code>MJPG_STREAMER_INPUT</code> settings will probably result in your camera feed being \"letterboxed\" but they will get you started. A full list of options is at mjpg-streamer-configuration-options.</p> <p>The typical specs for a baseline Raspberry Pi camera are:</p> <ul> <li>1080p 720p 5Mp Webcam</li> <li>Max resolution: 2592x1944</li> <li>Max frame rate: VGA 90fps, 1080p 30fps</li> <li>CODEC: MJPG H.264 AVC</li> </ul> <p>For that type of camera, the following is probably more appropriate:</p> <pre><code>  - MJPG_STREAMER_INPUT=-r 1152x648 -f 10\n</code></pre> <p>The resolution of 1152x648 is 60% of 1080p 1920x1080 and does not cause letterboxing. The resolution and rate of 10 frames per second won't over-tax your communications links, and the camera is MJPEG-capable so it does not need the <code>-y</code> option.</p>"},{"location":"Containers/Octoprint/#practical-usage","title":"Practical usage","text":""},{"location":"Containers/Octoprint/#starting-the-octoprint-container","title":"starting the OctoPrint container","text":"<p>To start a print session:</p> <ol> <li>Turn the 3D printer on.</li> <li> <p>Bring up the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d octoprint\n</code></pre> </li> </ol> <p>If you try to start the OctoPrint container before your 3D printer has been switched on and the USB interface has registered with the Raspberry Pi, the container will go into a restart loop.</p>"},{"location":"Containers/Octoprint/#first-run-the-setup-wizard","title":"first run \u2013 the Setup Wizard","text":"<p>Use a browser to point to port 9980 on your Raspberry Pi. For example:</p> <pre><code>http://raspberrypi.local:9980\n</code></pre> <p>This will launch the \"Setup Wizard\".</p> <ol> <li> <p>Click the \"Next\" button until you reach the \"Access Control\" screen:</p> <ul> <li>Define a Username and Password, and keep a record of your decisions.</li> <li>Click \"Create Account\".</li> <li>Ignore the alarming popup alert by clicking \"Ignore\". This alert is a result of OctoPrint running in a Docker container.</li> <li>Click \"Next\".</li> </ul> </li> <li> <p>At the \"Online Connectivity Check\" screen:</p> <ul> <li>Click \"Disable Connectivity Check\".</li> <li>Click \"Next\".</li> </ul> </li> <li> <p>At the \"Configure Anonymous Usage Tracking\" and \"Configure plugin blacklist processing\" screens:</p> <ul> <li>Make a decision about whether you want the feature enabled or disabled and click the appropriate button.</li> <li>Click \"Next\".</li> </ul> </li> <li> <p>At the \"Set up your printer profile\" screen:</p> <ul> <li>It is probably a good idea to visit the tabs and set values appropriate to your printer (build volume, at least).</li> <li>Click \"Next\".</li> </ul> </li> <li> <p>At the \"Server Commands\" screen:</p> <ul> <li> <p>Enter the following in the \"Restart OctoPrint\" field:</p> <pre><code>s6-svc -r /var/run/s6/services/octoprint\n</code></pre> </li> <li> <p>Click \"Next\".</p> </li> </ul> </li> <li> <p>At the \"Webcam &amp; Timelapse Recordings\" screen, and assuming you are configuring a PiCamera:</p> <ul> <li> <p>Enter the following in the \"Stream URL\" field:</p> <pre><code>/webcam/?action=stream\n</code></pre> <p>Click the \"Test\" button to confirm that the camera is working, then click \"Close\".</p> </li> <li> <p>Enter the following in the \"Snapshot URL\" field:</p> <pre><code>http://localhost:8080/?action=snapshot\n</code></pre> <p>Click the \"Test\" button to confirm that the camera is working, then click \"Close\".</p> </li> <li> <p>Enter the following in the \"Path to FFMPEG\" field:</p> <pre><code>/usr/bin/ffmpeg\n</code></pre> <p>The expected result is the message \"The path is valid\".</p> </li> <li> <p>Click \"Next\".</p> </li> </ul> </li> <li> <p>Click \"Finish\" then click the button to reload the user interface.</p> </li> </ol>"},{"location":"Containers/Octoprint/#after-the-first-run","title":"after the first run","text":"<p>Use a browser to point to port 9980 on your Raspberry Pi. For example:</p> <pre><code>http://raspberrypi.local:9980\n</code></pre> <p>Supply your user credentials and login.</p>"},{"location":"Containers/Octoprint/#popup-messages","title":"popup messages","text":"<p>OctoPrint will display numerous messages in popup windows. These generally fall into two categories:</p> <ul> <li>Messages that refer to updates; and</li> <li>Messages that refer to other events.</li> </ul> <p>In general, you can ignore messages about updates. You will get all updates automatically the next time the octoprint-docker container is rebuilt and pushed to DockerHub.</p> <p>You can, if you wish, allow an update to proceed. It might be appropriate to do that if you want to test an update. Just be aware that:</p> <ol> <li>Updates are ephemeral and will disappear the next time the Octoprint container is created.</li> <li>Updates can change the structure of the persistent storage area in a way which can't be undone, and which may prevent the Octoprint container from starting the next time it is created. In other words, if you want to trial an update, take a backup of OctoPrint's persistent storage area first.</li> </ol>"},{"location":"Containers/Octoprint/#restarting-the-octoprint-container","title":"restarting the OctoPrint container","text":"<p>You can restart the OctoPrint service in two ways:</p> <ul> <li>via the Raspberry Pi command line; or</li> <li>via the OctoPrint user interface.</li> </ul> <p>Whichever method you choose will result in a refresh of the OctoPrint user interface and you will need to follow the prompts to reload your browser page.</p>"},{"location":"Containers/Octoprint/#restarting-via-the-command-line","title":"restarting via the command line","text":"<p>Run the following commands:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart octoprint\n</code></pre>"},{"location":"Containers/Octoprint/#restarting-via-octoprint-user-interface","title":"restarting via OctoPrint user interface","text":"<p>From the \"System\" icon in the OctoPrint toolbar (looks like a power button symbol):</p> <ol> <li>Choose \"Restart OctoPrint\".</li> </ol> <p>Note:</p> <ul> <li> <p>If you do not see the \"System\" icon in the toolbar, fix it line this:</p> <ol> <li>Click the \"Settings\" icon (looks like a wrench) in the OctoPrint toolbar.</li> <li>Choose \"Server\".</li> <li> <p>Enter the following into the \"Restart OctoPrint\" field:</p> <pre><code>s6-svc -r /var/run/s6/services/octoprint\n</code></pre> </li> <li> <p>Click \"Save\".</p> </li> </ol> </li> </ul>"},{"location":"Containers/Octoprint/#stopping-the-octoprint-container","title":"stopping the OctoPrint container","text":"<p>Unless you intend to leave your printer switched on 24 hours a day, you will also need to be careful when you switch off the printer:</p> <ol> <li> <p>Terminate the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop octoprint\n$ docker-compose rm -f octoprint\n</code></pre> </li> <li> <p>Turn the 3D printer off.</p> </li> </ol> <p>If you turn the printer off without terminating the container, you will crash the container.</p>"},{"location":"Containers/Octoprint/#video-feed-built-in-camera-interface","title":"Video feed (built-in camera interface)","text":"<p>You can view the video feed independently of the OctoPrint web interface like this:</p> <pre><code>http://raspberrypi.local:9980/webcam/?action=stream\n</code></pre>"},{"location":"Containers/Octoprint/#silencing-the-security-warning","title":"Silencing the security warning","text":"<p>OctoPrint assumes it is running \"natively\" rather than in a container. From a data-communications perspective, OctoPrint (the process running inside the OctoPrint container) sees itself as running on a computer attached to the internal Docker network. When you connect to OctoPrint's web interface from a client device attached to an external network, OctoPrint sees that your source IP address is not on the internal Docker network and it issues a security warning.</p> <p>To silence the warning:</p> <ol> <li> <p>Terminate the container if it is running:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop octoprint\n$ docker-compose rm -f octoprint\n</code></pre> </li> <li> <p>use <code>sudo</code> and your favourite text editor to open the following file:</p> <pre><code>~/IOTstack/volumes/octoprint/octoprint/config.yaml\n</code></pre> </li> <li> <p>Implement the following pattern:</p> <pre><code>server:\n  \u2026\n  ipCheck:\n    enabled: true\n    trustedSubnets:\n    - 203.0.132.0/24\n</code></pre> <p>Notes:</p> <ul> <li>The <code>server:</code>, <code>ipCheck:</code> and <code>enabled:</code> directives may already be in place but the <code>trustedSubnets:</code> directive may not be. Add it, and then add your local subnet(s) where you see the \"192.168.1.0/24\" example.</li> <li>Remember to use spaces in YAML files. Do not use tabs.</li> </ul> </li> <li> <p>Save the file.</p> </li> <li> <p>Bring up the container: </p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d octoprint\n</code></pre> </li> </ol>"},{"location":"Containers/Octoprint/#routine-container-maintenance","title":"Routine container maintenance","text":"<p>You can check for updates like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull octoprint\n$ docker-compose up -d octoprint\n$ docker system prune\n</code></pre>"},{"location":"Containers/Octoprint/#if-you-forget-your-username-and-password","title":"If you forget your username and password","text":"<p>You can view a list of usernames like this:</p> <pre><code>$ docker exec octoprint octoprint --basedir /octoprint/octoprint user list\n</code></pre> <p>To reset a user's password:</p> <ol> <li> <p>Use the following line as a template and replace <code>\u00abusername\u00bb</code> and <code>\u00abpassword\u00bb</code> with appropriate values:</p> <pre><code>$ docker exec octoprint octoprint --basedir /octoprint/octoprint user password --password \u00abpassword\u00bb \u00abusername\u00bb\n</code></pre> </li> <li> <p>Execute the edited command. For example, to set the password for user \"me\" to \"verySecure\":</p> <pre><code>$ docker exec octoprint octoprint --basedir /octoprint/octoprint user password --password verySecure me\n</code></pre> </li> <li> <p>Restart OctoPrint:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart octoprint\n</code></pre> </li> </ol> <p>Note:</p> <ul> <li> <p>OctoPrint supports more than one username. To explore the further:</p> <pre><code>$ docker exec octoprint octoprint --basedir /octoprint/octoprint user --help\n</code></pre> </li> </ul>"},{"location":"Containers/Octoprint/#if-all-else-fails","title":"If all else fails\u2026","text":"<p>If the OctoPrint container seems to be misbehaving, you can get a \"clean slate\" by:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop octoprint\n$ docker-compose rm -f octoprint\n$ sudo rm -rf ./volumes/octoprint\n$ docker-compose up -d octoprint\n</code></pre> <p>The OctoPrint container is well-behaved and will re-initialise its persistent storage area correctly. OctoPrint will adopt \"first run\" behaviour and display the Setup Wizard.</p>"},{"location":"Containers/OpenHab/","title":"openHAB","text":""},{"location":"Containers/OpenHab/#references","title":"References","text":"<ul> <li>DockerHub</li> <li>GitHub</li> <li>openHAB website</li> </ul> <p>openHAB runs in \"host mode\" so there are no port mappings. The default port bindings on IOTstack are:</p> <ul> <li>4050 - the HTTP port of the web interface (instead of 8080)</li> <li>4051 - the HTTPS port of the web interface (instead of 8443)</li> <li>8101 - the SSH port of the Console (since openHAB 2.0.0)</li> <li>5007 - the LSP port for validating rules (since openHAB 2.2.0)</li> </ul> <p>If you want to change either of the first two:</p> <ol> <li> <p>Edit the <code>openhab</code> fragment in <code>docker-compose.yml</code>:</p> <pre><code>    - OPENHAB_HTTP_PORT=4050\n    - OPENHAB_HTTPS_PORT=4051\n</code></pre> </li> <li> <p>Recreate the openHAB container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d openhab\n</code></pre> </li> </ol> <p>There do not appear to be any environment variables to control ports 8101 or 5007 so, if other containers you need to run also depend on those ports, you will have to figure out some way of resolving the conflict.</p> <p>Note:</p> <ul> <li> <p>The original IOTstack documentation included:</p> <p>openHAB has been added without Amazon Dashbutton binding.</p> <p>but it is not clear if this is still the case.</p> </li> <li> <p>Amazon Dashbuttons have been discontinued so this may no longer be relevant.</p> </li> </ul>"},{"location":"Containers/PgAdmin4/","title":"pgAdmin4","text":""},{"location":"Containers/PgAdmin4/#references","title":"References","text":"<ul> <li>Docker Hub</li> <li>GitHub</li> <li>pgAdmin4 home page</li> </ul>"},{"location":"Containers/PgAdmin4/#about","title":"About","text":"<p>pgAdmin4 is a graphical user interface to PostgreSQL.</p>"},{"location":"Containers/PgAdmin4/#configuration","title":"Configuration","text":""},{"location":"Containers/PgAdmin4/#runtime-image","title":"Runtime image","text":"<p>The service definition includes the following lines:</p> <pre><code>  image: gpongelli/pgadmin4-arm:latest-armv7\n  platform: linux/arm/v7\n# image: gpongelli/pgadmin4-arm:latest-armv8\n</code></pre> <p>The ARMv7 image is enabled by default. This will run on both 32-bit (ARMv7) and 64-bit (ARMv8) systems. The <code>platform</code> clause silences warnings from docker-compose that arise when you try to run an ARMv7 image on ARMv8 architecture.</p> <p>If you are running on a full 64-bit system, you should edit your service definition so that it looks like this:</p> <pre><code># image: gpongelli/pgadmin4-arm:latest-armv7\n# platform: linux/arm/v7\n  image: gpongelli/pgadmin4-arm:latest-armv8\n</code></pre>"},{"location":"Containers/PgAdmin4/#container-time-zone","title":"Container Time Zone","text":"<p>The service definition includes the <code>TZ</code> environment variable. It defaults to <code>Etc/UTC</code>. You can either edit the environment variable directly in your compose file, or provide your own substitute by editing <code>~/IOTstack/.env</code>. Example:</p> <pre><code>$ cat ~/IOTstack/.env\nTZ=Australia/Sydney\n</code></pre>"},{"location":"Containers/PgAdmin4/#first-run","title":"First run","text":"<p>These instructions assume you have selected the <code>postgresql</code> container from the IOTstack menu, and that that container is running.</p> <p>Complete the following steps:</p> <ol> <li> <p>Use your web browser to connect to pgAdmin4 on port <code>5050</code>. For example:</p> <ul> <li><code>http://raspberrypi.local:5050</code></li> </ul> <p>The pgAdmin4 service takes a while to start so please be patient if you have only just launched the container. Once your browser is able to connect to pgAdmin4 successfully, the home screeen will be displayed, overlaid with a prompt to enter a master password:</p> <p></p> </li> <li> <p>Enter a master password.</p> </li> <li>Click \"OK\" to set the master password. The dialog will disappear leaving the home screen.</li> <li> <p>Click \"Add New Server\". This displays the server registration sheet:</p> <p></p> </li> <li> <p>Give the server a name. The name is not important. It just needs to be meaningful to you.</p> </li> <li> <p>Click the \"Connection\" tab:</p> <p></p> </li> <li> <p>Enter the name of the PostgreSQL container (ie \"postgres\").</p> </li> <li>The default port is 5432. This is the internal port number the PostgreSQL container is listening on. It is unlikely that you will need to change this.</li> <li>In the \"Maintenance database\" field, enter the value of the <code>POSTGRES_DB</code> environment variable as it applies to the PostgreSQL container.</li> <li>In the \"Username\" field, enter the value of the <code>POSTGRES_USER</code> environment variable as it applies to the PostgreSQL container.</li> <li>In the \"Password\" field, enter the value of the <code>POSTGRES_PASSWORD</code> environment variable as it applies to the PostgreSQL container.</li> <li>Enable the \"Save password\" switch if you think that is appropriate.</li> <li>Click the \"Save\" button.</li> </ol> <p>Keep in mind that the values of the environment variables you set in steps 9, 10 and 11 only apply the first time you launch the PostgreSQL container. If you change any of these in PostgreSQL, you will have to make matching changes in pgAdmin4.</p>"},{"location":"Containers/Pi-hole/","title":"Pi-hole","text":"<p>Pi-hole is a fantastic utility to reduce ads.</p>"},{"location":"Containers/Pi-hole/#references","title":"References","text":"<ul> <li>Pi-hole on GitHub</li> <li>Pi-hole on Dockerhub</li> <li>Pi-hole environment variables</li> </ul>"},{"location":"Containers/Pi-hole/#envVars","title":"Environment variables","text":"<p>In conjunction with controls in Pi-hole's web GUI, environment variables govern much of Pi-hole's behaviour.</p> <p>If you are running new menu (master branch), environment variables are inline in your compose file. If you are running old menu, the variables will be in:</p> <pre><code>~/IOTstack/services/pihole/pihole.env\n</code></pre> <p>There is nothing about old menu which requires the variables to be stored in the <code>pihole.env</code> file. You can migrate everything to <code>docker-compose.yml</code> if you wish.</p> <p>Pi-hole's authoritative list of environment variables can be found here. Although many of Pi-hole's options can be set through its web GUI, there are two key advantages to using environment variables:</p> <ol> <li>If you ever need to reset Pi-hole by erasing its persistent storage area, configuration options set using environment variables will persist while those set through the GUI may be lost; and</li> <li>On at least two occasions in its history, Pi-hole upgrades have had the effect of wiping configuration options set through the GUI, whereas options set using environment variables survived. </li> </ol>"},{"location":"Containers/Pi-hole/#adminPassword","title":"Admin password","text":"<p>By default, Pi-hole does not have an administrator password. That is because the default service definition provided by IOTstack contains the following environment variable with no value on its right hand side:</p> <pre><code>- WEBPASSWORD=\n</code></pre> <p>Each time the Pi-hole container is launched, it checks for the presence or absence of the <code>WEBPASSWORD</code> environment variable, then reacts like this:</p> <ul> <li> <p>If <code>WEBPASSWORD</code> is defined but does not have a value:</p> <ul> <li>No admin password is set;</li> <li>Any previous admin password is cleared;</li> <li>You will be able to connect to Pi-hole's web interface without providing a password (you won't even see the login screen); and</li> <li>The main menu (\u2261) will not contain a logout command.</li> </ul> <p>This is the default situation for IOTstack.</p> </li> <li> <p>If <code>WEBPASSWORD</code> is defined and has a value, that value will become the admin password. For example, to change your admin password to be \"IOtSt4ckP1Hol3\":</p> <ol> <li> <p>Edit your compose file so that Pi-hole's service definition contains:</p> <pre><code>- WEBPASSWORD=IOtSt4ckP1Hol3\n</code></pre> </li> <li> <p>Run:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d pihole\n</code></pre> <p>docker-compose will notice the change to the environment variable and re-create the container. The container will see that <code>WEBPASSWORD</code> has a value and will change the admin password to \"IOtSt4ckP1Hol3\".</p> <p>You will be prompted for a password whenever you connect to Pi-hole's web interface.</p> </li> </ol> </li> <li> <p>If <code>WEBPASSWORD</code> is undefined (absent from your compose file), Pi-hole behaves like this:</p> <ul> <li> <p>If this is the first time Pi-hole has been launched, a random password is generated.</p> <p>Pi-hole senses \"first launch\" if it has to initialise its persistent storage area. See also getting a clean slate. You can discover the password by running:</p> <pre><code>$ docker logs pihole | grep random\n</code></pre> <p>Remember, docker logs are cleared each time a container is terminated or re-created so you need to run that command before the log disappears!</p> </li> <li> <p>Otherwise, whatever password was set on the previous launch will be re-used.</p> </li> </ul> </li> </ul>"},{"location":"Containers/Pi-hole/#adminPassChange","title":"about <code>pihole -a -p</code>","text":"<p>Some Pi-hole documentation on the web recommends using the following command to change Pi-hole's admin password:</p> <pre><code>$ docker exec pihole pihole -a -p \u00abyourPasswordHere\u00bb\n</code></pre> <p>That command works but its effect will always be overridden by <code>WEBPASSWORD</code>. For example, suppose your service definition contains:</p> <pre><code>- WEBPASSWORD=myFirstPassword\n</code></pre> <p>When you start the container, the admin password will be \"myFirstPassword\". If you run:</p> <pre><code>$ docker exec pihole pihole -a -p mySecondPassword\n</code></pre> <p>then \"mySecondPassword\" will become the admin password until the next time the container is re-created by docker-compose, at which point the password will be reset to \"myFirstPassword\".</p> <p>Given this behaviour, we recommend that you ignore the <code>pihole -a -p</code> command.</p>"},{"location":"Containers/Pi-hole/#loggingVar","title":"Logging","text":"<p>You can control the amount of information Pi-hole retains about your DNS queries using the \"Privacy Settings\" tab of the \"Settings\" group. The default is \"Show &amp; record everything\".</p> <p>If you choose any option except \"Anonymous mode\", then Pi-hole divides the logging store into two parts:</p> <ul> <li>Entries which are more recent than 24 hours; and</li> <li>Entries which are older than 24 hours.</li> </ul> <p>In the \"System\" tab of the \"Settings\" group is a Flush logs (last 24 hours) button. Clicking that button erases all log entries which are more recent than 24 hours. The button does not erase entries which are older than 24 hours.</p> <p>Retention of log entries older than 24 hours is controlled by the following environment variable:</p> <pre><code>- FTLCONF_MAXDBDAYS=365\n</code></pre> <p>The default (which applies if the variable is omitted) is to retain log entries for 365 days.</p> <p>Depending on your DNS activity, the database where the log entries are stored can become quite large. Setting this variable to a shorter period will help you control the amount of storage Pi-hole consumes on disk and in your backups.</p> <p>Tip:</p> <ul> <li> <p>Adding this variable to an existing service definition, or changing the number of days to be less than the previous setting will not reduce the size of the logging database. Although Pi-hole will implement the change, the SQLite database where the logs are written retains the released storage for subsequent re-use. If you want to reclaim that space, run the following command:   </p> <pre><code>$ sqlite3 ~/IOTstack/volumes/pihole/etc-pihole/pihole-FTL.db \"vacuum;\"\n</code></pre> <p>The command should not need <code>sudo</code> because <code>pi</code> is the owner by default. There is no need to terminate Pi-hole before running this command (SQLite handles any contention).</p> </li> </ul>"},{"location":"Containers/Pi-hole/#upstreamDNS","title":"Recursive resolvers","text":"<p>You can control which public DNS servers are used by PiHole when it needs to refer queries to the Internet. You do this by enabling or disabling checkboxes in the \"Upstream DNS Servers\" panel of the \"DNS\" tab in the \"Settings\" group.</p> <p>The default is to use the two Google IPv4 DNS servers which correspond with 8.8.8.8 and 8.8.4.4, respectively.</p> <p>An alternative to toggling checkboxes in the Pi-hole GUI is to use an environment variable:</p> <pre><code>- PIHOLE_DNS_=8.8.8.8;8.8.4.4\n</code></pre> <p>The variable does end with an underscore!</p> <p>This variable takes a semi-colon-separated list of DNS servers. You can discover the IP address associated with a checkbox by hovering your mouse pointer over the checkbox and waiting for a tool-tip to appear:</p> <p></p>"},{"location":"Containers/Pi-hole/#advancedVars","title":"Advanced variables","text":"(advanced) reverse DNS query handling <p>First, understand that there are two basic types of DNS query:</p> <ul> <li> <p>forward queries:</p> <ul> <li>question: \"what is the IP address of fred.yourdomain.com?\"</li> <li>answer: 192.168.1.100</li> </ul> </li> <li> <p>reverse queries:</p> <ul> <li>question: \"what is the domain name for 192.168.1.100?\"</li> <li>answer: fred.yourdomain.com</li> </ul> </li> </ul> <p>Pi-hole has its own built-in DNS server which can answer both kinds of queries. The implementation is useful but doesn't offer all the features of a full-blown DNS server like BIND9. If you decide to implement a more capable DNS server to work alongside Pi-hole, you will need to understand the following Pi-hole environment variables:</p> <ul> <li> <p><code>REV_SERVER=</code></p> <p>If you configure Pi-hole's built-in DNS server to be authoritative for your local domain name, <code>REV_SERVER=false</code> is appropriate, in which case none of the variables discussed below has any effect.</p> <p>Setting <code>REV_SERVER=true</code> allows Pi-hole to forward queries that it can't answer to a local upstream DNS server, typically running inside your network.</p> </li> <li> <p><code>REV_SERVER_DOMAIN=yourdomain.com</code> (where \"yourdomain.com\" is an example)</p> <p>The Pi-hole documentation says:</p> <p>\"If conditional forwarding is enabled, set the domain of the local network router\".</p> <p>The words \"if conditional forwarding is enabled\" mean \"when <code>REV_SERVER=true</code>\".</p> <p>However, this option really has little-to-nothing to do with the \"domain of the local network router\". Your router may have an IP address that reverse-resolves to a local domain name (eg gateway.mydomain.com) but this is something most routers are unaware of, even if you have configured your router's DHCP server to inform clients that they should assume a default domain of \"yourdomain.com\".</p> <p>This variable actually tells Pi-hole the name of your local domain. In other words, it tells Pi-hole to consider the possibility that an unqualified name like \"fred\" could be the fully-qualified domain name \"fred.yourdomain.com\".</p> </li> <li> <p><code>REV_SERVER_TARGET=192.168.1.5</code> (where 192.168.1.5 is an example):</p> <p>The Pi-hole documentation says:</p> <p>\"If conditional forwarding is enabled, set the IP of the local network router\".</p> <p>This option tells Pi-hole where to direct forward queries that it can't answer. In other words, Pi-hole will send a forward query for fred.yourdomain.com to 192.168.1.5.</p> <p>It may be appropriate to set <code>REV_SERVER_TARGET</code> to the IP address of your router (eg 192.168.1.1) but, unless your router is running as a DNS server (not impossible but uncommon), the router will likely just relay any queries to your ISP's DNS servers (or other well-known DNS servers like 8.8.8.8 or 1.1.1.1 if you have configured those). Those external DNS servers are unlikely to be able to resolve queries for names in your private domain, and won't be able to do anything sensible with reverse queries if your home network uses RFC1918 addressing (which most do: 192.168.x.x being the most common example).</p> <p>Forwarding doesn't guarantee that 192.168.1.5 will be able to answer the query. The DNS server at 192.168.1.5 may well relay the query to yet another server. In other words, this environment variable does no more than set the next hop.</p> <p>If you are planning on using this option, the target needs to be a DNS server that is authoritative for your local domain and that, pretty much, is going to be a local upstream DNS server inside your home network like another Raspberry Pi running BIND9.</p> </li> <li> <p><code>REV_SERVER_CIDR=192.168.1.0/24</code> (where 192.168.1.0/24 is an example)</p> <p>The Pi-hole documentation says:</p> <p>\"If conditional forwarding is enabled, set the reverse DNS zone (e.g. 192.168.0.0/24)\".</p> <p>This is correct but it lacks detail.</p> <p>The string \"192.168.1.0/24\" defines your local subnet using Classless Inter-Domain Routing (CIDR) notation. Most home subnets use a subnet-mask of 255.255.255.0. If you write that out in binary, it is 24 1-bits followed by 8 0-bits, as in:</p> <pre><code>   255  .   255  .   255  .   0\n11111111 11111111 11111111 00000000\n</code></pre> <p>Those 24 one-bits are where the <code>/24</code> comes from in <code>192.168.1.0/24</code>. When you perform a bitwise logical AND between that subnet mask and 192.168.1.0, the \".0\" is removed (conceptually), as in:</p> <pre><code>192.168.1.0 AND 255.255.255.0 = 192.168.1\n</code></pre> <p>What it means is:</p> <ol> <li>The network prefix is \"192.168.1\".</li> <li>This host on the 192.168.1 network is the reserved address \"192.168.1.0\". It is better to think of this as \"the network prefix followed by all-zero bits in the host portion\". It is not common to see the .0 address used in practice. A device either knows its IP address or it doesn't. If it doesn't then it won't know its prefix so it will use 0.0.0.0 as a substitute for \"this\".</li> <li>The range of IP addresses available for allocation to hosts on this subnet is 192.168.1.1 through 192.168.1.254 inclusive.</li> <li>All hosts on the 192.168.1 network (ie broadcast) is the reserved address \"192.168.1.255\". It is better to think of this as \"the network prefix followed by all-one bits in the host portion\".</li> </ol> <p>When you set <code>REV_SERVER_CIDR=192.168.1.0/24</code> you are telling Pi-hole that reverse queries for the host range 192.168.1.1 through 192.168.1.254 should be sent to the <code>REV_SERVER_TARGET=192.168.1.5</code>.</p> </li> </ul>"},{"location":"Containers/Pi-hole/#webGUI","title":"Pi-hole Web GUI","text":"<p>Note: in order for Web GUI settings to have any effects, you need to configure the RPi or other machines to use it. This is described in the next topics.</p>"},{"location":"Containers/Pi-hole/#connectGUI","title":"Connecting to the GUI","text":"<p>Point your browser to:</p> <pre><code>http://\u00abyour_ip\u00bb:8089/admin\n</code></pre> <p>where \u00abyour_ip\u00bb can be:</p> <ul> <li>The IP address of the Raspberry Pi running Pi-hole.</li> <li>The domain name of the Raspberry Pi running Pi-hole.</li> <li>The multicast DNS name (eg \"raspberrypi.local\") of the Raspberry Pi running Pi-hole.</li> </ul>"},{"location":"Containers/Pi-hole/#localNames","title":"Adding local domain names","text":"<p>Login to the Pi-hole web interface: <code>http://raspberrypi.local:8089/admin</code>:</p> <ol> <li>Select from Left menu: Local DNS -&gt; DNS Records</li> <li>Enter Domain: <code>raspberrypi.home.arpa</code> and the RPi's IP Address, e.g. <code>192.168.1.10</code>.</li> <li>Press Add.</li> </ol> <p>Now you can use <code>raspberrypi.home.arpa</code> as the domain name for the Raspberry Pi in your whole local network. You can also add domain names for your other devices, provided they too have static IPs.</p> <p>why .home.arpa?</p> <p>Instead of <code>.home.arpa</code> - which is the real standard, but a mouthful - you can use <code>.internal</code>. Using <code>.local</code> would technically work, but it should be reserved for mDNS use only.</p>"},{"location":"Containers/Pi-hole/#rpiDNS","title":"Configure your Pi to use Pi-hole","text":"<p>The Raspberry Pi itself does not have to use the Pi-hole container for its own DNS services. Some chicken-and-egg situations can exist if, for example, the Pi-hole container is down when another process (eg <code>apt</code> or <code>docker-compose</code>) needs to do something that depends on DNS services being available.</p> <p>Nevertheless, if you configure Pi-hole to be local DNS resolver, then you will probably want to configure your Raspberry Pi to use the Pi-hole container in the first instance, and then fall back to a public DNS server if the container is down. As a beginner, this is probably what you want regardless. Do this by running the commands:</p> <pre><code>$ echo \"name_servers=127.0.0.1\" | sudo tee -a /etc/resolvconf.conf\n$ echo \"name_servers_append=8.8.8.8\" | sudo tee -a /etc/resolvconf.conf\n$ echo \"resolv_conf_local_only=NO\" | sudo tee -a /etc/resolvconf.conf\n$ sudo resolvconf -u\n</code></pre> <p>This results in a configuration that will continue working, even if the Pi-hole container isn't running.</p> Detailed explanations of these commands <ol> <li> <p><code>name_servers=127.0.0.1</code> instructs the Raspberry Pi to direct DNS queries to the loopback address. Port 53 is implied. If the Pi-hole container is running in:</p> <ul> <li>non-host mode, Docker is listening to port 53 and forwards the queries to the Pi-hole container;</li> <li>host mode, the Pi-hole container is listening to port 53.</li> </ul> </li> <li> <p><code>name_servers_append=8.8.8.8</code> instructs the Raspberry Pi to fail-over to 8.8.8.8 if Pi-hole does not respond. You can replace <code>8.8.8.8</code> (a Google service) with:</p> <ul> <li>Another well-known public DNS server like <code>1.1.1.1</code> (Cloudflare).</li> <li>The IP address(es) of your ISP's DNS hosts (generally available from your ISP's web site).</li> <li>The IP address of another DNS server running in your local network (eg BIND9).</li> <li>The IP address of your home router. Most home routers default to the ISP's DNS hosts but you can usually change your router's configuration to bypass your ISP in favour of public servers like 8.8.8.8 and 1.1.1.1.</li> </ul> <p>You need slightly different syntax if you want to add multiple fallback servers. For example, suppose your fallback hosts are a local server (eg 192.168.1.2) running BIND9 and 8.8.8.8. The command would be:</p> <pre><code>$ echo 'name_servers_append=\"192.168.1.2 8.8.8.8\"' | sudo tee -a /etc/resolvconf.conf\n</code></pre> </li> <li> <p><code>resolv_conf_local_only=NO</code> is needed so that 127.0.0.1 and 8.8.8.8 can coexist.</p> </li> <li>The <code>resolvconf -u</code> command instructs Raspberry Pi OS to rebuild the active resolver configuration. In principle, that means parsing <code>/etc/resolvconf.conf</code> to derive <code>/etc/resolv.conf</code>. This command can sometimes return the error \"Too few arguments\". You should ignore that error.</li> </ol> <pre><code>flowchart LR\n  RERECONF[\"/etc/resolvconf.conf\"] --- UP([resolvconf -u])\n  DHCP[DHCP provided DNS-server] --- UP\n  UP -- \"generates\" --&gt; RECONF[\"/etc/resolv.conf\"]\n  classDef command fill:#9996,stroke-width:0px\n  class UP command</code></pre> Advanced options: ignoring DHCP provided DNS-servers, local domain name search <ul> <li> <p>If you wish to prevent the Raspberry Pi from including the address(es) of DNS servers learned from DHCP, you can instruct the DHCP client running on the Raspberry Pi to ignore the information coming from the DHCP server:</p> <pre><code>$ echo 'nooption domain_name_servers' | sudo tee -a /etc/dhcpcd.conf\n$ sudo service dhcpcd reload\n$ sudo resolvconf -u\n</code></pre> </li> <li> <p>If you have followed the steps in Adding local domain names to define names for your local hosts, you can inform the Raspberry Pi of that fact like this:</p> <pre><code>$ echo 'search_domains=home.arpa' | sudo tee -a /etc/resolvconf.conf\n$ sudo resolvconf -u\n</code></pre> <p>That will add the following line to <code>/etc/resolv.conf</code>:</p> <pre><code>search home.arpa\n</code></pre> <p>Then, when you refer to a host by a short name (eg \"fred\") the Raspberry Pi will also consider \"fred.home.arpa\" when trying to discover the IP address.</p> </li> </ul> Interaction with other containers <p>Docker provides a special IP 127.0.0.11, which listens to DNS queries and resolves them according to the host RPi's resolv.conf. Containers usually rely on this to perform DNS lookups. This is nice as it won't present any surprises as DNS lookups on both the host and in the containers will yeild the same results.</p> <p>It's possible to make DNS queries directly cross-container, and even supported in some rare use-cases.</p>"},{"location":"Containers/Pi-hole/#using-pi-hole-as-your-local-dns","title":"Using Pi-hole as your local DNS","text":"<p>To use the Pi-hole in your LAN, you need to assign the Raspberry Pi a fixed IP-address and configure this IP as your DNS server.</p>"},{"location":"Containers/Pi-hole/#rpiFixedIP","title":"Fixed IP address for Pi-hole","text":"<p>If you want clients on your network to use Pi-hole for their DNS, the Raspberry Pi running Pi-hole must have a fixed IP address. It does not have to be a static IP address (in the sense of being hard-coded into the Raspberry Pi). The Raspberry Pi can still obtain its IP address from DHCP at boot time, providing your DHCP server (usually your home router) always returns the same IP address. This is usually referred to as a static binding and associates the Raspberry Pi's MAC address with a fixed IP address.</p> <p>Keep in mind that many Raspberry Pis have both Ethernet and WiFi interfaces. It is generally prudent to establish static bindings for both network interfaces in your DHCP server.</p> <p>You can use the following command to discover the MAC addresses for your Raspberry Pi's Ethernet and WiFi interfaces:</p> <pre><code>$ for I in eth0 wlan0 ; do ip link show $I ; done\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000\n    link/ether dc:a6:32:4c:89:f9 brd ff:ff:ff:ff:ff:ff\n3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000\n    link/ether e5:4f:01:41:88:b2 brd ff:ff:ff:ff:ff:ff\n</code></pre> <p>In the above:</p> <ul> <li>The MAC address of the Ethernet interface is \"dc:a6:32:4c:89:f9\"</li> <li>The MAC address of the WiFi interface is \"e5:4f:01:41:88:b2\"</li> </ul> <p>If a physical interface does not exist, the command returns \"Device does not exist\" for that interface. If you prefer, you can also substitute the <code>ifconfig</code> command for <code>ip link show</code>. It's just a little more wordy.</p>"},{"location":"Containers/Pi-hole/#rpiConfig","title":"Configure clients to use Pi-hole","text":"<p>In order for Pi-hole to block ads or resolve anything, clients need to be told to use it as their DNS server. You can either:</p> <ol> <li>Adopt a whole-of-network approach and edit the DNS settings in your DHCP server so that all clients are given the IP address of the Raspberry Pi running Pi-hole to use for DNS services when a lease is issued.</li> <li>Adopt a case-by-case (manual) approach where you instruct particular clients to obtain DNS services from the IP address of the Raspberry Pi running Pi-hole.</li> </ol> <p>Option 1 (whole-of-network) is the simplest approach. Assuming your Raspberry Pi has the static IP <code>192.168.1.10</code>:</p> <ol> <li> <p>Go to your network's DHCP server. In most home networks, this will be your Wireless Access Point/WLAN Router:</p> <ul> <li>Login into its web-interface</li> <li>Find where DNS servers are defined (generally with DHCP controls)</li> <li>Change all DNS fields to <code>192.168.1.10</code></li> </ul> </li> <li> <p>All local clients have to be rebooted. Without this they will continue to use the old DNS setting from an old DHCP lease for quite some time.</p> </li> </ol> <p>Option 2 (case-by-case) generally involves finding the IP configuration options for each host and setting the DNS server manually. Manual changes are usually effective immediately without needing a reboot.</p> advanced configurations <p>Setting up a combination of Pi-hole (for ad-blocking services), and/or a local upstream DNS resolver (eg BIND9) to be authoritative for a local domain and reverse-resolution for your local IP addresses, and decisions about where each DNS server forwards queries it can't answer (eg your ISP's DNS servers, or Google's 8.8.8.8, or Cloudflare's 1.1.1.1) is a complex topic and depends on your specific needs.</p> <p>The same applies to setting up a DHCP server (eg DHCPD) which is capable of distinguishing between the various clients on your network (ie by MAC address) to make case-by-case decisions as to where each client should obtain its DNS services. </p> <p>If you need help, try asking questions on the IOTstack Discord channel.</p>"},{"location":"Containers/Pi-hole/#debugging","title":"Testing and Troubleshooting","text":"<p>Make these assumptions:</p> <ol> <li> <p>You have followed the instructions above to add these lines to <code>/etc/resolvconf.conf</code>:</p> <pre><code>name_servers=127.0.0.1\nname_servers_append=8.8.8.8\nresolv_conf_local_only=NO\n</code></pre> </li> <li> <p>The Raspberry Pi running Pi-hole has the IP address 192.168.1.10 which it obtains as a static assignment from your DHCP server.</p> </li> <li>You have configured your DHCP server to provide 192.168.1.10 for client devices to use to obtain DNS services (ie, you are saying clients should use Pi-hole for DNS).</li> </ol> <p>The result of the configuration appears in <code>/etc/resolv.conf</code>:</p> <pre><code>$ cat /etc/resolv.conf\n# Generated by resolvconf\nnameserver 127.0.0.1\nnameserver 192.168.1.10\nnameserver 8.8.8.8\n</code></pre> <p>Interpretation:</p> <ul> <li><code>nameserver 127.0.0.1</code> is present because of <code>name_servers=127.0.0.1</code></li> <li><code>nameserver 192.168.1.10</code> is present because it was learned from DHCP</li> <li><code>nameserver 8.8.8.8</code> is present because of <code>name_servers_append=8.8.8.8</code></li> </ul> <p>The fact that the Raspberry Pi is effectively represented twice (once as 127.0.0.1, and again as 192.168.1.10) does not matter. If the Pi-hole container stops running, the Raspberry Pi will bypass 192.168.1.10 and fail over to 8.8.8.8, failing back to 127.0.0.1 when the Pi-hole container starts again.</p> <p>Install dig:</p> <pre><code>$ sudo apt install dnsutils\n</code></pre> <p>Test that Pi-hole is correctly configured (should respond 192.168.1.10):</p> <pre><code>$ dig raspberrypi.home.arpa @192.168.1.10\n</code></pre> <p>To test on another machine if your network's DNS configuration is correct, and an ESP will resolve its DNS queries correctly, restart the other machine to ensure DNS changes are updated and then use:</p> <pre><code>$ dig raspberrypi.home.arpa\n</code></pre> <p>This should produce the same result as the previous command.</p> <p>If this fails to resolve the IP, check that the server in the response is <code>192.168.1.10</code>. If it's <code>127.0.0.xx</code> check <code>/etc/resolv.conf</code> begins with <code>nameserver 192.168.1.10</code>. If not, check the machine is configured to use DHCP and revisit Pi-hole as DNS.</p>"},{"location":"Containers/Pi-hole/#iotConfig","title":"Microcontrollers","text":"<p>If you want to avoid hardcoding your Raspberry Pi IP to your ESPhome devices, you need a DNS server that will do the resolving. This can be done using the Pi-hole container as described above.</p>"},{"location":"Containers/Pi-hole/#esp32mDNS","title":"<code>*.local</code> won't work for ESPhome","text":"<p>There is a special case for resolving <code>*.local</code> addresses. If you do a <code>ping raspberrypi.local</code> on your desktop Linux or the Raspberry Pi, it will first try using mDNS/bonjour to resolve the IP address raspberrypi.local. If this fails it will then ask the DNS server. ESPhome devices can't use mDNS to resolve an IP address. You need a proper DNS server to respond to queries made by an ESP. As such, <code>dig raspberrypi.local</code> will fail, simulating ESPhome device behavior. This is as intended, and you should use raspberrypi.home.arpa as the address on your ESP-device.</p>"},{"location":"Containers/Pi-hole/#cleanSlate","title":"Getting a clean slate","text":"<p>If Pi-hole misbehaves, you can always try starting from a clean slate by erasing Pi-hole's persistent storage area. Erasing the persistent storage area causes PiHole to re-initialise its data structures on the next launch. You will lose:</p> <ol> <li>Any configuration options you may have set via the web GUI that are not otherwise reflected in environment variables.</li> <li>Any whitelist, blacklist or local DNS records you entered.</li> <li>All DNS resolution and blocking history.</li> </ol> <p>Also note that your administrative password will reset.</p> <p>The recommended approach is:</p> <ol> <li>Login to Pi-hole's web GUI and navigate to Settings \u00bb Teleporter.</li> <li>Click the Backup button to download a backup.</li> <li>Logout of the Web GUI.</li> <li> <p>Run the following commands:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down pihole\n$ sudo rm -rf ./volumes/pihole\n$ docker-compose up -d pihole\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Login to Pi-hole's web GUI and navigate to Settings \u00bb Teleporter.</p> </li> <li>Use the checkboxes to select the settings you wish to restore, and click the Browse and Restore buttons.</li> </ol>"},{"location":"Containers/Pi-hole/#dockerDesktop","title":"Docker Desktop","text":"<p>If you run Pi-hole using Docker Desktop for macOS, all client activity will be logged against the IP address of the default gateway on the internal bridged network.</p> <p>It appears that Docker Desktop for macOS interposes an additional level of Network Address Translation (NAT) between clients and the Pi-hole service. This does not affect  Pi-hole's ability to block ads. It just makes the GUI reports a little less useful.</p> <p>It is not known whether this is peculiar to Docker Desktop for macOS or also affects other variants of Docker Desktop.</p> <p>This problem does not affect Pi-hole running in a container on a Raspberry Pi.</p>"},{"location":"Containers/Plex/","title":"Plex","text":""},{"location":"Containers/Plex/#references","title":"References","text":"<ul> <li>Homepage</li> <li>Docker</li> </ul>"},{"location":"Containers/Plex/#web-interface","title":"Web interface","text":"<p>The web UI can be found on <code>\"your_ip\":32400/web</code></p>"},{"location":"Containers/Plex/#mounting-an-external-drive-by-uuid-to-the-home-directory","title":"Mounting an external drive by UUID to the home directory","text":"<p>official mounting guide</p> <p>Create a directory in you home directory called <code>mnt</code> with a subdirectory <code>HDD</code>. Follow the instruction above to mount your external drive to <code>/home/pi/mnt/HDD</code> in you <code>fstab</code> edit your docker-compose.yml file under plex and uncomment the volumes for tv series and movies (modify the path to point to your media locations). Run <code>docker-compose up -d</code> to rebuild plex with the new volumes </p>"},{"location":"Containers/Portainer-agent/","title":"Portainer agent","text":""},{"location":"Containers/Portainer-agent/#references","title":"References","text":"<ul> <li>Docker</li> <li>Docs</li> </ul>"},{"location":"Containers/Portainer-agent/#about","title":"About","text":"<p>The portainer agent is a great way to add a second docker instance to an existing portainer instance. This allows you to manage multiple docker environments from one portainer instance.</p>"},{"location":"Containers/Portainer-agent/#adding-to-an-existing-instance","title":"Adding to an existing instance","text":"<p>When you want to add the agent to an existing portainer instance. </p> <ul> <li>You go to the endpoints tab.</li> <li>Click on <code>Add endpoint</code></li> <li>Select Agent</li> <li>Enter the name of the agent</li> <li>Enter the url of the endpoint <code>ip-of-agent-instance:9001</code></li> <li>Click on add endpoint</li> </ul>"},{"location":"Containers/Portainer-ce/","title":"Portainer CE","text":""},{"location":"Containers/Portainer-ce/#references","title":"References","text":"<ul> <li>Docker</li> <li>Website</li> </ul>"},{"location":"Containers/Portainer-ce/#definitions","title":"Definition","text":"<ul> <li> <p>\"#yourip\" means any of the following:</p> <ul> <li>the IP address of your Raspberry Pi (eg <code>192.168.1.10</code>)</li> <li>the multicast domain name of your Raspberry Pi (eg <code>iot-hub.local</code>)</li> <li>the domain name of your Raspberry Pi (eg <code>iot-hub.mydomain.com</code>) </li> </ul> </li> </ul>"},{"location":"Containers/Portainer-ce/#about","title":"About Portainer CE","text":"<p>Portainer CE (Community Edition) is an application for managing Docker. It is a successor to Portainer. According to the Portainer CE documentation</p> <p>Portainer 1.24.x will continue as a separate code branch, released as portainer/portainer:latest, and will receive ongoing security updates until at least 1st Sept 2021. No new features will be added beyond what was available in 1.24.1.</p> <p>From that it should be clear that Portainer is deprecated and that Portainer CE is the way forward.</p>"},{"location":"Containers/Portainer-ce/#installation","title":"Installing Portainer CE","text":"<p>Run the menu:</p> <pre><code>$ cd ~/IOTstack\n$ ./menu.sh\n</code></pre> <p>Choose \"Build Stack\", select \"Portainer-ce\", press [TAB] then \"\\&lt;Ok&gt;\" and follow through to the end of the menu process, typically choosing \"Do not overwrite\" for any existing services. When the menu finishes:</p> <pre><code>$ docker-compose up -d\n</code></pre> <p>Ignore any message like this:</p> <p>WARNING: Found orphan containers (portainer) for this project \u2026</p>"},{"location":"Containers/Portainer-ce/#firstRun","title":"First run of Portainer CE","text":"<p>In your web browser navigate to <code>#yourip:9000/</code>:</p> <ul> <li>the first screen will suggest a username of \"admin\" and ask for a password. Supply those credentials and click \"Create User\".</li> <li>the second screen will ask you to select a connection method. For IOTstack, \"Docker (Manage the local Docker environment)\" is usually appropriate so click that and then click \"Connect\".</li> </ul> <p>From there, you can click on the \"Local\" group and take a look around. One of the things Portainer CE can help you do is find unused containers but beware of reading too much into this because, sometimes, an \"unused\" container is actually the base for another container (eg Node-RED).</p> <p>There are 'Quick actions' to view logs and other stats. This can all be done from terminal commands but Portainer CE makes it easier. </p>"},{"location":"Containers/Portainer-ce/#setPublicIP","title":"Setting the Public IP address","text":"<p>If you click on a \"Published Port\" in the \"Containers\" list, your browser may return an error saying something like \"can't connect to server\" associated with an IP address of \"0.0.0.0\".</p> <p>To fix that problem, proceed as shown below:</p> <p></p> <ol> <li>Click \"Environments\" in the left hand panel.</li> <li>Click the name \"local\" in the list of Environments.</li> <li>Click in the \"Public IP\" field. Enter one of the following:<ul> <li>The multicast DNS (MDNS) name of your Raspberry Pi (eg <code>iot-hub.local</code>)</li> <li>The fully-qualified domain name (FQDN) of your Raspberry Pi (eg <code>iot-hub.mydomain.com</code>)</li> <li>The IP address of your Raspberry Pi (eg <code>192.168.1.10</code>)</li> </ul> </li> <li>Click \"Update environment\".</li> </ol> <p>To remove the Public IP address, repeat the above steps but clear the \"Public IP\" field in step 3.</p> <p>The reason why you have to tell Portainer CE which Public IP address to use is because an instance of Portainer CE does not necessarily have to be running on the same Raspberry Pi as the Docker containers it is managing.</p> <p>Keep in mind that clicking on a \"Published Port\" does not guarantee that your browser can open a connection. For example:</p> <ul> <li>Port 1883 for Mosquitto expects MQTT packets. It will not respond to HTTP, so any attempt will fail.</li> <li>Port 8089 for PiHole will respond to HTTP but PiHole may reject or mis-handle your attempt.</li> <li>Port 1880 for NodeRed will respond normally.</li> </ul> <p>All things considered, you will get more consistent behaviour if you simply bookmark the URLs you want to use for your IOTstack services.</p> <p>Notes:</p> <ul> <li>Earlier documentation for Portainer-CE used the term \"endpoint\" for what is now being called the \"environment\".</li> <li>The \"environment\" being discussed in this section is Portainer-CE's environment. It should not be confused with the tools Portainer-CE provides for managing a container's environment (eg setting environment variables).</li> </ul>"},{"location":"Containers/Portainer-ce/#forgotPassword","title":"If you forget your password","text":"<p>If you forget the password you created for Portainer CE, you can recover by doing the following:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose stop portainer-ce\n$ sudo rm -r ./volumes/portainer-ce\n$ docker-compose start portainer-ce\n</code></pre> <p>Then, follow the steps in:</p> <ol> <li>First run of Portainer CE; and</li> <li>Setting the Public IP address.</li> </ol>"},{"location":"Containers/PostgreSQL/","title":"PostgreSQL","text":""},{"location":"Containers/PostgreSQL/#references","title":"References","text":"<ul> <li>Docker image</li> <li>Postgre SQL Homepage</li> <li>Postgre SQL docs</li> </ul>"},{"location":"Containers/PostgreSQL/#about","title":"About","text":"<p>PostgreSQL is an SQL server, for those that need an SQL database.</p> <p>The database is available on port <code>5432</code></p>"},{"location":"Containers/PostgreSQL/#configuration","title":"Configuration","text":"<p>The service definition includes the following environment variables:</p> <ul> <li><code>TZ</code> your timezone. Defaults to <code>Etc/UTC</code></li> <li><code>POSTGRES_USER</code>. Initial username. Defaults to <code>postuser</code>.</li> <li><code>POSTGRES_PASSWORD</code>. Initial password associated with initial username. Defaults to <code>IOtSt4ckpostgresDbPw</code> (<code>postpassword</code> for old menu).</li> <li><code>POSTGRES_DB</code>. Initial database. Defaults to <code>postdb</code>.</li> </ul> <p>You can either edit the environment variables directly or provide your own substitutes by editing <code>~/IOTstack/.env</code>. Example:</p> <pre><code>$ cat ~/IOTstack/.env\nTZ=Australia/Sydney\nPOSTGRES_PASSWORD=oneTwoThree\n</code></pre> <p>When the container is brought up:</p> <ul> <li><code>TZ</code> will have the value <code>Australia/Sydney</code> (from <code>.env</code>)</li> <li><code>POSTGRES_PASSWORD</code> will have the value <code>oneTwoThree</code> (from <code>.env</code>)</li> <li><code>POSTGRES_USER</code> will have the value <code>postuser</code> (the default); and</li> <li><code>POSTGRES_DB</code> will have the value <code>postdb</code> (the default).</li> </ul> <p>The <code>TZ</code> variable takes effect every time the container is brought up. The other environment variables only work the first time the container is brought up.</p> <p>It is highly recommended to select your own password before you launch the container for the first time. See also Getting a clean slate.</p>"},{"location":"Containers/PostgreSQL/#management","title":"Management","text":"<p>You can interact with the PostgreSQL Relational Database Management System running in the container via its <code>psql</code> command. You can invoke <code>psql</code> like this:</p> <pre><code>$ docker exec -it postgres bash -c 'PGPASSWORD=$POSTGRES_PASSWORD psql $POSTGRES_DB $POSTGRES_USER'\n</code></pre> <p>Because of the single quotes (') surrounding everything after the <code>-c</code>, expansion of the environment variables is deferred until the command is executed inside the container.</p> <p>You can use any of the following methods to exit <code>psql</code>:</p> <ul> <li>Type \"\\q\" and press return</li> <li>Type \"exit\" and press return</li> <li>Press control+D</li> </ul>"},{"location":"Containers/PostgreSQL/#password-change","title":"password change","text":"<p>Once you have logged into <code>psql</code> you can reset the password like this:</p> <pre><code># ALTER USER \u00abuser\u00bb WITH PASSWORD '\u00abpassword\u00bb';\n</code></pre> <p>Replace:</p> <ul> <li><code>\u00abuser\u00bb</code> with the username (eg the default username is <code>postuser</code>)</li> <li><code>\u00abpassword\u00bb</code> with your new password.</li> </ul> <p>Notes:</p> <ul> <li>Changing the password via the <code>ALTER</code> command does not update the value of the <code>POSTGRES_PASSWORD</code> environment variable. You need to do that by hand.</li> <li> <p>Whenever you make a change to a running container's environment variables, the changes will not take effect until you re-create the container by running:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d postgresql\n</code></pre> </li> </ul>"},{"location":"Containers/PostgreSQL/#cleanSlate","title":"Getting a clean slate","text":"<p>If you need to start over, proceed like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down postgres\n$ sudo rm -rf ./volumes/postgres\n$ docker-compose up -d postgres\n</code></pre> <p>see also if downing a container doesn't work</p>"},{"location":"Containers/Prometheus/","title":"Prometheus","text":""},{"location":"Containers/Prometheus/#references","title":"References","text":"<ul> <li>Prometheus home</li> <li> <p>GitHub:</p> <ul> <li>Prometheus</li> <li>CAdvisor</li> <li>Node Exporter</li> </ul> </li> <li> <p>DockerHub:</p> <ul> <li>Prometheus</li> <li>CAdvisor</li> <li>Node Exporter</li> </ul> </li> </ul>"},{"location":"Containers/Prometheus/#configUpdate","title":"Special note 2022-11-08","text":"<p>Issue 620 pointed out there was an error in the default configuration file. That has been fixed. To adopt it, please do the following:</p> <ol> <li> <p>If Prometheus and/or any of its associated containers are running, take them down:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down prometheus prometheus-cadvisor prometheus-nodeexporter\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Move the existing active configuration out of the way:</p> <pre><code>$ cd ~/IOTstack/volumes/prometheus/data/config\n$ mv config.yml config.yml.old\n</code></pre> </li> <li> <p>Make sure that the service definitions in your <code>docker-compose.yml</code> are up-to-date by comparing them with the template versions:</p> <ul> <li><code>~/IOTstack/.templates/prometheus/service.yml</code></li> <li><code>~/IOTstack/.templates/prometheus-cadvisor/service.yml</code></li> <li><code>~/IOTstack/.templates/prometheus-nodeexporter/service.yml</code></li> </ul> <p>Your service definitions and those in the templates do not need to be identical, but you should be able to explain any differences.</p> </li> <li> <p>Rebuild your Prometheus container by following the instructions in Upgrading Prometheus. Rebuilding will import the updated default configuration into the container's image.</p> </li> <li> <p>Start the service:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d prometheus\n</code></pre> <p>Starting <code>prometheus</code> should start <code>prometheus-cadvisor</code> and <code>prometheus-nodeexporter</code> automatically. Because the old configuration has been moved out of the way, the container will supply a new version as a default.</p> </li> <li> <p>Compare the configurations:</p> <pre><code>$ cd ~/IOTstack/volumes/prometheus/data/config\n$ diff -y config.yml.old config.yml\nglobal:                          global:\n  scrape_interval: 10s             scrape_interval: 10s\n  evaluation_interval: 10s         evaluation_interval: 10s\n\nscrape_configs:                  scrape_configs:\n  - job_name: \"iotstack\"           - job_name: \"iotstack\"\n    static_configs:                  static_configs:\n      - targets:                       - targets:\n        - localhost:9090                 - localhost:9090\n        - cadvisor:8080        |         - prometheus-cadvisor:8080\n        - nodeexporter:9100    |         - prometheus-nodeexporter:9100\n</code></pre> <p>In the output above, the vertical bars (<code>|</code>) in the last two lines indicate that those lines have changed. The \"old\" version is on the left, \"new\" on the right.</p> <p>If you have made other alterations to your config then you should see other change indicators including <code>&lt;</code>, <code>|</code> and <code>&gt;</code>. If so, you should hand-merge your own changes from <code>config.yml.old</code> into <code>config.yml</code> and then restart the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart prometheus\n</code></pre> </li> </ol>"},{"location":"Containers/Prometheus/#overview","title":"Overview","text":"<p>Prometheus is a collection of three containers:</p> <ul> <li>Prometheus</li> <li>CAdvisor</li> <li>Node Exporter</li> </ul> <p>The default configuration for Prometheus supplied with IOTstack scrapes information from all three containers.</p>"},{"location":"Containers/Prometheus/#installProm","title":"Installing Prometheus","text":""},{"location":"Containers/Prometheus/#installPromNewMenu","title":"if you are running New Menu \u2026","text":"<p>When you select Prometheus in the IOTstack menu, you must also select:</p> <ul> <li>prometheus-cadvisor; and</li> <li>prometheus-nodeexporter.</li> </ul> <p>If you do not select all three containers, Prometheus will not start.</p>"},{"location":"Containers/Prometheus/#installPromOldMenu","title":"if you are running Old Menu \u2026","text":"<p>When you select Prometheus in the IOTstack menu, the service definition includes the three containers:</p> <ul> <li>prometheus</li> <li>prometheus-cadvisor; and</li> <li>prometheus-nodeexporter.</li> </ul>"},{"location":"Containers/Prometheus/#significantFiles","title":"Significant directories and files","text":"<pre><code>~/IOTstack\n\u251c\u2500\u2500 .templates\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 prometheus\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 service.yml \u2776\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 Dockerfile \u2777\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 docker-entrypoint.sh \u2778\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 iotstack_defaults \u2779\n\u2502\u00a0\u00a0  \u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 config.yml\n\u251c\u2500\u2500 services\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 prometheus\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 service.yml \u277a\n\u251c\u2500\u2500 docker-compose.yml \u277b\n\u2514\u2500\u2500 volumes\n    \u2514\u2500\u2500 prometheus \u277c\n     \u00a0\u00a0 \u2514\u2500\u2500 data\n     \u00a0\u00a0     \u251c\u2500\u2500 config \u277d\n     \u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.yml\n     \u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 prometheus.yml\n     \u00a0\u00a0     \u2514\u2500\u2500 data\n</code></pre> <ol> <li>The template service definition.</li> <li>The Dockerfile used to customise Prometheus for IOTstack.</li> <li>A pre-launch script to handle container self-repair before launching the Prometheus service.</li> <li>Defaults for IOTstack, used to initialise on first run, and for container self-repair.</li> <li>The working service definition (only relevant to old-menu, copied from \u2776).</li> <li>The Compose file (includes \u2776).</li> <li>The persistent storage area.</li> <li>The configuration directory.</li> </ol>"},{"location":"Containers/Prometheus/#howPrometheusIOTstackGetsBuilt","title":"How Prometheus gets built for IOTstack","text":""},{"location":"Containers/Prometheus/#githubSourceCode","title":"Prometheus source code (GitHub)","text":"<p>The source code for Prometheus lives at GitHub prometheus/prometheus.</p>"},{"location":"Containers/Prometheus/#dockerHubImages","title":"Prometheus images (DockerHub)","text":"<p>Periodically, the source code is recompiled and the resulting image is pushed to prom/prometheus on DockerHub.</p>"},{"location":"Containers/Prometheus/#iotstackMenu","title":"IOTstack menu","text":"<p>When you select Prometheus in the IOTstack menu, the template service definition is copied into the Compose file.</p> <p>Under old menu, it is also copied to the working service definition and then not really used.</p>"},{"location":"Containers/Prometheus/#iotstackFirstRun","title":"IOTstack first run","text":"<p>On a first install of IOTstack, you run the menu, choose Prometheus as one of your containers, and are told to do this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p><code>docker-compose</code> reads the Compose file. When it arrives at the <code>prometheus</code> fragment, it finds:</p> <pre><code>prometheus:\n  container_name: prometheus\n  build: ./.templates/prometheus/.\n</code></pre> <p>The <code>build</code> statement tells <code>docker-compose</code> to look for:</p> <pre><code>~/IOTstack/.templates/prometheus/Dockerfile\n</code></pre> <p>The Dockerfile is in the <code>.templates</code> directory because it is intended to be a common build for all IOTstack users. This is different to the arrangement for Node-RED where the Dockerfile is in the <code>services</code> directory because it is how each individual IOTstack user's version of Node-RED is customised.</p> <p>The Dockerfile begins with:</p> <pre><code>FROM prom/prometheus:latest\n</code></pre> <p>If you need to pin to a particular version of Prometheus, the Dockerfile is the place to do it. See Prometheus version pinning.</p> <p>The <code>FROM</code> statement tells the build process to pull down the base image from DockerHub.</p> <p>It is a base image in the sense that it never actually runs as a container on your Raspberry Pi.</p> <p>The remaining instructions in the Dockerfile customise the base image to produce a local image. The customisations are:</p> <ol> <li>Add configuration defaults appropriate for IOTstack.</li> <li> <p>Add <code>docker-entrypoint.sh</code> which:</p> <ul> <li>Ensures the internal directory <code>/prometheus/config/</code> exists;</li> <li>Copies any configuration files that have gone missing into that directory.</li> <li>Enforces \"pi:pi\" ownership in <code>~/IOTstack/volumes/prometheus/data/config</code>.</li> <li>Launches the Prometheus service.</li> </ul> </li> </ol> <p>The local image is instantiated to become your running container.</p> <p>When you run the <code>docker images</code> command after Prometheus has been built, you may see two rows for Prometheus:</p> <pre><code>$ docker images\nREPOSITORY           TAG         IMAGE ID       CREATED          SIZE\niotstack_prometheus  latest      1815f63da5f0   23 minutes ago   169MB\nprom/prometheus      latest      3f9575991a6c   3 days ago       169MB\n</code></pre> <ul> <li><code>prom/prometheus</code> is the base image; and</li> <li><code>iotstack_prometheus</code>  is the local image.</li> </ul> <p>You may see the same pattern in Portainer, which reports the base image as \"unused\". You should not remove the base image, even though it appears to be unused.</p> <p>Whether you see one or two rows depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Prometheus/#dependencies","title":"Dependencies: CAdvisor and Node Exporter","text":"<p>The CAdvisor and Node Exporter are included in the Prometheus service definition as dependent containers. What that means is that each time you start Prometheus, <code>docker-compose</code> ensures that CAdvisor and Node Exporter are already running, and keeps them running.</p> <p>The default configuration for Prometheus assumes CAdvisor and Node Exporter are running and starts scraping information from those targets as soon as it launches.</p>"},{"location":"Containers/Prometheus/#configuringPrometheus","title":"Configuring Prometheus","text":""},{"location":"Containers/Prometheus/#configDir","title":"Configuration directory","text":"<p>The configuration directory for the IOTstack implementation of Prometheus is at the path:</p> <pre><code>~/IOTstack/volumes/prometheus/data/config\n</code></pre> <p>That directory contains two files:</p> <ul> <li><code>config.yml</code>; and</li> <li><code>prometheus.yml</code>.</li> </ul> <p>If you delete either file, Prometheus will replace it with a default the next time the container starts. This \"self-repair\" function is intended to provide reasonable assurance that Prometheus will at least start instead of going into a restart loop.</p> <p>Unless you decide to change it, the <code>config</code> folder and its contents are owned by \"pi:pi\". This means you can edit the files in the configuration directory without needing the <code>sudo</code> command. Ownership is enforced each time the container restarts.</p>"},{"location":"Containers/Prometheus/#activeConfig","title":"Active configuration file","text":"<p>The file named <code>config.yml</code> is the active configuration. This is the file you should edit if you want to make changes. The default structure of the file is:</p> <pre><code>global:\n  scrape_interval: 10s\n  evaluation_interval: 10s\n\nscrape_configs:\n  - job_name: \"iotstack\"\n    static_configs:\n      - targets:\n        - localhost:9090\n        - cadvisor:8080\n        - nodeexporter:9100\n</code></pre> <p>To cause a running instance of Prometheus to notice a change to this file:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart prometheus\n$ docker logs prometheus\n</code></pre> <p>Note:</p> <ul> <li>The YAML parser used by Prometheus seems to be exceptionally sensitive to syntax errors (far less tolerant than <code>docker-compose</code>). For this reason, you should always check the Prometheus log after any configuration change.</li> </ul>"},{"location":"Containers/Prometheus/#referenceConfig","title":"Reference configuration file","text":"<p>The file named <code>prometheus.yml</code> is a reference configuration. It is a copy of the original configuration file that ships inside the Prometheus container at the path:</p> <pre><code>/etc/prometheus/prometheus.yml\n</code></pre> <p>Editing <code>prometheus.yml</code> has no effect. It is provided as a convenience to help you follow examples on the web. If you want to make the contents of <code>prometheus.yml</code> the active configuration, you need to do this:</p> <pre><code>$ cd ~/IOTstack/volumes/prometheus/data/config\n$ cp prometheus.yml config.yml\n$ cd ~/IOTstack\n$ docker-compose restart prometheus\n$ docker logs prometheus\n</code></pre>"},{"location":"Containers/Prometheus/#environmentVars","title":"Environment variables","text":"<p>The IOTstack implementation of Prometheus supports two environment variables:</p> <pre><code>environment:\n  - IOTSTACK_UID=1000\n  - IOTSTACK_GID=1000\n</code></pre> <p>Those variables control ownership of the Configuration directory and its contents. Those environment variables are present in the standard IOTstack service definition for Prometheus and have the effect of assigning ownership to \"pi:pi\".</p> <p>If you delete those environment variables from your Compose file, the Configuration directory will be owned by \"nobody:nobody\"; otherwise the directory and its contents will be owned by whatever values you pass for those variables.</p>"},{"location":"Containers/Prometheus/#migration","title":"Migration considerations","text":"<p>Under the original IOTstack implementation of Prometheus (just \"as it comes\" from DockerHub), the service definition expected the configuration file to be at:</p> <pre><code>~/IOTstack/services/prometheus/config.yml\n</code></pre> <p>Under this implementation of Prometheus, the configuration file has moved to:</p> <pre><code>~/IOTstack/volumes/prometheus/data/config/config.yml\n</code></pre> <p>The change of location is one of the things that allows self-repair to work properly. </p> <p>Some of the assumptions behind the default configuration file have changed. In particular, instead of the entire <code>scrape_configs</code> block being commented-out, it is active and defines <code>localhost</code>, <code>cadvisor</code> and <code>nodeexporter</code> as targets.</p> <p>You should compare the old and new versions and decide which settings need to be migrated into the new configuration file.</p> <p>If you change the configuration file, restart Prometheus and then check the log for errors:</p> <pre><code>$ docker-compose restart prometheus\n$ docker logs prometheus\n</code></pre> <p>Note:</p> <ul> <li>The YAML parser used by Prometheus is very sensitive to syntax errors. Always check the Prometheus log after any configuration change.</li> </ul>"},{"location":"Containers/Prometheus/#upgradingPrometheus","title":"Upgrading Prometheus","text":"<p>You can update <code>cadvisor</code> and <code>nodeexporter</code> like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull cadvisor nodeexporter\n$ docker-compose up -d\n$ docker system prune\n</code></pre> <p>In words:</p> <ul> <li><code>docker-compose pull</code> downloads any newer images;</li> <li><code>docker-compose up -d</code> causes any newly-downloaded images to be instantiated as containers (replacing the old containers); and</li> <li>the <code>prune</code> gets rid of the outdated images.</li> </ul> <p>This \"simple pull\" strategy doesn't work when a Dockerfile is used to build a local image on top of a base image downloaded from DockerHub. The local image is what is running so there is no way for the <code>pull</code> to sense when a newer version becomes available.</p> <p>The only way to know when an update to Prometheus is available is to check the prom/prometheus tags page on DockerHub.</p> <p>Once a new version appears on DockerHub, you can upgrade Prometheus like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull prometheus\n$ docker-compose up -d prometheus\n$ docker system prune\n$ docker system prune\n</code></pre> <p>Breaking it down into parts:</p> <ul> <li><code>build</code> causes the named container to be rebuilt;</li> <li><code>--no-cache</code> tells the Dockerfile process that it must not take any shortcuts. It really must rebuild the local image;</li> <li><code>--pull</code> tells the Dockerfile process to actually check with DockerHub to see if there is a later version of the base image and, if so, to download it before starting the build;</li> <li><code>prometheus</code> is the named container argument required by the <code>build</code> command.</li> </ul> <p>Your existing Prometheus container continues to run while the rebuild proceeds. Once the freshly-built local image is ready, the <code>up</code> tells <code>docker-compose</code> to do a new-for-old swap. There is barely any downtime for your service.</p> <p>The <code>prune</code> is the simplest way of cleaning up. The first call removes the old local image. The second call cleans up the old base image.</p> <p>Whether an old base image exists depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Prometheus/#versionPinning","title":"Prometheus version pinning","text":"<p>If you need to pin Prometheus to a particular version:</p> <ol> <li> <p>Use your favourite text editor to open the following file:</p> <pre><code>~/IOTstack/.templates/prometheus/Dockerfile\n</code></pre> </li> <li> <p>Find the line:</p> <pre><code>FROM prom/prometheus:latest\n</code></pre> </li> <li> <p>Replace <code>latest</code> with the version you wish to pin to. For example, to pin to version 2.30.2:</p> <pre><code>FROM prom/prometheus:2.30.2\n</code></pre> </li> <li> <p>Save the file and tell <code>docker-compose</code> to rebuild the local image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d --build prometheus\n$ docker system prune\n</code></pre> <p>The new local image is built, then the new container is instantiated based on that image. The <code>prune</code> deletes the old local image.</p> </li> </ol> <p>Note:</p> <ul> <li>As well as preventing Docker from updating the base image, pinning will also block incoming updates to the Dockerfile from a <code>git pull</code>. Nothing will change until you decide to remove the pin.</li> </ul>"},{"location":"Containers/Python/","title":"Python","text":""},{"location":"Containers/Python/#references","title":"references","text":"<ul> <li>Python.org</li> <li>Dockerhub image library</li> <li>GitHub docker-library/python</li> </ul>"},{"location":"Containers/Python/#menuPython","title":"selecting Python in the IOTstack menu","text":"<p>When you select Python in the menu:</p> <ol> <li> <p>The following folder and file structure is created:</p> <pre><code>$ tree ~/IOTstack/services/python\n/home/pi/IOTstack/services/python\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 app.py\n\u251c\u2500\u2500 docker-entrypoint.sh\n\u2514\u2500\u2500 Dockerfile\n</code></pre> <p>Note:</p> <ul> <li>Under \"old menu\" (old-menu branch), the <code>service.yml</code> is also copied into the <code>python</code> directory but is then not used.</li> </ul> </li> <li> <p>This service definition is added to your <code>docker-compose.yml</code>:</p> <pre><code>python:\n  container_name: python\n  build: ./services/python/.\n  restart: unless-stopped\n  environment:\n  - TZ=Etc/UTC\n  - IOTSTACK_UID=1000\n  - IOTSTACK_GID=1000\n# ports:\n#   - \"external:internal\"\n  volumes:\n  - ./volumes/python/app:/usr/src/app\n</code></pre> </li> </ol>"},{"location":"Containers/Python/#customisingPython","title":"customising your Python service definition","text":"<p>The service definition contains a number of customisation points:</p> <ol> <li><code>restart: unless-stopped</code> assumes your Python script will run in an infinite loop. If your script is intended to run once and terminate, you should remove this directive.</li> <li><code>TZ=Etc/UTC</code> should be set to your local time-zone. Never use quote marks on the right hand side of a <code>TZ=</code> variable.</li> <li> <p>If you are running as a different user ID, you may want to change both <code>IOTSTACK_UID</code> and <code>IOTSTACK_GID</code> to appropriate values.</p> <p>Notes:</p> <ul> <li>Don't use user and group names because these variables are applied inside the container where those names are (probably) undefined.</li> <li> <p>The only thing these variables affect is the ownership of:</p> <pre><code>~/IOTstack/volumes/python/app\n</code></pre> <p>and its contents. If you want everything to be owned by root, set both of these variables to zero (eg <code>IOTSTACK_UID=0</code>).</p> </li> </ul> </li> <li> <p>If your Python script listens to data-communications traffic, you can set up the port mappings by uncommenting the <code>ports:</code> directive.</p> </li> </ol> <p>If your Python container is already running when you make a change to its service definition, you can apply it via:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d python\n</code></pre>"},{"location":"Containers/Python/#firstLaunchPython","title":"Python - first launch","text":"<p>After running the menu, you are told to run the commands:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p>This is what happens:</p> <ol> <li>docker-compose reads your <code>docker-compose.yml</code>.</li> <li> <p>When it finds the service definition for Python, it encounters:</p> <pre><code>build: ./services/python/.\n</code></pre> <p>The leading period means \"the directory containing <code>docker-compose.yml</code> while the trailing period means \"Dockerfile\", so the path expands to:</p> <pre><code>~/IOTstack/services/python/Dockerfile\n</code></pre> </li> <li> <p>The <code>Dockerfile</code> is processed. It downloads the base image for Python from Dockerhub and then makes changes including:</p> <ul> <li> <p>copying the contents of the following directory into the image as a set of defaults:</p> <pre><code>/home/pi/IOTstack/services/python/app\n</code></pre> </li> <li> <p>copying the following file into the image:</p> <pre><code>/home/pi/IOTstack/services/python/docker-entrypoint.sh\n</code></pre> <p>The <code>docker-entrypoint.sh</code> script runs each time the container launches and performs initialisation and \"self repair\" functions.</p> </li> </ul> <p>The output of the Dockerfile run is a new local image tagged with the name <code>iotstack_python</code>.</p> </li> <li> <p>The <code>iotstack_python</code> image is instantiated to become the running container.</p> </li> <li> <p>When the container starts, the <code>docker-entrypoint.sh</code> script runs and initialises the container's persistent storage area:</p> <pre><code>$ tree -pu ~/IOTstack/volumes\n/home/pi/IOTstack/volumes\n\u2514\u2500\u2500 [drwxr-xr-x root    ]  python\n    \u2514\u2500\u2500 [drwxr-xr-x pi      ]  app\n        \u2514\u2500\u2500 [-rwxr-xr-x pi      ]  app.py\n</code></pre> <p>Note:</p> <ul> <li>the top-level <code>python</code> folder is owned by \"root\" but the <code>app</code> directory and its contents are owned by \"pi\".</li> </ul> </li> <li> <p>The initial <code>app.py</code> Python script is a \"hello world\" placeholder. It runs as an infinite loop emitting messages every 10 seconds until terminated. You can see what it is doing by running:</p> <pre><code>$ docker logs -f python\nThe world is born. Hello World.\nThe world is re-born. Hello World.\nThe world is re-born. Hello World.\n\u2026\n</code></pre> <p>Pressing control+c terminates the log display but does not terminate the running container.</p> </li> </ol>"},{"location":"Containers/Python/#stopPython","title":"stopping the Python service","text":"<p>To stop the container from running, either:</p> <ul> <li> <p>take down your whole stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down\n</code></pre> </li> <li> <p>terminate the python container</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down python\n</code></pre> <p>see also if downing a container doesn't work</p> </li> </ul>"},{"location":"Containers/Python/#startPython","title":"starting the Python service","text":"<p>To bring up the container again after you have stopped it, either:</p> <ul> <li> <p>bring up your whole stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> </li> <li> <p>bring up the python container</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d python\n</code></pre> </li> </ul>"},{"location":"Containers/Python/#reLaunchPython","title":"Python - second-and-subsequent launch","text":"<p>Each time you launch the Python container after the first launch:</p> <ol> <li>The existing local image (<code>iotstack_python</code>) is instantiated to become the running container.</li> <li>The <code>docker-entrypoint.sh</code> script runs and performs \"self-repair\" by replacing any files that have gone missing from the persistent storage area. Self-repair does not overwrite existing files! </li> <li>The <code>app.py</code> Python script is run.</li> </ol>"},{"location":"Containers/Python/#debugging","title":"when things go wrong - check the log","text":"<p>If the container misbehaves, the log is your friend:</p> <pre><code>$ docker logs python\n</code></pre>"},{"location":"Containers/Python/#yourPythonScript","title":"project development life-cycle","text":"<p>It is critical that you understand that all of your project development should occur within the folder:</p> <pre><code>~/IOTstack/volumes/python/app\n</code></pre> <p>So long as you are performing some sort of routine backup (either with a supplied script or a third party solution like Paraphraser/IOTstackBackup), your work will be protected.</p>"},{"location":"Containers/Python/#gettingStarted","title":"getting started","text":"<p>Start by editing the file:</p> <pre><code>~/IOTstack/volumes/python/app/app.py\n</code></pre> <p>If you need other supporting scripts or data files, also add those to the directory:</p> <pre><code>~/IOTstack/volumes/python/app\n</code></pre> <p>Any time you change something in the <code>app</code> folder, tell the running python container to notice the change by:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart python\n</code></pre>"},{"location":"Containers/Python/#persistentStorage","title":"reading and writing to disk","text":"<p>Consider this line in the service definition:</p> <pre><code>- ./volumes/python/app:/usr/src/app\n</code></pre> <p>The leading period means \"the directory containing <code>docker-compose.yml</code>\" so it the same as:</p> <pre><code>- ~/IOTstack/volumes/python/app:/usr/src/app\n</code></pre> <p>Then, you split the line at the \":\", resulting in:</p> <ul> <li>The external directory = <code>~/IOTstack/volumes/python/app</code></li> <li>The internal directory = <code>/usr/src/app</code></li> </ul> <p>What it means is that:</p> <ul> <li>Any file you put into the external directory (or any sub-directories you create within the external directory) will be visible to your Python script running inside the container at the same relative position in the internal directory.</li> <li>Any file or sub-directory created in the internal directory by your Python script running inside the container will be visible outside the container at the same relative position in the external directory.</li> <li>The contents of external directory and, therefore, the internal directory will persist across container launches.</li> </ul> <p>If your script writes into any other directory inside the container, the data will be lost when the container re-launches.</p>"},{"location":"Containers/Python/#cleanSlate","title":"getting a clean slate","text":"<p>If you make a mess of things and need to start from a clean slate, erase the persistent storage area:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down python\n$ sudo rm -rf ./volumes/python\n$ docker-compose up -d python\n</code></pre> <p>see also if downing a container doesn't work</p> <p>The container will re-initialise the persistent storage area from its defaults.</p>"},{"location":"Containers/Python/#addingPackages","title":"adding packages","text":"<p>As you develop your project, you may find that you need to add supporting packages. For this example, we will assume you want to add \"Flask\" and \"beautifulsoup4\".</p> <p>If you were developing a project outside of container-space, you would simply run:</p> <pre><code>$ pip3 install -U Flask beautifulsoup4\n</code></pre> <p>You can do the same thing with the running container:</p> <pre><code>$ docker exec python pip3 install -U Flask beautifulsoup4\n</code></pre> <p>and that will work\u00a0\u2014\u00a0until the container is re-launched, at which point the added packages will disappear.</p> <p>To make Flask and beautifulsoup4 a permanent part of your container:</p> <ol> <li> <p>Change your working directory:</p> <pre><code>$ cd ~/IOTstack/services/python/app\n</code></pre> </li> <li> <p>Use your favourite text editor to create the file <code>requirements.txt</code> in that directory. Each package you want to add should be on a line by itself:</p> <pre><code>Flask\nbeautifulsoup4\n</code></pre> </li> <li> <p>Tell Docker to rebuild the local Python image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --force-rm python\n$ docker-compose up -d --force-recreate python\n$ docker system prune -f\n</code></pre> <p>Note:</p> <ul> <li>You will see a warning about running pip as root - ignore it.</li> </ul> </li> <li> <p>Confirm that the packages have been added:</p> <pre><code>$ docker exec python pip3 freeze | grep -e \"Flask\" -e \"beautifulsoup4\"\nbeautifulsoup4==4.10.0\nFlask==2.0.1\n</code></pre> </li> <li> <p>Continue your development work by returning to getting started.</p> </li> </ol> <p>Note:</p> <ul> <li> <p>The first time you following the process described above to create <code>requirements.txt</code>, a copy will appear at:</p> <pre><code>~/IOTstack/volumes/python/app/requirements.txt\n</code></pre> <p>This copy is the result of the \"self-repair\" code that runs each time the container starts noticing that <code>requirements.txt</code> is missing and making a copy from the defaults stored inside the image.</p> <p>If you make more changes to the master version of <code>requirements.txt</code> in the services directory and rebuild the local image, the copy in the volumes directory will not be kept in-sync. That's because the \"self-repair\" code never overwrites existing files.</p> <p>If you want to bring the copy of <code>requirements.txt</code> in the volumes directory up-to-date:</p> <pre><code>$ cd ~/IOTstack\n$ rm ./volumes/python/app/requirements.txt\n$ docker-compose restart python\n</code></pre> <p>The <code>requirements.txt</code> file will be recreated and it will be a copy of the version in the services directory as of the last image rebuild.</p> </li> </ul>"},{"location":"Containers/Python/#scriptBaking","title":"making your own Python script the default","text":"<p>Suppose the Python script you have been developing reaches a major milestone and you decide to \"freeze dry\" your work up to that point so that it becomes the default when you ask for a clean slate. Proceed like this:</p> <ol> <li> <p>If you have added any packages by following the steps in adding packages, run the following command:</p> <pre><code>$ docker exec python bash -c 'pip3 freeze &gt;requirements.txt'\n</code></pre> <p>That generates a <code>requirements.txt</code> representing the state of play inside the running container. Because it is running inside the container, the <code>requirements.txt</code> created by that command appears outside the container at:</p> <pre><code>~/IOTstack/volumes/python/app/requirements.txt\n</code></pre> </li> <li> <p>Make your work the default:</p> <pre><code>$ cd ~/IOTstack\n$ cp -r ./volumes/python/app/* ./services/python/app\n</code></pre> <p>The <code>cp</code> command copies:</p> <ul> <li>your Python script;</li> <li>the optional <code>requirements.txt</code> (from step 1); and</li> <li>any other files you may have put into the Python working directory.</li> </ul> <p>Key point:</p> <ul> <li>everything copied into <code>./services/python/app</code> will become part of the new local image.</li> </ul> </li> <li> <p>Terminate the Python container and erase its persistent storage area:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down python\n$ sudo rm -rf ./volumes/python\n</code></pre> <p>Note:</p> <ul> <li> <p>If erasing the persistent storage area feels too risky, just move it out of the way:</p> <pre><code>$ cd ~/IOTstack/volumes\n$ sudo mv python python.off\n</code></pre> </li> </ul> </li> <li> <p>Rebuild the local image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --force-rm python\n$ docker-compose up -d --force-recreate python\n</code></pre> <p>On its first launch, the new container will re-populate the persistent storage area but, this time, it will be your Python script and any other supporting files, rather than the original \"hello world\" script.</p> </li> <li> <p>Clean up by removing the old local image:</p> <pre><code>$ docker system prune -f\n</code></pre> </li> </ol>"},{"location":"Containers/Python/#scriptCanning","title":"canning your project","text":"<p>Suppose your project has reached the stage where you wish to put it into production as a service under its own name. Make two further assumptions:</p> <ol> <li>You have gone through the steps in making your own Python script the default and you are certain that the content of <code>./services/python/app</code> correctly captures your project.</li> <li>You want to give your project the name \"wishbone\".</li> </ol> <p>Proceed like this:</p> <ol> <li> <p>Stop the development project:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down python\n</code></pre> </li> <li> <p>Remove the existing local image:</p> <pre><code>$ docker rmi iotstack_python\n</code></pre> </li> <li> <p>Rename the <code>python</code> services directory to the name of your project:</p> <pre><code>$ cd ~/IOTstack/services\n$ mv python wishbone\n</code></pre> </li> <li> <p>Edit the <code>python</code> service definition in <code>docker-compose.yml</code> and replace references to <code>python</code> with the name of your project. In the following, the original is on the left, the edited version on the right, and the lines that need to change are indicated with a \"|\": </p> <pre><code>python:                                  |  wishbone:\n  container_name: python                 |    container_name: wishbone\n  build: ./services/python/.             |    build: ./services/wishbone/.\n  restart: unless-stopped                     restart: unless-stopped\n  environment:                                environment:\n    - TZ=Etc/UTC                                - TZ=Etc/UTC\n    - IOTSTACK_UID=1000                         - IOTSTACK_UID=1000\n    - IOTSTACK_GID=1000                         - IOTSTACK_GID=1000\n  # ports:                                    # ports:\n  #   - \"external:internal\"                   #   - \"external:internal\"\n  volumes:                                    volumes:\n    - ./volumes/python/app:/usr/src/app  |      - ./volumes/wishbone/app:/usr/src/app\n</code></pre> <p>Note:</p> <ul> <li>if you make a copy of the <code>python</code> service definition and then perform the required \"wishbone\" edits on the copy, the <code>python</code> definition will still be active so <code>docker-compose</code> may try to bring up both services. You will eliminate the risk of confusing yourself if you follow these instructions \"as written\" by not leaving the <code>python</code> service definition in place.</li> </ul> </li> <li> <p>Start the renamed service:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d wishbone\n</code></pre> </li> </ol> <p>Remember:</p> <ul> <li> <p>After you have done this, the persistent storage area will be at the path:</p> <pre><code>~/IOTstack/volumes/wishbone/app\n</code></pre> </li> </ul>"},{"location":"Containers/Python/#routineMaintenance","title":"routine maintenance","text":"<p>To make sure you are running from the most-recent base image of Python from Dockerhub:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull python\n$ docker-compose up -d python\n$ docker system prune -f\n$ docker system prune -f\n</code></pre> <p>In words:</p> <ol> <li>Be in the right directory.</li> <li>Force docker-compose to download the most-recent version of the Python base image from Dockerhub, and then run the Dockerfile to build a new local image.</li> <li>Instantiate the newly-built local image.</li> <li>Remove the old local image.</li> <li>Remove the old base image</li> </ol> <p>The old base image can't be removed until the old local image has been removed, which is why the <code>prune</code> command needs to be run twice.</p> <p>Note:</p> <ul> <li>If you have followed the steps in canning your project and your service has a name other than <code>python</code>, just substitute the new name where you see <code>python</code> in the two <code>dockerc-compose</code> commands.</li> </ul>"},{"location":"Containers/RTL_433-docker/","title":"RTL_433 Docker","text":"<p>Requirements, you will need to have a SDR dongle for you to be able to use RTL. I've tested this with a RTL2838</p> <p>Make sure you can see your receiver by running <code>lsusb</code></p> <pre><code>$ lsusb\nBus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 001 Device 004: ID 0bda:2838 Realtek Semiconductor Corp. RTL2838 DVB-T\nBus 001 Device 002: ID 2109:3431 VIA Labs, Inc. Hub\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n</code></pre> <p>Before starting the container please install RTL_433 from the native installs menu. This will setup your environment with the correct variables and programs. It is also advised to run RTL_433 to verify that it is working correctly on your system.</p> <p>The container is designed to send all detected messages over mqtt</p> <p>Edit the IOTstack/services/rtl_433/rtl_433.env file with your relevant settings for your mqtt server: <pre><code>MQTT_ADDRESS=mosquitto\nMQTT_PORT=1833\n#MQTT_USER=myuser\n#MQTT_PASSWORD=mypassword\nMQTT_TOPIC=RTL_433\n</code></pre></p> <p>the container starts with the command <code>rtl_433 -F mqtt:....</code> currently it does not filter any packets, you will need to do this in Node-RED</p>"},{"location":"Containers/Ring-MQTT/","title":"Ring-MQTT","text":""},{"location":"Containers/Ring-MQTT/#references","title":"References","text":"<ul> <li>Ring-MQTT Wiki (documentation)</li> <li>DockerHub (Docker images)</li> <li>GitHub (Source code and issues)</li> </ul>"},{"location":"Containers/Ring-MQTT/#getting-started","title":"Getting started","text":"<ol> <li> <p>Be in the correct directory (assumed throughout):</p> <pre><code>$ cd ~/IOTstack\n</code></pre> </li> <li> <p>Run the IOTstack menu and choose <code>ring-mqtt</code>. An alternative to running the menu is to append the service definition template to your compose file like this:</p> <pre><code>$ sed -e \"s/^/  /\" ./.templates/ring-mqtt/service.yml &gt;&gt;docker-compose.yml\n</code></pre> <p>The <code>sed</code> command is required because service definition templates are left-shifted by two spaces.</p> </li> <li> <p>This step is optional. Use a text editor to open your <code>docker-compose.yml</code> file:</p> <ul> <li>find the <code>ring-mqtt</code> service definition;</li> <li>change the <code>TZ</code> environment variable to your time-zone;</li> <li>save your work.</li> </ul> </li> <li> <p>Bring up the container:</p> <pre><code>$ docker-compose up -d ring-mqtt\n</code></pre> <p>This pulls the image from DockerHub, instantiates the container, and initialises its persistent storage.</p> </li> <li> <p>Use <code>sudo</code> and a text editor to open the configuration file at the path. For example:</p> <pre><code>$ sudo vi ./volumes/ring-mqtt/data/config.json\n</code></pre> <p>At the time of writing, the default configuration file looked like this:</p> <pre><code>{\n    \"mqtt_url\": \"mqtt://localhost:1883\",\n    \"mqtt_options\": \"\",\n    \"livestream_user\": \"\",\n    \"livestream_pass\": \"\",\n    \"disarm_code\": \"\",\n    \"enable_cameras\": false,\n    \"enable_modes\": false,\n    \"enable_panic\": false,\n    \"hass_topic\": \"homeassistant/status\",\n    \"ring_topic\": \"ring\",\n    \"location_ids\": [\n        \"\"\n    ]\n}\n</code></pre> <p>From the perspective of any process running in a Docker container, <code>localhost</code> means \"this container\" rather than \"this Raspberry Pi\". You need to edit line 2 to point to your MQTT broker:</p> <ul> <li> <p>If the <code>ring-mqtt</code> container and your <code>mosquitto</code> container are running on the same Raspberry Pi:</p> <pre><code>\"mqtt_url\": \"mqtt://mosquitto:1883\",\n</code></pre> </li> <li> <p>Otherwise, replace <code>localhost</code> with the IP address or domain name of the host where your MQTT broker is running. For example:</p> <pre><code>\"mqtt_url\": \"mqtt://192.168.0.100:1883\",\n</code></pre> </li> <li> <p>If your MQTT broker is protected by a username and password, refer to the Ring-MQTT Wiki for the correct syntax.</p> </li> </ul> <p>Save your work then restart the container:</p> <pre><code>$ docker-compose restart ring-mqtt\n</code></pre> </li> <li> <p>Launch your browser (eg Chrome, Firefox, Safari) and open the following URL:</p> <pre><code>http://\u00abip-or-name\u00bb:55123\n</code></pre> <p>where <code>\u00abip-or-name\u00bb</code> is the IP address or domain name of the Raspberry Pi running your ring-mqtt container. Examples:</p> <ul> <li><code>http://192.168.1.100:55123</code></li> <li><code>http://iot-hub.my.domain.com:55123</code></li> <li><code>http://iot-hub.local:55123</code></li> </ul> <p>You should see the following screen:</p> <p></p> <p>Follow the instructions on the screen to generate your refresh token.</p> </li> <li> <p>Check the logs:</p> <pre><code>$ docker logs ring-mqtt\n</code></pre> <p>Unless you see errors being reported, your <code>ring-mqtt</code> container should be ready.</p> </li> </ol>"},{"location":"Containers/Ring-MQTT/#environment-variables","title":"Environment variables","text":"<p>The default service definition includes two environment variables:</p> <pre><code>environment:\n- TZ=Etc/UTC\n- DEBUG=ring-*\n</code></pre> <ul> <li><code>TZ=</code> should be set to your local time zone (explained above).</li> <li><code>DEBUG=ring-*</code> (\"all debugging options enabled\") is the default for <code>ring-mqtt</code> when running in a container. It is included as a placeholder if you want to tailor debugging output. Refer to the Ring-MQTT Wiki.</li> </ul> <p>Whenever you change an environment variable, run:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d ring-mqtt\n</code></pre> <p>The \"up\" causes docker-compose to notice the configuration change and re-create the container.</p>"},{"location":"Containers/Ring-MQTT/#configuration","title":"Configuration","text":"<p>Consult the Ring-MQTT Wiki.</p>"},{"location":"Containers/Ring-MQTT/#maintenance","title":"Maintenance","text":"<p>Periodically:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull ring-mqtt\n</code></pre> <p>If a new image comes down from DockerHub:</p> <pre><code>$ docker-compose up -d ring-mqtt\n$ docker system prune -f\n</code></pre> <p>The \"up\" instantiates the newly-downloaded image as the running container. The \"prune\" cleans up the older image.</p>"},{"location":"Containers/Scrypted/","title":"Scrypted \u2013 home video integration platform","text":""},{"location":"Containers/Scrypted/#references","title":"References","text":"<ul> <li>Scrypted home page</li> <li>DockerHub</li> <li>GitHub</li> </ul>"},{"location":"Containers/Scrypted/#getting-started","title":"Getting started","text":"<ol> <li>Run the IOTstack menu and select \"Scrypted\" so that the service definition is added to your compose file.</li> <li> <p>Before starting the container for the first time, run the following commands:</p> <pre><code>$ cd ~/IOTstack\n$ echo \"SCRYPTED_WEBHOOK_UPDATE_AUTHORIZATION=$(cat /proc/sys/kernel/random/uuid | md5sum | head -c 24)\" &gt;&gt;.env\n</code></pre> <p>This generates a random token and places it in <code>~/IOTstack/.env</code>.</p> <p>Notes:</p> <ol> <li>You only need to do this once.</li> <li>It is not clear whether the token is respected on every launch, or only on first launch.</li> </ol> </li> <li> <p>Start Scrypted:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d scrypted\n</code></pre> <p>Note:</p> <ul> <li>scrypted is a large image (2.5GB). It takes time to download and decompress!</li> </ul> </li> <li> <p>Use the following URL as a template:</p> <pre><code>https://\u00abhost-or-ip\u00bb:10443\n</code></pre> <p>Replace <code>\u00abhost-or-ip\u00bb</code> with the domain name or IP address of your Raspberry Pi. Examples:</p> <ul> <li><code>https://raspberrypi.my.domain.com:10443</code></li> <li><code>https://raspberrypi.local:10443</code></li> <li><code>https://192.168.1.10:10443</code></li> </ul> <p>Note:</p> <ul> <li>You can't use the <code>http</code> protocol. You must use <code>https</code>.</li> </ul> </li> <li> <p>Paste the URL into a browser window. The container uses a self-signed certificate so you will need to accept that using your browser's mechanisms.</p> </li> <li>Enter a username and password to create your administrator account.</li> </ol>"},{"location":"Containers/Scrypted/#troubleshooting","title":"Troubleshooting","text":"<p>If you see the message:</p> <pre><code>required variable SCRYPTED_WEBHOOK_UPDATE_AUTHORIZATION is missing a value: see instructions for generating a token\n</code></pre> <p>it means that you did not complete step 2 before starting the container. Go back and perform step 2.</p> <p>If you need to start over from scratch:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down scrypted\n$ sudo rm -rf ./volumes/scrypted\n$ docker-compose up -d scrypted\n</code></pre> <p>see also if downing a container doesn't work</p>"},{"location":"Containers/Scrypted/#about-the-service-definition","title":"About the service definition","text":"<p>The Scrypted container runs in host mode, which means it binds directly to the Raspberry Pi's ports. The service definition includes:</p> <pre><code>x-ports:\n- \"10443:10443\"\n</code></pre> <p>The effect of the <code>x-</code> prefix is to comment-out that port mapping. It is included as an aide-memoire to help you remember the port number.</p> <p>The service definition also includes the following environment variable:</p> <pre><code>- SCRYPTED_WEBHOOK_UPDATE=http://localhost:10444/v1/update\n</code></pre> <p>The container does not bind to port 10444 so the purpose of this is not clear. The port number should be treated as reserved. </p>"},{"location":"Containers/Syncthing/","title":"Syncthing","text":"<p>Syncthing is a continuous file synchronization program. It synchronizes files between two or more computers in real time, safely protected from prying eyes. Your data is your data alone and you deserve to choose where it is stored, whether it is shared with some third party, and how it's transmitted over the internet.</p> <p>Forget about using propietary solutions and take control of your data. Syncthing is an open source solution for synchronizing your data in a p2p way. </p>"},{"location":"Containers/Syncthing/#references","title":"References","text":"<ul> <li>Syncthing home page</li> <li>GitHub repository</li> <li>linuxserver.io docker image - The one used here</li> <li> <p>Official Syncthing docker image - Not the one used here</p> <ul> <li>For more information about official syncthing image have a look at here </li> </ul> </li> </ul>"},{"location":"Containers/Syncthing/#web-interface","title":"Web interface","text":"<p>The web UI can be found on  <code>yourip:8384</code></p>"},{"location":"Containers/Syncthing/#data-volumes","title":"Data &amp; volumes","text":"<p>Configuration data is available under <code>/config</code> containers directroy and mapped to <code>./volumes/syncthing/config</code> . </p> <p>The <code>/app</code> directory is inside the container, on the host you will use ./volumes/syncthing/data.  The default share is named Sync. Other added folders will also appear under data.</p>"},{"location":"Containers/Syncthing/#ports","title":"Ports","text":"<p>Have a look at <code>~/IOTStack/.templates/syncthing/service.yml</code> or linuxserve docker documentation, by the way, used ports are; </p> <pre><code>    ports:\n      - 8384:8384 # Web UI\n      - 22000:22000/tcp # TCP file transfers\n      - 22000:22000/udp # QUIC file transfers\n      - 21027:21027/udp # Receive local discovery broadcasts\n</code></pre>"},{"location":"Containers/TasmoAdmin/","title":"TasmoAdmin","text":""},{"location":"Containers/TasmoAdmin/#references","title":"References","text":"<ul> <li>Homepage</li> <li>Docker</li> </ul>"},{"location":"Containers/TasmoAdmin/#web-interface","title":"Web interface","text":"<p>The web UI can be found on <code>\"your_ip\":8088</code></p>"},{"location":"Containers/TasmoAdmin/#usage","title":"Usage","text":"<p>(instructions to follow)</p>"},{"location":"Containers/Telegraf/","title":"Telegraf","text":"<p>This document discusses an IOTstack-specific version of Telegraf built on top of influxdata/influxdata-docker/telegraf using a Dockerfile.</p> <p>The purpose of the Dockerfile is to:</p> <ul> <li>tailor the default configuration to be IOTstack-ready; and</li> <li>enable the container to perform self-repair if essential elements of the persistent storage area disappear.</li> </ul>"},{"location":"Containers/Telegraf/#references","title":"References","text":"<ul> <li>influxdata Telegraf home</li> <li>GitHub: influxdata/influxdata-docker/telegraf</li> <li>DockerHub: influxdata Telegraf</li> </ul>"},{"location":"Containers/Telegraf/#significantFiles","title":"Significant directories and files","text":"<pre><code>~/IOTstack\n\u251c\u2500\u2500 .templates\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 telegraf\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 Dockerfile \u2776\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 entrypoint.sh \u2777\n\u2502       \u251c\u2500\u2500 iotstack_defaults\n\u2502\u00a0\u00a0     \u2502   \u251c\u2500\u2500 additions \u2778\n\u2502\u00a0\u00a0     \u2502   \u2514\u2500\u2500 auto_include \u2779\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 service.yml \u277a\n\u251c\u2500\u2500 services\n\u2502   \u2514\u2500\u2500 telegraf\n\u2502       \u2514\u2500\u2500 service.yml \u277b\n\u251c\u2500\u2500 docker-compose.yml\n\u2514\u2500\u2500 volumes\n    \u2514\u2500\u2500 telegraf \u277c\n        \u251c\u2500\u2500 additions \u277d\n        \u251c\u2500\u2500 telegraf-reference.conf \u2792\n        \u2514\u2500\u2500 telegraf.conf \u2793\n</code></pre> <ol> <li>The Dockerfile used to customise Telegraf for IOTstack.</li> <li>A replacement for the <code>telegraf</code> container script of the same name, extended to handle container self-repair.</li> <li>The additions folder. See Applying optional additions.</li> <li>The auto_include folder. Additions automatically applied to    <code>telegraf.conf</code>. See Automatic includes to telegraf.conf.</li> <li>The template service definition.</li> <li>The working service definition (only relevant to old-menu, copied from \u2779).</li> <li>The persistent storage area for the <code>telegraf</code> container.</li> <li>A working copy of the additions folder (copied from \u2778). See Applying optional additions.</li> <li>The reference configuration file. See Changing Telegraf's configuration.</li> <li>The active configuration file. A subset of \u2792 altered to support communication with InfluxDB running in a container in the same IOTstack instance.</li> </ol> <p>Everything in the persistent storage area \u277c:</p> <ul> <li>will be replaced if it is not present when the container starts; but</li> <li>will never be overwritten if altered by you.</li> </ul>"},{"location":"Containers/Telegraf/#howTelegrafIOTstackGetsBuilt","title":"How Telegraf gets built for IOTstack","text":""},{"location":"Containers/Telegraf/#iotstackMenu","title":"IOTstack menu","text":"<p>When you select Telegraf in the IOTstack menu, the template service definition is copied into the Compose file.</p> <p>Under old menu, it is also copied to the working service definition and then not really used.</p>"},{"location":"Containers/Telegraf/#iotstackFirstRun","title":"IOTstack first run","text":"<p>On a first install of IOTstack, you run the menu, choose your containers, and are told to do this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> <p>See also the Migration considerations (below).</p> <p><code>docker-compose</code> reads the Compose file. When it arrives at the <code>telegraf</code> fragment, it finds:</p> <pre><code>  telegraf:\n    container_name: telegraf\n    build: ./.templates/telegraf/.\n    \u2026\n</code></pre> <p>The <code>build</code> statement tells <code>docker-compose</code> to look for:</p> <pre><code>~/IOTstack/.templates/telegraf/Dockerfile\n</code></pre> <p>The Dockerfile is in the <code>.templates</code> directory because it is intended to be a common build for all IOTstack users. This is different to the arrangement for Node-RED where the Dockerfile is in the <code>services</code> directory because it is how each individual IOTstack user's version of Node-RED is customised.</p> <p>The Dockerfile begins with:</p> <pre><code>FROM telegraf:latest\n</code></pre> <p>If you need to pin to a particular version of Telegraf, the Dockerfile is the place to do it. See Telegraf version pinning.</p> <p>The <code>FROM</code> statement tells the build process to pull down the base image from DockerHub.</p> <p>It is a base image in the sense that it never actually runs as a container on your Raspberry Pi.</p> <p>The remaining instructions in the Dockerfile customise the base image to produce a local image. The customisations are:</p> <ol> <li>Add the <code>rsync</code> package. This helps the container perform self-repair.</li> <li>Copy the default configuration file that comes with the DockerHub image (so it will be available as a fully-commented reference for the user) and make it read-only.</li> <li>Make a working version of the default configuration file from which comment lines and blank lines have been removed.</li> <li>Patch the working version to support communications with InfluxDB running in another container in the same IOTstack instance.</li> <li> <p>Replace <code>entrypoint.sh</code> with a version which:</p> <ul> <li>calls <code>rsync</code> to perform self-repair if <code>telegraf.conf</code> goes missing; and</li> <li>enforces root:root ownership in <code>~/IOTstack/volumes/telegraf</code>.</li> </ul> </li> </ol> <p>The local image is instantiated to become your running container.</p> <p>When you run the <code>docker images</code> command after Telegraf has been built, you may see two rows for Telegraf:</p> <pre><code>$ docker images\nREPOSITORY          TAG      IMAGE ID       CREATED       SIZE\niotstack_telegraf   latest   59861b7fe9ed   2 hours ago   292MB\ntelegraf            latest   a721ac170fad   3 days ago    273MB\n</code></pre> <ul> <li><code>telegraf</code> is the base image; and</li> <li><code>iotstack_telegraf</code> is the local image.</li> </ul> <p>You may see the same pattern in Portainer, which reports the base image as \"unused\". You should not remove the base image, even though it appears to be unused.</p> <p>Whether you see one or two rows depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Telegraf/#migration","title":"Migration considerations","text":"<p>Under the original IOTstack implementation of Telegraf (just \"as it comes\" from DockerHub), the service definition expected <code>telegraf.conf</code> to be at:</p> <pre><code>~/IOTstack/services/telegraf/telegraf.conf\n</code></pre> <p>Under this implementation of Telegraf, the configuration file has moved to:</p> <pre><code>~/IOTstack/volumes/telegraf/telegraf.conf\n</code></pre> <p>The change of location is one of the things that allows self-repair to work properly. </p> <p>With one exception, all prior and current versions of the default configuration file are identical in terms of their semantics.</p> <p>In other words, once you strip away comments and blank lines, and remove any \"active\" configuration options that simply repeat their default setting, you get the same subset of \"active\" configuration options. The default configuration file supplied with gcgarner/IOTstack is available here if you wish to refer to it.</p> <p>The exception is <code>[[inputs.mqtt_consumer]]</code> which is now provided as an optional addition. If your existing Telegraf configuration depends on that input, you will need to apply it. See applying optional additions.</p>"},{"location":"Containers/Telegraf/#logging","title":"Logging","text":"<p>You can inspect Telegraf's log by:</p> <pre><code>$ docker logs telegraf\n</code></pre> <p>These logs are ephemeral and will disappear when your Telegraf container is rebuilt.</p>"},{"location":"Containers/Telegraf/#logTelegrafDB","title":"log message: database \"telegraf\" creation failed","text":"<p>The following log message can be misleading:</p> <pre><code>W! [outputs.influxdb] When writing to [http://influxdb:8086]: database \"telegraf\" creation failed: Post \"http://influxdb:8086/query\": dial tcp 172.30.0.9:8086: connect: connection refused\n</code></pre> <p>If InfluxDB is not running when Telegraf starts, the <code>depends_on:</code> clause in Telegraf's service definition tells Docker to start InfluxDB (and Mosquitto) before starting Telegraf. Although it can launch the InfluxDB container first, Docker has no way of knowing when the <code>influxd</code> process running inside the InfluxDB container will start listening to port 8086.</p> <p>What this error message usually means is that Telegraf has tried to communicate with InfluxDB before the latter is ready to accept connections. Telegraf typically retries after a short delay and is then able to communicate with InfluxDB.</p>"},{"location":"Containers/Telegraf/#editConfiguration","title":"Changing Telegraf's configuration","text":"<p>The first time you launch the Telegraf container, the following structure will be created in the persistent storage area:</p> <pre><code>~/IOTstack/volumes/telegraf\n\u251c\u2500\u2500 [drwxr-xr-x root    ]  additions\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 [-rw-r--r-- root    ]  inputs.mqtt_consumer.conf\n\u251c\u2500\u2500 [-rw-r--r-- root    ]  telegraf.conf\n\u2514\u2500\u2500 [-r--r--r-- root    ]  telegraf-reference.conf\n</code></pre> <p>The file:</p> <ul> <li> <p><code>telegraf-reference.conf</code>:</p> <ul> <li>is a reference copy of the default configuration file that ships with the base image for Telegraf when it is downloaded from DockerHub. It is nearly 9000 lines long and is mostly comments.</li> <li>is not used by Telegraf but will be replaced if you delete it.</li> <li>is marked \"read-only\" (even for root) as a reminder that it is only for your reference. Any changes you make will be ignored.</li> </ul> </li> <li> <p><code>telegraf.conf</code>:</p> <ul> <li>is created by removing all comment lines and blank lines from <code>telegraf-reference.conf</code>, leaving only the \"active\" configuration options, and then adding options necessary for IOTstack.</li> <li>is less than 30 lines and is significantly easier to understand than <code>telegraf-reference.conf</code>.</li> </ul> </li> <li> <p><code>inputs.mqtt_consumer.conf</code> \u2013 see Applying optional additions below.</p> </li> </ul> <p>The intention of this structure is that you:</p> <ol> <li>search <code>telegraf-reference.conf</code> to find the configuration option you need;</li> <li>read the comments to understand what the option does and how to use it; and then</li> <li>import the option into the correct section of <code>telegraf.conf</code>.</li> </ol> <p>When you make a change to <code>telegraf.conf</code>, you activate it by restarting the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart telegraf\n</code></pre>"},{"location":"Containers/Telegraf/#autoInclude","title":"Automatic includes to telegraf.conf","text":"<ul> <li> <p><code>inputs.docker.conf</code> instructs Telegraf to collect metrics from Docker. Requires kernel control   groups to be enabled to collect memory usage data. If not done during initial installation,   enable by running (reboot required):</p> <pre><code>$ CMDLINE=\"/boot/firmware/cmdline.txt\" &amp;&amp; [ -e \"$CMDLINE\" ] || CMDLINE=\"/boot/cmdline.txt\"\n$ echo $(cat \"$CMDLINE\") cgroup_memory=1 cgroup_enable=memory | sudo tee \"$CMDLINE\"\n</code></pre> </li> <li> <p><code>inputs.cpu_temp.conf</code> collects cpu temperature.</p> </li> </ul>"},{"location":"Containers/Telegraf/#optionalAdditions","title":"Applying optional additions","text":"<p>The additions folder (see Significant directories and files) is a mechanism for additional IOTstack-ready configuration options to be provided for Telegraf.</p> <p>Currently there is one addition:</p> <ol> <li><code>inputs.mqtt_consumer.conf</code> which formed part of the gcgarner/IOTstack telegraf configuration and instructs Telegraf to subscribe to a metric feed from the Mosquitto broker. This assumes, of course, that something is publishing those metrics.</li> </ol> <p>Using <code>inputs.mqtt_consumer.conf</code> as the example, applying that addition to your Telegraf configuration file involves:</p> <pre><code>$ cd ~/IOTstack/volumes/telegraf\n$ grep -v \"^#\" additions/inputs.mqtt_consumer.conf | sudo tee -a telegraf.conf &gt;/dev/null\n$ cd ~/IOTstack\n$ docker-compose restart telegraf\n</code></pre> <p>The <code>grep</code> strips comment lines and the <code>sudo tee</code> is a safe way of appending the result to <code>telegraf.conf</code>. The <code>restart</code> causes Telegraf to notice the change.</p>"},{"location":"Containers/Telegraf/#cleanSlate","title":"Getting a clean slate","text":""},{"location":"Containers/Telegraf/#zapStore","title":"Erasing the persistent storage area","text":"<p>Erasing Telegraf's persistent storage area triggers self-healing and restores known defaults:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down telegraf\n$ sudo rm -rf ./volumes/telegraf\n$ docker-compose up -d telegraf\n</code></pre> <p>Notes:</p> <ul> <li> <p>You can also remove individual files within the persistent storage area and then trigger self-healing. For example, if you decide to edit <code>telegraf-reference.conf</code> and make a mess, you can restore the original version like this:</p> <pre><code>$ cd ~/IOTstack\n$ sudo rm ./volumes/telegraf/telegraf-reference.conf\n$ docker-compose restart telegraf\n</code></pre> </li> <li> <p>See also if downing a container doesn't work</p> </li> </ul>"},{"location":"Containers/Telegraf/#resetDB","title":"Resetting the InfluxDB database","text":"<p>To reset the InfluxDB database that Telegraf writes into, proceed like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down telegraf\n$ docker exec -it influxdb influx -precision=rfc3339\n&gt; drop database telegraf\n&gt; exit\n$ docker-compose up -d telegraf\n</code></pre> <p>In words:</p> <ul> <li>Be in the right directory.</li> <li>Stop the Telegraf container (while leaving the InfluxDB container running). See also if downing a container doesn't work.</li> <li>Launch the Influx CLI inside the InfluxDB container.</li> <li>Delete the <code>telegraf</code> database, and then exit the CLI.</li> <li>Start the Telegraf container. This re-creates the database automatically. </li> </ul>"},{"location":"Containers/Telegraf/#upgradingTelegraf","title":"Upgrading Telegraf","text":"<p>You can update most containers like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune\n</code></pre> <p>In words:</p> <ul> <li><code>docker-compose pull</code> downloads any newer images;</li> <li><code>docker-compose up -d</code> causes any newly-downloaded images to be instantiated as containers (replacing the old containers); and</li> <li>the <code>prune</code> gets rid of the outdated images.</li> </ul> <p>This strategy doesn't work when a Dockerfile is used to build a local image on top of a base image downloaded from DockerHub. The local image is what is running so there is no way for the <code>pull</code> to sense when a newer version becomes available.</p> <p>The only way to know when an update to Telegraf is available is to check the Telegraf tags page on DockerHub.</p> <p>Once a new version appears on DockerHub, you can upgrade Telegraf like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose build --no-cache --pull telegraf\n$ docker-compose up -d telegraf\n$ docker system prune\n$ docker system prune\n</code></pre> <p>Breaking it down into parts:</p> <ul> <li><code>build</code> causes the named container to be rebuilt;</li> <li><code>--no-cache</code> tells the Dockerfile process that it must not take any shortcuts. It really must rebuild the local image;</li> <li><code>--pull</code> tells the Dockerfile process to actually check with DockerHub to see if there is a later version of the base image and, if so, to download it before starting the build;</li> <li><code>telegraf</code> is the named container argument required by the <code>build</code> command.</li> </ul> <p>Your existing Telegraf container continues to run while the rebuild proceeds. Once the freshly-built local image is ready, the <code>up</code> tells <code>docker-compose</code> to do a new-for-old swap. There is barely any downtime for your service.</p> <p>The <code>prune</code> is the simplest way of cleaning up. The first call removes the old local image. The second call cleans up the old base image. Whether an old base image exists depends on the version of <code>docker-compose</code> you are using and how your version of <code>docker-compose</code> builds local images.</p>"},{"location":"Containers/Telegraf/#versionPinning","title":"Telegraf version pinning","text":"<p>If you need to pin Telegraf to a particular version:</p> <ol> <li> <p>Use your favourite text editor to open the following file:</p> <pre><code>~/IOTstack/.templates/telegraf/Dockerfile\n</code></pre> </li> <li> <p>Find the line:</p> <pre><code>FROM telegraf:latest\n</code></pre> </li> <li> <p>Replace <code>latest</code> with the version you wish to pin to. For example, to pin to version 1.19.3:</p> <pre><code>FROM telegraf:1.19.3\n</code></pre> </li> <li> <p>Save the file and tell <code>docker-compose</code> to rebuild the local image:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d --build telegraf\n$ docker system prune\n</code></pre> <p>The new local image is built, then the new container is instantiated based on that image. The <code>prune</code> deletes the old local image.</p> </li> </ol> <p>Note:</p> <ul> <li>As well as preventing Docker from updating the base image, pinning will also block incoming updates to the Dockerfile from a <code>git pull</code>. Nothing will change until you decide to remove the pin.</li> </ul>"},{"location":"Containers/Timescaledb/","title":"Timescaledb","text":""},{"location":"Containers/Timescaledb/#default-port-changed","title":"Default port changed","text":"<p>In order to avoid port conflict with PostgreSQL, the public database port is mapped to 5433 using Docker.</p> <p>Cross-container access from other containers still works as previously: <code>timescaledb:5432</code>.</p>"},{"location":"Containers/WireGuard/","title":"WireGuard","text":"<p>WireGuard is a fast, modern, secure Virtual Private Network (VPN) tunnel. It can securely connect you to your home network, allowing you to access your home network's local services from anywhere. It can also secure your traffic when using public internet connections.</p> <p>Reference:</p> <ul> <li>WireGuard home page</li> <li>IOTstack discussion paper : ZeroTier vs WireGuard</li> <li>2022-10-01 WireGuard migration</li> </ul> <p>Assumptions:</p> <ul> <li>These instructions assume that you have privileges to configure your network's gateway (router). If you are not able to make changes to your network's firewall settings, then you will not be able to finish this setup.</li> <li>In common with most VPN technologies, WireGuard assumes that the WAN side of your network's gateway has a public IP address which is reachable directly. WireGuard may not work if that assumption does not hold. If you strike this problem, read ZeroTier vs WireGuard.</li> </ul>"},{"location":"Containers/WireGuard/#installWireguard","title":"Installing WireGuard under IOTstack","text":"<p>You increase your chances of a trouble-free installation by performing the installation steps in the following order.</p>"},{"location":"Containers/WireGuard/#updateRaspbian","title":"Step 1: Update your Raspberry Pi OS","text":"<p>To be able to run WireGuard successfully, your Raspberry Pi needs to be fully up-to-date. If you want to understand why, see the read only flag.</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade -y\n</code></pre>"},{"location":"Containers/WireGuard/#obtainDDNS","title":"Step 2: Set up a Dynamic DNS name","text":"<p>Before you can use WireGuard (or any VPN solution), you need a mechanism for your remote clients to reach your home router. You have two choices:</p> <ol> <li>Obtain a permanent IP address for your home router from your Internet Service Provider (ISP). Approach your ISP if you wish to pursue this option. It generally involves additional charges.</li> <li>Use a Dynamic DNS service. See IOTstack documentation Accessing your device from the internet. The rest of this documentation assumes you have chosen this option.</li> </ol>"},{"location":"Containers/WireGuard/#serviceDefinition","title":"Step 3: Understand the Service Definition","text":"<p>This is the service definition template that IOTstack uses for WireGuard:</p> <pre><code>wireguard:\n  container_name: wireguard\n  image: ghcr.io/linuxserver/wireguard\n  restart: unless-stopped\n  environment:\n    - PUID=1000\n    - PGID=1000\n    - TZ=${TZ:-Etc/UTC}\n    - SERVERURL=your.dynamic.dns.name\n    - SERVERPORT=51820\n    - PEERS=laptop,phone,tablet\n    - PEERDNS=auto\n    - ALLOWEDIPS=0.0.0.0/0\n  ports:\n    - \"51820:51820/udp\"\n  volumes:\n    - ./volumes/wireguard/config:/config\n    - ./volumes/wireguard/custom-cont-init.d:/custom-cont-init.d\n    - ./volumes/wireguard/custom-services.d:/custom-services.d\n  cap_add:\n    - NET_ADMIN\n  sysctls:\n    - net.ipv4.conf.all.src_valid_mark=1\n</code></pre> <p>Unfortunately, that service definition will not work \"as is\". It needs to be configured.</p> <p>Key points:</p> <ul> <li>Everything in the <code>environment:</code> section from <code>SERVERURL=</code> down to <code>PEERDNS=</code> (inclusive) affects WireGuard's generated configurations (the QR codes). In other words, any time you change any of those values, any existing QR codes will stop working.</li> </ul>"},{"location":"Containers/WireGuard/#configureWhat","title":"Step 4: Decide what to configure","text":"<p>With most containers, you can continue to tweak environment variables and settings without upsetting the container's basic behaviour. WireGuard is a little different. You really need to think, carefully, about how you want to configure the service before you start. If you change your mind later, you generally have to start from a clean slate.</p>"},{"location":"Containers/WireGuard/#configureAlways","title":"Fields that you should always configure","text":"<ul> <li> <p><code>SERVERURL=</code> should be set to the domain name you have registered with a Dynamic DNS service provider. Example:</p> <pre><code>- SERVERURL=downunda.duckdns.org\n</code></pre> </li> <li> <p><code>PEERS=</code> should be a comma-separated list of your client devices (all the phones, tablets, laptops, desktops you want to use remotely to get back into your home network). Example:</p> <pre><code>- PEERS=jillMacbook,jackChromebook,alexNokiaG10\n</code></pre> <p>Notes:</p> <ul> <li>Many examples on the web use \"PEERS=n\" where \"n\" is a number. In practice, that approach seems to be a little fragile and is not recommended for IOTstack.</li> <li>Each name needs to start with a letter and be followed by one or more letters and/or digits. Letters can be upper- or lower-case. Do not use any other characters.</li> </ul> </li> </ul>"},{"location":"Containers/WireGuard/#configurePeerDNS","title":"Optional configuration - DNS resolution for peers","text":"<p>You have several options for how your remote peers resolve DNS requests:</p> <ul> <li> <p><code>PEERDNS=auto</code></p> <p>DNS queries made on connected WireGuard clients should work as if they were made on the host. If you configure PiHole into the host's <code>resolveconf.conf</code>, Wireguard clients will also automatically use it.</p> <p>Details:</p> <ul> <li>The default value of <code>auto</code> instructs the WireGuard service running within the WireGuard container to use a DNS-service, coredns, also running in the Wireguard container. Coredns by default directs queries to 127.0.0.11, which Docker intercepts and forwards to whichever resolvers are specified in the Raspberry Pi's <code>/etc/resolv.conf</code>.</li> </ul> </li> <li> <p><code>PEERDNS=auto</code> with <code>custom-cont-init</code></p> <p>This configuration instructs WireGuard to forward DNS queries from remote peers to any host daemon or container which is listening on port 53. This is the option you will want to choose if you are running an ad-blocking DNS server (eg PiHole or AdGuardHome) in a container on the same host as WireGuard, and you want your remote clients to obtain DNS resolution via the ad-blocker, but don't want your Raspberry Pi host to use it.</p> <p>Acknowledgement: thanks to @ukkopahis for developing this option.</p> <p>To activate this feature:</p> <ol> <li>Make sure your WireGuard service definition contains <code>PEERDNS=auto</code>.</li> <li> <p>Start the WireGuard container by executing:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d wireguard\n</code></pre> <p>This ensures that the <code>~/IOTstack/volumes/wireguard</code> folder structure is created and remote client configurations are (re)generated properly.</p> </li> <li> <p>Run the following commands:  </p> <pre><code>$ cd ~/IOTstack\n$ sudo cp ./.templates/wireguard/use-container-dns.sh ./volumes/wireguard/custom-cont-init.d/\n$ docker-compose restart wireguard\n</code></pre> <p>The presence of <code>use-container-dns.sh</code> causes WireGuard to redirect incoming DNS queries to the default gateway on the internal bridged network. That, in turn, results in the queries being forwarded to any other container that is listening for DNS traffic on port 53. It does not matter if that other container is PiHole, AdGuardHome, bind9 or any other kind of DNS server.</p> <p>Do note, however, that this configuration creates a dependency between WireGuard and the container providing DNS resolution. You may wish to make that explicit in your <code>docker-compose.yml</code> by adding these lines to your WireGuard service definition:</p> <pre><code>depends_on:\n  - pihole\n</code></pre> <p>Substitute <code>adguardhome</code> or <code>bind9</code> for <code>pihole</code>, as appropriate.</p> </li> </ol> <p>Once activated, this feature will remain active until you decide to deactivate it. If you ever wish to deactivate it, run the following commands:</p> <pre><code>$ cd ~/IOTstack\n$ sudo rm ./volumes/wireguard/custom-cont-init.d/use-container-dns.sh\n$ docker-compose restart wireguard\n</code></pre> </li> <li> <p><code>PEERDNS=\u00abip address\u00bb</code></p> <p>A third possibility is if you have a local upstream DNS server. You can specify the IP address of that server so that remote peers receive DNS resolution from that host. For example:</p> <pre><code>- PEERDNS=192.168.203.65\n</code></pre> <p>Do note that changes to <code>PEERDNS</code> will not be updated to existing clients, and as such you may want to use <code>PEERDNS=auto</code> unless you have a very specific requirement.</p> </li> </ul>"},{"location":"Containers/WireGuard/#configurePorts","title":"Optional configuration - WireGuard ports","text":"<p>The WireGuard service definition template follows the convention of using UDP port \"51820\" in three places. You can leave it like that and it will just work. There is no reason to change the defaults unless you want to.</p> <p>To understand what each port number does, it is better to think of them like this:</p> <pre><code>environment:\n- SERVERPORT=\u00abpublic\u00bb\nports:\n- \"\u00abexternal\u00bb:\u00abinternal\u00bb/udp\"\n</code></pre> <p>These definitions are going to be used throughout this documentation:</p> <ul> <li> <p>The \u00abpublic\u00bb port is the port number that your remote WireGuard clients (phone, laptop etc) will try to reach. This is the port number that your router needs to expose to the outside world.</p> </li> <li> <p>The \u00abexternal\u00bb port is the port number that Docker, running on your Raspberry Pi, will be listening on. Your router needs to forward WireGuard incoming traffic to the \u00abexternal\u00bb port on your Raspberry Pi.</p> </li> <li> <p>The \u00abinternal\u00bb port is the port number that WireGuard (the server process) will be listening on inside the WireGuard container. Docker handles forwarding between the \u00abexternal\u00bb and \u00abinternal\u00bb port.</p> </li> </ul> <p>Rule #1:</p> <ul> <li>You can change the \u00abpublic\u00bb and \u00abexternal\u00bb ports but you can't change the \u00abinternal\u00bb port unless you are prepared to do a lot more work.</li> </ul> <p>Rule #2:</p> <ul> <li>The \u00abpublic\u00bb port forms part of the QR codes. If you decide to change the \u00abpublic\u00bb port after you generate the QR codes, you will have to start over from a clean slate.</li> </ul> <p>Rule #3:</p> <ul> <li>Your router needs to know about both the \u00abpublic\u00bb and \u00abexternal\u00bb ports so, if you decide to change either of those, you must also reconfigure your router.</li> </ul> <p>See Understanding WireGuard's port numbers if you want more information on how the various port numbers are used.</p>"},{"location":"Containers/WireGuard/#configureWireGuard","title":"Step 5: Configure WireGuard","text":"<p>There are two approaches:</p> <ol> <li>Let the menu generate a <code>docker-compose.yml</code> with the default WireGuard service definition template, and then edit <code>docker-compose.yml</code>.</li> <li>Prepare a <code>compose-override.yml</code> file, then run the menu and have it perform the substitutions for you.</li> </ol> <p>Of the two, the first is generally the simpler and means you don't have to re-run the menu whenever you want to change WireGuard's configuration.</p>"},{"location":"Containers/WireGuard/#editCompose","title":"Method 1: Configure WireGuard by editing <code>docker-compose.yml</code>","text":"<ol> <li> <p>Run the menu:</p> <pre><code>$ cd ~/IOTstack\n$ ./menu.sh\n</code></pre> </li> <li> <p>Choose the \"Build Stack\" option.</p> </li> <li>If WireGuard is not already selected, select it.</li> <li>Press enter to begin the build.</li> <li>Choose Exit.</li> <li>Open <code>docker-compose.yml</code> in your favourite text editor.</li> <li>Navigate to the WireGuard service definition.</li> <li>Implement the decisions you took in decide what to configure.</li> <li>Save your work.</li> </ol>"},{"location":"Containers/WireGuard/#editOverride","title":"Method 2: Configure WireGuard using <code>compose-override.yml</code>","text":"<p>The Custom services and overriding default settings for IOTstack page describes how to use an override file to allow the menu to incorporate your custom configurations into the final <code>docker-compose.yml</code> file.</p> <p>You will need to create the <code>compose-override.yml</code> before running the menu to build your stack. If you have already built your stack, you'll have to rebuild it after creating <code>compose-override.yml</code>.</p> <ol> <li> <p>Use your favourite text editor to create (or open) the override file. The file is expected to be at the path:</p> <pre><code>~/IOTstack/compose-override.yml\n</code></pre> </li> <li> <p>Define overrides to implement the decisions you took in Decide what to configure. For example:</p> <pre><code>services:\n  wireguard:\n    environment:\n    - PUID=1000\n    - PGID=1000\n    - TZ=${TZ:-Etc/UTC}\n    - SERVERURL=downunda.duckdns.org\n    - SERVERPORT=51820\n    - PEERS=laptop,phone,tablet\n    - PEERDNS=auto\n    - ALLOWEDIPS=0.0.0.0/0\n</code></pre> <p>Key points:</p> <ul> <li>The override file works at the section level. Therefore, you have to include all of the environment variables from the template, not just the ones you want to alter.</li> <li>If your override file contains configurations for other containers, make sure the file only has a single <code>services:</code> directive at the start.</li> </ul> </li> <li> <p>Save your work.</p> </li> <li> <p>Run the menu:</p> <pre><code>$ cd ~/IOTstack\n$ ./menu.sh\n</code></pre> </li> <li> <p>Choose the \"Build Stack\" option.</p> </li> <li>If WireGuard is not already selected, select it.</li> <li>Press enter to begin the build.</li> <li>Choose Exit.</li> <li> <p>Check your work by running:</p> <pre><code>$ cat docker-compose.yml\n</code></pre> <p>and verify that the <code>wireguard</code> service definition is as you expect.</p> </li> </ol>"},{"location":"Containers/WireGuard/#startWireGuard","title":"Step 6: Start WireGuard","text":"<ol> <li> <p>To start WireGuard, bring up your stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> </li> <li> <p>Confirm that WireGuard has started properly by running:</p> <pre><code>$ docker ps --format \"table {{.Names}}\\t{{.RunningFor}}\\t{{.Status}}\" --filter name=wireguard\n</code></pre> <p>Repeat the command a few times with a short delay in between. You are looking for signs that the WireGuard container is restarting. If the container seems to be restarting then this command is your friend:</p> <pre><code>$ docker logs wireguard\n</code></pre> <p>See also discussion of the read-only flag.</p> </li> <li> <p>Confirm that WireGuard has generated the expected configurations. For example, given the following setting in <code>docker-compose.yml</code>:</p> <pre><code>- PEERS=jillMacbook,jackChromebook,alexNokiaG10\n</code></pre> <p>you would expect a result something like this:</p> <pre><code>$ tree ./volumes/wireguard/config\n./volumes/wireguard/config\n\u251c\u2500\u2500 coredns\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Corefile\n\u251c\u2500\u2500 peer_alexNokiaG10\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer_alexNokiaG10.conf\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer_alexNokiaG10.png\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 presharedkey-peer_alexNokiaG10\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 privatekey-peer_alexNokiaG10\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 publickey-peer_alexNokiaG10\n\u251c\u2500\u2500 peer_jackChromebook\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer_jackChromebook.conf\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer_jackChromebook.png\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 presharedkey-peer_jackChromebook\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 privatekey-peer_jackChromebook\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 publickey-peer_jackChromebook\n\u251c\u2500\u2500 peer_jillMacbook\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer_jillMacbook.conf\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer_jillMacbook.png\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 presharedkey-peer_jillMacbook\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 privatekey-peer_jillMacbook\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 publickey-peer_jillMacbook\n\u251c\u2500\u2500 server\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 privatekey-server\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 publickey-server\n\u251c\u2500\u2500 templates\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 peer.conf\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 server.conf\n\u2514\u2500\u2500 wg0.conf\n</code></pre> <p>Notice how each element in the <code>PEERS=</code> list is represented by a sub-directory prefixed with <code>peer_</code>. You should expect the same pattern for your peers.</p> </li> </ol>"},{"location":"Containers/WireGuard/#clientQRcodes","title":"Step 7: Save your WireGuard client configuration files (QR codes)","text":"<p>The first time you launch WireGuard, it generates cryptographically protected configurations for your remote clients and encapsulates those configurations in QR codes. You can see the QR codes by running:</p> <pre><code>$ docker logs wireguard\n</code></pre> <p>WireGuard's log is ephemeral, which means it resets each time the container is re-created. In other words, you can't rely on going back to the log to obtain your QR codes if you lose them.</p> <p>WireGuard also records the QR codes as <code>.png</code> files. In fact, the QR codes shown by <code>docker logs wireguard</code> are just side-effects of the <code>.png</code> files as they are created.</p> <p>If your Raspberry Pi has a GUI (such as a screen attached to an HDMI port or a VNC connection), you can always retrieve the QR codes by opening the <code>.png</code> files in the GUI.</p> <p>If, however, your Raspberry Pi is running headless, you will need to copy the <code>.png</code> files to a system that is capable of displaying them, such as a Mac or PC. You can use SCP to do that.</p> <p>See ssh tutorial if you need help setting up SSH (of which SCP is a part).</p> <p>For example, to copy all PNG files from your Raspberry Pi to a target system:</p> <pre><code>$ find ~/IOTstack/volumes/wireguard/config -name \"*.png\" -exec scp {} user@hostorip:. \\;\n</code></pre> <p>Note:</p> <ul> <li><code>hostorip</code> is the host name, fully-qualified domain name, multicast domain name or IP address of the GUI-capable target computer; and</li> <li><code>user</code> is a valid username on the target computer.</li> </ul> <p>If you want to work in the other direction (ie from the GUI-capable system), you can try:</p> <pre><code>$ scp pi@hostorip:IOTstack/volumes/wireguard/peer_jill-macbook/peer_jill-macbook.png .\n</code></pre> <p>In this case:</p> <ul> <li><code>hostorip</code> is the host name, fully-qualified domain name, multicast domain name or IP address of the Raspberry Pi that is running WireGuard.</li> </ul> <p>Keep in mind that each QR code contains everything needed for any device to access your home network via WireGuard. Treat your <code>.png</code> files as \"sensitive documents\".</p>"},{"location":"Containers/WireGuard/#routerNATConfig","title":"Step 8: Configure your router with a NAT rule","text":"<p>A typical home network will have a firewall that effectively blocks all incoming attempts from the Internet to open a new connection with a device on your network.</p> <p>To use a VPN from outside of your home network (which is precisely the point of running the service!), you need to configure your router to allow incoming WireGuard traffic to reach the Raspberry Pi running WireGuard. These instructions assume you have the privileges to do that.</p> <p>If you have not used your router's administrative interface before, the default login credentials may be physically printed on the device or in its instruction manual.</p> <p>If you have never changed the default login credentials, you should take the time to do that. </p> <p>Routers have wildly different user interfaces but the concepts will be the same. This section describes the basic technique but if you are unsure how to do this on your particular router model, the best idea would be to search the web for:</p> <ul> <li>\"[YOUR DEVICE NAME] port forwarding configuration\"; or</li> <li>\"[YOUR DEVICE NAME] NAT configuration\"</li> </ul> <p>A typical configuration process goes something like this:</p> <ol> <li>The router sub-process you need to configure is called Network Address Translation (NAT) but it's not unheard of for this functionality to be grouped with FireWall.</li> <li> <p>The NAT component you are looking for probably has a name like \"Port Redirection\", \"Port Forwarding\", \"NAT Forwarding\" or \"NAT Virtual Server\".</p> <ul> <li>It might also be under \"Open Ports\" but those are usually one-to-one mappings (ie incomingPort=outgoingPort), apply to port ranges, and are intended to target a single DMZ host.</li> </ul> </li> <li> <p>The configuration screen will contain at least the following fields:</p> Field Value Interface router's WAN interface Private IP x.x.x.x Private Port \u00abexternal\u00bb Protocol UDP Public Port \u00abpublic\u00bb Service Name WireGuard <p>The fields in the above list are in alphabetical order. They will almost certainly be in a different order in your router and may also have different names:</p> <ul> <li>Interface is typically a popup menu. Generally it will either default to the name of the physical port on your router that connects to the outside world, or be some other sensible default like \"All\".</li> <li>Private IP (or Internal IP) is the IP address of the Raspberry Pi running WireGuard. Note that this pretty much forces you to give your Raspberry Pi a statically-configured IP address (either a static binding in your DHCP server or a hard-coded address in the Raspberry Pi itself).</li> <li> <p>Private Port (or Internal Port) needs to be the value you chose for \u00abexternal\u00bb in the WireGuard service definition (51820 if you didn't change it).</p> <p>Yes, this does sound counterintuitive but it's a matter of perspective. From the router's perspective, the port is on the private or internal part of your home network. From Docker's perspective, the port is \u00abexternal\u00bb to container-space.</p> </li> <li> <p>Protocol will usually default to \"TCP\" but you must change it to \"UDP\".</p> </li> <li>Public Port or External Port needs to be the value you chose for \u00abpublic\u00bb in the WireGuard service definition (51820 if you didn't change it).</li> <li>Service Name (or Service Type) is typically a text field, an editable menu (where you can either make a choice or type your own value), or a button approximating an editable menu. If you are given the option of choosing \"WireGuard\", do that, otherwise just type that name into the field. It has no significance other than reminding you what the rule is for. </li> </ul> </li> </ol>"},{"location":"Containers/WireGuard/#configureClients","title":"Step 9: Configure your remote WireGuard clients","text":"<p>This is a massive topic and one which is well beyond the scope of this guide. You really will have to work it out for yourself. Start by Googling:</p> <ul> <li>\"[YOUR DEVICE NAME] install WireGuard client\".</li> </ul> <p>You will find the list of client software at WireGuard Installation.</p> <p>For portable devices (eg iOS and Android) it usually boils down to:</p> <ol> <li>Install the app on your portable device.</li> <li>Display the QR code the WireGuard server generated for the device.</li> <li>Launch the app.</li> <li>Point the device's camera at the QR code.</li> <li>Follow your nose.</li> </ol>"},{"location":"Containers/WireGuard/#understandingPorts","title":"Understanding WireGuard's port numbers","text":"<p>Here's a concrete example configuration using three different port numbers:</p> <pre><code>environment:\n- SERVERURL=downunda.duckdns.org\n- SERVERPORT=51620\nports:\n- \"51720:51820/udp\"\n</code></pre> <p>In other words:</p> <ol> <li>The \u00abpublic\u00bb port is 51620.</li> <li>The \u00abexternal\u00bb port is 51720.</li> <li>The \u00abinternal\u00bb port is 51820.</li> </ol> <p>You also need to make a few assumptions:</p> <ol> <li>The host running the remote WireGuard client (eg a mobile phone with the WireGuard app installed) has been allocated the IP address 55.66.77.88 when it connected to the Internet over 3G/4G/5G.</li> <li>When the remote WireGuard client initiated the session, it chose UDP port 44524 as its source port. The actual number chosen is (essentially) random and only significant to the client.</li> <li>Your Internet Service Provider allocated the IP address 12.13.14.15 to the WAN side of your router.</li> <li>You have done all the steps in Set up a Dynamic DNS name and your WAN IP address (12.13.14.15) is being propagated to your Dynamic DNS service provider.</li> </ol> <p>Here's a reference model to help explain what occurs:</p> <p></p> <p>The remote WireGuard client:</p> <ol> <li>Obtains the Dynamic DNS domain name (\"downunda.duckdns.org\") and \u00abpublic\u00bb UDP port (51620) from the configuration contained within the QR code. Recall that those values are obtained from the <code>SERVERURL=</code> and <code>SERVERPORT=</code> environment variables in <code>docker-compose.yml</code>.</li> <li>Executes a DNS query for the domain name \"downunda.duckdns.org\" to obtains the WAN IP address (12.13.14.15) of your home router.</li> <li>Addresses outgoing packets to 12.13.14.15:51620.</li> </ol> <p>You configure a NAT port-forwarding rule in your router which accepts incoming traffic on the \u00abpublic\u00bb UDP port (51620) and uses Network Address Translation to change the destination IP address to the Raspberry Pi and destination port to the \u00abexternal\u00bb UDP port (51720). In other words, each incoming packet is readdressed to 192.168.203.60:51720.</p> <p>Docker is listening to the Raspberry Pi's \u00abexternal\u00bb UDP port 51720. Docker uses Network Address Translation to change the destination IP address to the WireGuard container and destination port to the \u00abinternal\u00bb UDP port (51820). In other words, each incoming packet is readdressed to 172.18.0.6:51820.</p> <p>The packet is then routed to the internal bridged network, and delivered to the WireGuard server process running in the container which is listening on the \u00abinternal\u00bb UDP port (51820).</p> <p>A reciprocal process occurs when the WireGuard server process sends packets back to the remote WireGuard client.</p> <p>The following table summarises the transformations as the client and server exchange information:</p> <p></p> <p>Even if you use port 51820 everywhere (the default), all this Network Address Translation still occurs. Keep this in mind if you are trying to debug WireGuard because you may actually find it simpler to understand what is going on if you use different numbers for the \u00abpublic\u00bb and \u00abexternal\u00bb ports.</p> <p>This model is a slight simplification because the remote client may also be also operating behind a router performing Network Address Translation. It is just easier to understand the basic concepts if you assume the remote client has a publicly-routable IP address.</p>"},{"location":"Containers/WireGuard/#debugging","title":"Debugging techniques","text":""},{"location":"Containers/WireGuard/#tcpdumpExternal","title":"Monitor WireGuard traffic between your router and your Raspberry Pi","text":"<p>If <code>tcpdump</code> is not installed on your Raspberry Pi, you can install it by:</p> <pre><code>$ sudo apt install tcpdump\n</code></pre> <p>After that, you can capture traffic between your router and your Raspberry Pi by:</p> <pre><code>$ sudo tcpdump -i eth0 -n udp port \u00abexternal\u00bb\n</code></pre> <p>Press ctrlc to terminate the capture.</p>"},{"location":"Containers/WireGuard/#tcpdumpInternal","title":"Monitor WireGuard traffic between your Raspberry Pi and the WireGuard container","text":"<p>First, you need to add <code>tcpdump</code> to the container. You only need to do this once per debugging session. The package will remain in place until the next time you re-create the container.</p> <pre><code>$ docker exec wireguard bash -c 'apt update ; apt install -y tcpdump'\n</code></pre> <p>To monitor traffic:</p> <pre><code>$ docker exec -t wireguard tcpdump -i eth0 -n udp port \u00abinternal\u00bb\n</code></pre> <p>Press ctrlc to terminate the capture.</p>"},{"location":"Containers/WireGuard/#listenExternal","title":"Is Docker listening on the Raspberry Pi's \u00abexternal\u00bb port?","text":"<pre><code>$ PORT=\u00abexternal\u00bb; sudo nmap -sU -p $PORT 127.0.0.1 | grep \"$PORT/udp\"\n</code></pre> <p>There will be a short delay. The expected answer is either:</p> <ul> <li><code>\u00abexternal\u00bb/udp open|filtered unknown</code> = Docker is listening</li> <li><code>\u00abexternal\u00bb/udp closed unknown</code> = Docker is not listening</li> </ul> <p>Success implies that the container is also listening.</p>"},{"location":"Containers/WireGuard/#listenPublic","title":"Is your router listening on the \u00abpublic\u00bb port?","text":"<pre><code>$ PORT=\u00abpublic\u00bb; sudo nmap -sU -p $PORT downunda.duckdns.org | grep \"$PORT/udp\"\n</code></pre> <p>There will be a short delay. The expected answer is either:</p> <ul> <li><code>\u00abpublic\u00bb/udp open|filtered unknown</code> = router is listening</li> <li><code>\u00abpublic\u00bb/udp closed unknown</code> = router is not listening</li> </ul> <p>Note:</p> <ul> <li>Some routers always return the same answer irrespective of whether the router is or isn't listening to the port being checked. This stops malicious users from working out which ports might be open. This test will not be useful if your router behaves like that. You will have to rely on <code>tcpdump</code> telling you whether your router is forwarding traffic to your Raspberry Pi.</li> </ul>"},{"location":"Containers/WireGuard/#readOnlyFlag","title":"The read-only flag","text":"<p>The <code>:ro</code> at the end of the following line in WireGuard's service definition means \"read only\":</p> <pre><code>- /lib/modules:/lib/modules:ro\n</code></pre> <p>If that flag is omitted then WireGuard may try to update the <code>/lib/modules</code> path in your operating system. To be clear, <code>/lib/modules</code> is both outside the WireGuard container and outside the normal persistent storage area in the <code>./volumes</code> directory.</p> <p>The basic idea of containers is that processes are contained, include all their own dependencies, can be added and removed cleanly, and don't change the underlying operating system.</p> <p>Writing into <code>/lib/modules</code> is not needed on a Raspberry Pi, providing that Raspberry Pi OS is up-to-date. That is why the first step in the installation procedure tells you to bring the system up-to-date.</p> <p>If WireGuard refuses to install and you have good reason to suspect that WireGuard may be trying to write to <code>/lib/modules</code> then you can consider removing the <code>:ro</code> flag and re-trying. Just be aware that WireGuard will likely be modifying your operating system.  </p>"},{"location":"Containers/WireGuard/#pullWireguard","title":"Updating WireGuard","text":"<p>To update the WireGuard container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull wireguard\n</code></pre> <p>If a new image comes down, then:</p> <pre><code>$ docker-compose up -d wireguard\n$ docker system prune\n</code></pre>"},{"location":"Containers/WireGuard/#migrateWireguard","title":"2022-10-01 WireGuard migration","text":"<p>WireGuard's designers have redefined the structure they expect in the persistent storage area. Before the change, a single volume-mapping got the job done:</p> <pre><code>volumes:\n- ./volumes/wireguard:/config\n</code></pre> <p>After the change, three mappings are required:</p> <pre><code>volumes:\n- ./volumes/wireguard/config:/config\n- ./volumes/wireguard/custom-cont-init.d:/custom-cont-init.d\n- ./volumes/wireguard/custom-services.d:/custom-services.d\n</code></pre> <p>In essence, inside the container:</p> <ul> <li>old: <code>custom-cont-init.d</code> and <code>custom-services.d</code> directories were subdirectories of <code>/config</code>;</li> <li>new: <code>custom-cont-init.d</code> and <code>custom-services.d</code> are top-level directories alongside <code>/config</code>.</li> </ul> <p>The new <code>custom-cont-init.d</code> and <code>custom-services.d</code> directories also need to be owned by root. Previously, they could be owned by \"pi\".</p> <p>IOTstack users implementing WireGuard for the first time will get the correct structure. Existing users need to migrate. The process is a little messy so IOTstack provides a script to automate the restructure:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down wireguard\n$ ./scripts/2022-10-01-wireguard-restructure.sh\n</code></pre> <p>see also if downing a container doesn't work</p> <p>In words:</p> <ul> <li>Be in the correct directory</li> <li>Stop WireGuard (the script won't run if you don't do this)</li> <li>Run the script</li> </ul> <p>The script:</p> <ol> <li>Renames <code>./volumes/wireguard</code> to <code>./volumes/wireguard.bak</code>; then</li> <li>Builds the new <code>./volumes/wireguard</code> structure using <code>./volumes/wireguard.bak</code> for its source material.</li> <li>Finishes by reminding you to update your <code>docker-compose.yml</code> to adopt the new service definition.</li> </ol> <p>Your WireGuard client configurations (QR codes) are not affected by the migration.</p> <p>Once the migration is complete and you have adopted the new service definition, you can start WireGuard again:</p> <pre><code>$ docker-compose up -d wireguard\n</code></pre> <p>You should test that your remote clients can still connect. Assuming a successful migration, you can safely delete the backup directory:</p> <pre><code>$ sudo rm -rf ./volumes/wireguard.bak\n</code></pre> <p>Always be careful when using <code>sudo</code> in conjunction with recursive remove. Double-check everything before pressing return.</p>"},{"location":"Containers/WireGuard/#cleanSlate","title":"Getting a clean slate","text":"<p>If WireGuard misbehaves, you can start over from a clean slate. You may also need to do this if you change any of the following environment variables:</p> <pre><code>- SERVERURL=\n- SERVERPORT=\n- PEERS=\n- PEERDNS=\n</code></pre> <p>The procedure is:</p> <ol> <li> <p>If WireGuard is running, terminate it:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down wireguard\n</code></pre> <p>see also if downing a container doesn't work</p> </li> <li> <p>Erase the persistent storage area (essential):</p> <pre><code>$ sudo rm -rf ./volumes/wireguard\n</code></pre> <p>Be very careful with that command and double-check your work before you hit return.</p> <p>Erasing the persistent storage area:</p> <ul> <li>destroys the old client configurations and invalidates any copies of QR codes. Existing clients will stop working until presented with a new QR code.</li> <li>deactivates <code>PEERDNS=auto</code> with <code>custom-cont-init</code>.</li> </ul> </li> <li> <p>Start WireGuard:</p> <pre><code>$ docker-compose up -d wireguard\n</code></pre> <p>This will generate new client configurations and QR codes for your devices.</p> <p>Remember to re-activate <code>PEERDNS=auto</code> with <code>custom-cont-init</code> if you need it.</p> </li> </ol>"},{"location":"Containers/WordPress/","title":"WordPress","text":"<p>WordPress is a web content-management system.</p>"},{"location":"Containers/WordPress/#resources","title":"Resources","text":"<ul> <li> <p>WordPress home page</p> <ul> <li>documentation</li> </ul> </li> <li> <p>DockerHub</p> </li> <li>GitHub</li> </ul>"},{"location":"Containers/WordPress/#overview","title":"Overview","text":"<p>You need to perform two steps before WordPress can be launched:</p> <ol> <li>Install the service definition.</li> <li>Configure the environment.</li> </ol> <p>Note:</p> <ul> <li>Do not \"up\" your stack until you have completed step 2.</li> </ul> <p></p>"},{"location":"Containers/WordPress/#install-the-service-definition","title":"Install the service definition","text":"<p>Be in the correct directory:</p> <pre><code>$ cd ~/IOTstack\n</code></pre>"},{"location":"Containers/WordPress/#option-1-the-iotstack-menu","title":"option 1 - the IOTstack menu","text":"<ol> <li> <p>Launch the menu</p> <pre><code>$ ./menu.sh\n</code></pre> </li> <li> <p>Choose \"Build Stack\".</p> </li> <li>Place the cursor on \"wordpress\" and press space to select it.</li> <li>Press enter to build the stack.</li> <li>Place the cursor on \"Exit\" and press enter.</li> </ol>"},{"location":"Containers/WordPress/#option-2-manual-from-iotstack-templates","title":"option 2 - manual from IOTstack templates","text":"<p>When IOTstack is cloned from GitHub, the default for your local copy of the repository is to be on the \"master\" branch. Master-branch templates are left-shifted by two spaces with respect to how they need to appear in <code>docker-compose.yml</code>. The following <code>sed</code> command prepends two spaces to the start of each line:</p> <pre><code>$ sed -e \"s/^/  /\" ./.templates/wordpress/service.yml &gt;&gt;docker-compose.yml\n</code></pre> <p>Templates on the \"old-menu\" branch already have proper alignment, so <code>cat</code> can be used:</p> <pre><code>$ cat ./.templates/wordpress/service.yml &gt;&gt;docker-compose.yml\n</code></pre> <p></p>"},{"location":"Containers/WordPress/#configure-the-environment","title":"Configure the environment","text":""},{"location":"Containers/WordPress/#check-dependency","title":"check dependency","text":"<p>The password-generation steps in the next section assume <code>uuidgen</code> is available on your system. The following command installs <code>uuidgen</code> if it is not present already:</p> <pre><code>$ [ -z \"$(which uuidgen)\" ] &amp;&amp; sudo apt update &amp;&amp; sudo apt install -y uuid-runtime\n</code></pre> <p></p>"},{"location":"Containers/WordPress/#generate-passwords","title":"generate passwords","text":"<p>WordPress relies on MariaDB, and MariaDB requires both a user password and a root password. You can generate the passwords like this:</p> <pre><code>$ echo \"WORDPRESS_DB_PASSWORD=$(uuidgen)\" &gt;&gt;~/IOTstack/.env\n$ echo \"WORDPRESS_ROOT_PASSWORD=$(uuidgen)\" &gt;&gt;~/IOTstack/.env\n</code></pre> <p>Key points:</p> <ol> <li> <p>You will not need to know either of these passwords in order to use WordPress.</p> <p>These passwords govern access to the WordPress database (the <code>wordpress_db</code> container). WordPress (the <code>wordpress</code> container) has a separate system of credentials. You set up an administrator account the first time you login to WordPress. </p> </li> <li> <p>You will not need to know either password in order to use the <code>mysql</code> command line interface to inspect the WordPress database. See accessing the MariaDB command line interface.</p> </li> <li>The WordPress database container does not expose any ports to the outside world. That means you can't use general-purpose MariaDB/MySQL GUI-based front-ends to reach the WordPress database.</li> <li>Both passwords are applied when the MariaDB container is first initialised. Changing either password value in <code>.env</code> will break your installation.</li> </ol> <p></p>"},{"location":"Containers/WordPress/#set-hostname","title":"set hostname","text":"<p>WordPress (running inside the container) needs to know the domain name of the host on which the container is running. You can satisfy the requirement like this:</p> <pre><code>$ echo \"WORDPRESS_HOSTNAME=$HOSTNAME.local\" &gt;&gt;~/IOTstack/.env\n</code></pre> <p>The above assumes the host is advertising a multicast domain name. This is a safe assumption for Raspberry Pis but may not necessarily be applicable in other situations. If your host is associated with a fully-qualified domain name (A record or CNAME), you can use that instead. For example:</p> <pre><code>$ echo \"WORDPRESS_HOSTNAME=iot-hub.my.domain.com\" &gt;&gt;~/IOTstack/.env\n</code></pre>"},{"location":"Containers/WordPress/#checking-your-wordpress-environment-values","title":"checking your WordPress environment values","text":"<p>You can confirm that the passwords and hostname have been added to <code>.env</code> like this:</p> <pre><code>$ grep \"^WORDPRESS\" ~/IOTstack/.env\nWORDPRESS_DB_PASSWORD=41dcbe76-9c39-4c7f-bd65-2f0421bccbeb\nWORDPRESS_ROOT_PASSWORD=ee749d72-f1a5-4bc0-b182-21e8284f9fd2\nWORDPRESS_HOSTNAME=raspberrypi.local\n</code></pre>"},{"location":"Containers/WordPress/#alternative-method","title":"alternative method","text":"<p>If you prefer to keep your environment values inline in your <code>docker-compose.yml</code> rather than in the <code>.env</code> file then you can achieve the same result by editing the service definitions as follows:</p> <ul> <li> <p><code>wordpress</code>:</p> <pre><code>  environment:\n    WORDPRESS_DB_PASSWORD: \u00abyourUserPasswordHere\u00bb\n  hostname: \u00abhostname\u00bb.\u00abdomain\u00bb\n</code></pre> </li> <li> <p><code>wordpress_db</code>:</p> <pre><code>  environment:\n    MYSQL_ROOT_PASSWORD: \u00abyourRootPasswordHere\u00bb\n    MYSQL_PASSWORD: \u00abyourUserPasswordHere\u00bb\n</code></pre> </li> </ul>"},{"location":"Containers/WordPress/#starting-wordpress","title":"Starting WordPress","text":"<pre><code>$ cd ~/IOTstack\n$ docker-compose up -d wordpress\n</code></pre> <p>This starts both WordPress and its database.</p> <p></p>"},{"location":"Containers/WordPress/#accessing-the-wordpress-gui","title":"Accessing the WordPress GUI","text":"<p>Use a URL in the following form, where <code>\u00abhost\u00bb</code> should be the value you chose at set hostname.</p> <pre><code>http://\u00abhost\u00bb:8084\n</code></pre> <p>Examples:</p> <ul> <li><code>http://raspberrypi.local:8084</code></li> <li><code>http://iot-hub.my.domain.com:8084</code></li> </ul> <p>You will be prompted to:</p> <ol> <li>Set your language; and</li> <li>Create your administrator account.</li> </ol> <p>After that, you should refer to the WordPress documentation.</p> <p></p>"},{"location":"Containers/WordPress/#about-mariadb","title":"About MariaDB","text":"<p>The MariaDB instance associated with WordPress is private to WordPress. It is included along with the WordPress service definition. You do not have to select MariaDB in the IOTstack menu.</p> <p>There is nothing stopping you from also selecting MariaDB in the IOTstack menu. Multiple instances of MariaDB will coexist quite happily but they are separate and distinct Relational Database Manager Systems (RDBMS).</p> <p></p>"},{"location":"Containers/WordPress/#accessing-the-mariadb-command-line-interface","title":"Accessing the MariaDB command line interface","text":"<p>If you need inspect or manipulate the WordPress database, begin by opening a shell into the WordPress MariaDB container:</p> <pre><code>$ docker exec -it wordpress_db bash\n</code></pre> <p>While you are in the shell, you can use the <code>MYSQL_ROOT_PASSWORD</code> environment variable to reference the root password. For example:</p> <pre><code># mysql -p$MYSQL_ROOT_PASSWORD\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\nYour MariaDB connection id is 169\nServer version: 10.11.6-MariaDB-log Alpine Linux\n\nCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nMariaDB [(none)]&gt;\n</code></pre> <p>Note:</p> <ul> <li>There is no space between the <code>-p</code> and <code>$MYSQL_ROOT_PASSWORD</code>. If you insert a space, <code>mysql</code> will prompt you to enter the password interactively.</li> </ul> <p>Once you have opened a session using <code>mysql</code>, you can execute MySQL commands. For example:</p> <pre><code>MariaDB [(none)]&gt; show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n| wordpress          |\n+--------------------+\n5 rows in set (0.010 sec)\n</code></pre> <p>To exit <code>mysql</code>, either press control+d or use the <code>exit</code> command:</p> <pre><code>MariaDB [(none)]&gt; exit\nBye\n\n#\n</code></pre> <p>Similarly, control+d or <code>exit</code> will terminate the container's <code>bash</code> shell and return you to the host's command line.</p>"},{"location":"Containers/WordPress/#references-to-nextcloud","title":"References to <code>nextcloud</code>","text":"<p>Both the <code>wordpress</code> and <code>wordpress_db</code> service definitions connect to the <code>nextcloud</code> network. </p> <p>Please note the emphasis on \"network\".</p> <p>The <code>nextcloud</code> network is an internal private network created by <code>docker-compose</code> to facilitate data-communications between a user-facing service (like WordPress) and an associated database back-end (like MariaDB).</p> <p>The NextCloud container was the first to use the private-network strategy so the \"nextcloud\" name is an accident of history. In an ideal world, the network would be renamed to something which more accurately reflected its purpose, like \"databases\". Unfortunately, the IOTstack menu lacks the facilities needed to update existing deployments so the most likely result of any attempt at renaming would be to break existing stacks.</p> <p>At runtime, the <code>nextcloud</code> network has the name <code>iotstack_nextcloud</code>, and exists alongside the <code>iotstack_default</code> network which is shared by other IOTstack containers.</p> <p>The material point is that, even though WordPress has nothing to do with NextCloud, the references to the <code>nextcloud</code> network are are not mistakes. They are intentional.</p>"},{"location":"Containers/WordPress/#getting-a-clean-slate","title":"Getting a clean slate","text":"<p>If you start the WordPress container and then decide that you need to change its environment variables, you must first erase the container's persistent store:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down wordpress wordpress_db\n$ sudo rm -rf ./volumes/wordpress\n</code></pre> <p>Notes:</p> <ul> <li>Both the <code>wordpress</code> and <code>wordpress_db</code> containers need to be taken down before the persistent store can be removed safely. </li> <li>Be very careful with the <code>sudo rm</code> command. Double-check before pressing the return key!</li> </ul> <p>Once the persistent store has been erased, you can change the environment variables.</p> <p>When you are ready, start WordPress again:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d wordpress\n</code></pre> <p>Note:</p> <ul> <li>The <code>wordpress_db</code> container does not need to be brought up explicitly. It is started automatically as a by-product of starting <code>wordpress</code>.</li> </ul>"},{"location":"Containers/X2go/","title":"x2go","text":"<p>x2go is an \"alternative\" to using VNC for a remote connection. It uses X11 forwarding over ssh to provide a desktop environment</p> <p>Reason for using: I have a Pi 4 and I didn't buy a micro hdmi cable. You can use VNC however you are limited to a 800x600 window.</p>"},{"location":"Containers/X2go/#installation","title":"Installation","text":"<p>Install with <code>sudo apt install x2goserver</code></p> <p>x2go cant connect to the native Raspbian Desktop so you will need to install another with <code>sudo tasksel</code></p> <p></p> <p>I chose Xfce because it is light weight.</p> <p>Install the x2go client from their website</p> <p>Now I have a full-screen client </p> <p></p>"},{"location":"Containers/X2go/#youtube-tutorial","title":"YouTube tutorial","text":"<p>Laurence systems</p>"},{"location":"Containers/ZeroTier-vs-WireGuard/","title":"ZeroTier vs WireGuard","text":"<p>ZeroTier and WireGuard are not mutually exclusive. You can run both if you wish. The purpose of this document is to try to offer some general guidance about the two solutions.</p>"},{"location":"Containers/ZeroTier-vs-WireGuard/#installation-differences","title":"Installation differences","text":"<p>Assume your goal is to give yourself access to your home network when you are on the road. This is something you can do with both WireGuard and ZeroTier.</p>"},{"location":"Containers/ZeroTier-vs-WireGuard/#wireguard","title":"WireGuard","text":"<p>Providing you follow IOTstack's WireGuard documentation faithfully, WireGuard is a bit easier to get going than ZeroTier.</p> <p>Although it helps to have some feeling for TCP/IP fundamentals, you definitely don't need to be a comms guru.</p> <p>Using WireGuard to access your home network when you are on the road involves:</p> <ol> <li> <p>A routable IP address on the WAN side of your home router.</p> <p>The IP address on the WAN side of your home router is allocated by your ISP. It can be fixed or dynamic. If you have not explicitly signed up for a fixed IP address service then your address is probably dynamic and can change each time you reboot your router, or if your ISP \"bounces\" your connection.</p> </li> <li> <p>If your WAN IP address is dynamic then you need a mechanism for making it discoverable using a Dynamic Domain Name System (DDNS) service such as DuckDNS or NoIP.com.</p> <p>That's a separate registration and setup process.</p> </li> <li> <p>A WireGuard server running in a Docker container on your Raspberry Pi. Ideally, you give some thought to the clients you will need so that the QR codes can be generated the first time you bring up the container.</p> </li> <li> <p>A WireGuard client running in each remote device. Each client needs to be configured with a QR code or configuration file created in the previous step.</p> </li> <li> <p>A port-forwarding rule in your home router so that traffic originated by remote WireGuard clients can be relayed to the WireGuard server running on your Raspberry Pi.</p> </li> </ol>"},{"location":"Containers/ZeroTier-vs-WireGuard/#zerotier","title":"ZeroTier","text":"<p>Implementing ZeroTier is not actually any more difficult to get going than WireGuard. ZeroTier's apparent complexity arises from the way it inherently supports many network topologies. Getting it set up to meet your requirements takes planning. </p> <p>You still don't need to be a comms guru but it will help if you've had some experience making TCP/IP do what you want.</p> <p>Using ZeroTier to access your home network when you are on the road involves:</p> <ol> <li> <p>Registering for a ZeroTier account (free and paid levels).</p> </li> <li> <p>Either (or both) of the following:</p> <ul> <li>A ZeroTier client running on every device at your home to which you need remote access;</li> <li>A ZeroTier-router client running in a Docker container on a Raspberry Pi at your home. This is analogous to the WireGuard server.</li> </ul> </li> <li> <p>A ZeroTier client running in each remote device.</p> </li> <li> <p>Every ZeroTier client (home and remote) needs to be provided with your ZeroTier network identifier. You also need to authorise each client to join your ZeroTier network. Together, these are the equivalent of WireGuard's QR code. </p> </li> <li> <p>Depending on what you want to achieve, you may need to configure one or more static routes in the ZeroTier Cloud and in your home router.</p> </li> </ol> <p>The things you don't need to worry about include:</p> <ul> <li>Whether the IP address on the WAN side of your home router is routable;</li> <li>Any port-forwarding rules in your home router; or</li> <li>Setting up a Dynamic Domain Name System (DDNS) service.</li> </ul>"},{"location":"Containers/ZeroTier-vs-WireGuard/#cgnat-wireguards-nemesis","title":"CGNAT \u2013 WireGuard's nemesis","text":"<p>Now that you have some appreciation for the comparative level of difficulty in setting up each service, let's focus on WireGuard's key problem.</p> <p>WireGuard depends on the IP address on the WAN side of your home router being routable. What that means is that the IP address has to be known to the routing tables of the core routers that drive the Internet.</p> <p>You will probably have seen quite a few of the addresses in the following table:</p> Table 1: Reserved IP Address Ranges <p>Nothing in that list is routable. That list is also far from complete (see wikipedia). The average IOTstack user has probably encountered at least:</p> <ul> <li>172.16/12 - commonly used by Docker to allocate its internal networks.</li> <li>192.168/16 - used by a lot of consumer equipment such as home routers.</li> </ul> Figure 1: Router WAN port using CGNAT range <p>Consider Figure 1. On the left is a cloud representing your home network where you probably use a subnet in the 192.168/16 range. The 192.168/16 range is not routable so, to exchange packets with the Internet, your home router needs to perform Network Address Translation (NAT).</p> <p>Assume a computer on your home network has the IP address 192.168.1.100 and wants to communicate with a service on the Internet. What the NAT service running in your home router does is:</p> <ul> <li>in the outbound direction, packets leaving your LAN will have a source IP address of 192.168.1.100. NAT replaces the source IP address with the IP address of the WAN side of your home router. Let's say that's 200.1.2.3.</li> <li>the system at the other end thinks the packets are coming from 200.1.2.3 so that's what it uses when it sends back reply packets.</li> <li>in the inbound direction, packets arrive with a destination IP address of 200.1.2.3. NAT replaces the destination address 200.1.2.3 with 192.168.1.100 and sends the packet to the device on your home network that originated the traffic.</li> </ul> <p>The NAT service running in your router builds tables that keep track of everything needed to make this work but, and this is a critical point, NAT can only build those tables when devices on your home LAN originate the traffic. If a packet addressed to your WAN IP arrives unexpectedly and NAT can't figure out what to do from its tables, the packet gets dropped.</p> <p>A remote WireGuard client trying to originate a connection with the WireGuard server running in your IOTstack is an example of an \"unexpected packet\". The reason it doesn't get dropped is because of the port-forwarding rule you set up in your router. That rule essentially fools NAT into believing that the WireGuard server originated the traffic.</p> <p>If the IP address your ISP assigns to your router's WAN interface is routable then your traffic will follow the green line in Figure 1. It will transit your ISP's network, be forwarded to the Internet, and reply packets will come back the same way.</p> <p>However, if the WAN IP address is not routable then your traffic will follow the red line in Figure 1. What happens next is another round of Network Address translation. Using the same address examples above:</p> <ul> <li>Your router \"A\" replaces 192.168.1.100 with the IP address of the WAN side of your home router but, this time, that's a non-routable address like 100.64.44.55; and then</li> <li>Your ISP's router \"B\" replaces 100.64.44.55 with 200.1.2.3.</li> </ul> <p>The system at the other end sees 200.1.2.3 as the source address so that's what it uses in reply packets.</p> <p>Both NAT engines \"A\" and \"B\" are building tables to make this work but, again, it is all in response to outbound traffic. If your remote WireGuard client tries to originate a connection with your WireGuard server by addressing the packet to \"B\", it's unexpected and gets dropped.</p> <p>Unlike the situation with your home router where you can add a port-forwarding rule to fool NAT into believing your WireGuard server originated the traffic, you don't control your ISP's NAT router so it's a problem you can't fix.</p> <p>Your remote WireGuard client can't bypass your ISP's NAT router by addressing the packet to \"A\" because that address is not routable, so nothing on the Internet has any idea of where to send it, so the packet gets dropped.</p> <p>Due to the shortage of IPv4 addresses, it is increasingly common for ISPs to apply their own NAT service after yours. Generally, ISPs use the 100.64/10 range so, if you connect to your home router's user interface and see something like the IP address circled in Figure 2, you can be sure that you are the victim of \"CGNAT\".</p> Figure 2: Router WAN port using CGNAT range <p>While seeing a router WAN address that is not routable proves that your ISP is performing an additional Network Address Translation step, seeing an IP address that should be routable does not necessarily prove the opposite. The only way to be certain is to compare the IP address your router shows for its WAN interface with the IP address you see in a service like whatsmyip.com. If they are not the same, your ISP is likely applying its own NAT service.</p> <p>If WireGuard won't work and you suspect your ISP is applying its own NAT service, you have the following options:</p> <ol> <li>Negotiate with your ISP to be allocated a fixed IP address in a routable range. You may be asked to pay ongoing fees for this.</li> <li>Change your ISP for one that still allocates routable IP addresses. But this may merely postpone the inevitable. To conserve dwindling IPv4 addresses, many ISPs are implementing Carrier Grade Network Address Translation (CGNAT).</li> <li>If your ISP offers it, implement IPv6 on your home network. This is a non-trivial task and well beyond the scope of IOTstack's documentation.</li> <li>Use a Virtual Private Server (VPS) to work around the problem. Explaining this is also well beyond the scope of IOTstack. Google \"wireguard cgnat\", grab a cup of coffee, and settle down for an afternoon's reading. </li> <li>Switch to ZeroTier. You can think of it as being \"like WireGuard with its own VPS\".</li> </ol>"},{"location":"Containers/ZeroTier-vs-WireGuard/#site-to-site-tunnelling","title":"Site-to-site tunnelling","text":"<p>You can use both WireGuard and ZeroTier to set up secure site-to-site routing such as between your home and the homes of your friends and relatives.</p> <p>If you want to use WireGuard:</p> <ol> <li>Make sure that all sites running WireGuard obey the CGNAT constraints mentioned above.</li> <li>Conduct your own research into how to set it up because the IOTstack documentation for WireGuard does not cover the topic.</li> </ol> <p>If you want to use ZeroTier:</p> <ol> <li>ZeroTier is immune to CGNAT constraints.</li> <li>The IOTstack documentation for ZeroTier explains the how-to.</li> </ol>"},{"location":"Containers/ZeroTier/","title":"ZeroTier","text":"<p>ZeroTier is a Virtual Private Network (VPN) solution that creates secure data-communications paths between devices at different locations. You can use ZeroTier to:</p> <ul> <li>give remote devices secure access to your home network's local services;</li> <li>provide secure network-to-network communications between your home network and the home networks of your friends and relations; and</li> <li>bypass carrier-grade network address translation (CGNAT) which can befuddle WireGuard.</li> </ul>"},{"location":"Containers/ZeroTier/#zeroTierImages","title":"ZeroTier Docker images","text":"<p>This documentation covers two DockerHub images and two IOTstack templates:</p> <ul> <li> <p><code>zyclonite:zerotier</code></p> <p>This image implements a standard ZeroTier client. It is what you get if you choose \"ZeroTier-client\" from the IOTstack menu. Its function is identical to the clients you install on Android, iOS, macOS and Windows.</p> </li> <li> <p><code>zyclonite:zerotier-router</code></p> <p>This is an enhanced version of the ZeroTier client. It is what you get if you choose \"ZeroTier-router\" from the IOTstack menu. In addition to connecting your Raspberry Pi to your ZeroTier network, it can also forward packets between remote clients and devices attached to your home LAN. It is reasonably close to WireGuard in its general behaviour.</p> </li> </ul>"},{"location":"Containers/ZeroTier/#references","title":"References","text":"<ul> <li> <p>ZeroTier:</p> <ul> <li>Home Page (sign-up)</li> <li>ZeroTier Central (management)</li> <li>Documentation</li> <li>Knowledge Base - Networking</li> <li>GitHub (ZeroTier source code)</li> </ul> </li> <li> <p>zyclonite/zerotier:</p> <ul> <li>GitHub (image source code)</li> <li>DockerHub (image repository)</li> </ul> </li> <li> <p>IOTstack discussion paper : ZeroTier vs WireGuard</p> </li> </ul>"},{"location":"Containers/ZeroTier/#definitions","title":"Definition","text":"<ul> <li>Catenet (a concatenation of networks) means the collection of networks and clients that can reach each other either across a local network or via a path through a ZeroTier Cloud.</li> </ul>"},{"location":"Containers/ZeroTier/#gettingStarted","title":"Getting started with ZeroTier","text":""},{"location":"Containers/ZeroTier/#createAccount","title":"Create an account","text":"<p>ZeroTier offers both free and paid accounts. A free account offers enough for the average home user.</p> <p>Go to the Zerotier downloads page. If you wait a little while, a popup window will appear with a \"Start here\" link which triggers a wizard to guide you through the registration and setup process. At the end, you will have an account plus an initial ZeroTier Network ID.</p> <p>Tip: Make a note of your ZeroTier network ID - you will need it!</p> <p>You should take the time to work through the configuration page for your newly-created ZeroTier network. At the very least:</p> <ol> <li>Give your ZeroTier network a name. At this point you only have a single network but you may decide to create more. Meaningful names are always easier on the brain than 16-hex-digit numbers.</li> <li> <p>Scroll down until you see the \"IPv4 Auto-Assign\" area. By default, ZeroTier will have done the following:</p> <ul> <li>Enabled \"Auto-Assign from Range\";</li> <li>Selected the \"Easy\" button; and</li> <li>Randomly-selected one of the RFC1918 private ranges below the line.</li> </ul> <p>If the range selected by ZeroTier does not begin with \"10.x\", consider changing the selection to something in that range. This documentation uses <code>10.244.*.*</code> throughout and it may be easier to follow if you do something similar. </p> <p>Tip: avoid <code>10.13.*.*</code> if you are also running WireGuard. </p> <p>The logic behind this recommendation is that you can use 10.x.x.x for ZeroTier and 192.168.x.x for your home networks, leaving 172.x.x.x for Docker. That should make it easier to understand what is going on when you examine routing tables.</p> <p>Nevertheless, nothing about ZeroTier depends on you using a 10.x network. If you have good reasons for selecting from a different range, do so. It's your network! </p> </li> </ol>"},{"location":"Containers/ZeroTier/#singleRemote","title":"Install client on \"remote\"","text":"<p>You should install ZeroTier client software on at least one mobile device (laptop, iDevice) that is going to connect remotely. You don't need to go to a remote location or fake \"remoteness\" by connecting through a cellular system. You can do all this while the device is connected to your home network.</p> <p>Connecting a client to your ZeroTier network is a three-step process:</p> <ol> <li> <p>Install the client software on the device. The Zerotier downloads page has clients for every occasion: Android, iOS, macOS, Unix and Windows.</p> </li> <li> <p>Launch the client and enter your ZeroTier Network ID:</p> <ul> <li> <p>on macOS, launching the app adds a menu to the right hand side of your menu bar. From that menu, choose \"Join New Network\u2026\", enter your network ID into the dialog box and click \"Join\".</p> </li> <li> <p>on iOS, launching the app for the first time presents you with a privacy policy which you need to accept, followed by a mostly-blank screen:</p> <ul> <li>Tap +, accept the privacy policy (again) and enter your network ID into the field.</li> <li>Leave the other settings alone and tap \"Add Network\". Acknowledge any security prompt (what you see depends on your version of iOS).</li> <li>Turn on the slider button.</li> </ul> </li> <li> <p>Android and Windows \u2013 follow your nose.</p> </li> </ul> </li> <li> <p>In a web browser:</p> <ul> <li>connect to ZeroTier Central: https://my.zerotier.com</li> <li>login to your account</li> <li>click on your network ID</li> <li>scroll down to the \"Members\" area</li> <li>find the newly-added client</li> <li>authorise the client by turning on its \"Auth?\" checkbox</li> <li>fill in the \"Name\" and, optionally, the \"Description\" fields so that you can keep track of the device associated with the client ID. Again, names are easier on the brain than numbers.  </li> </ul> </li> </ol> <p>Each time you authorise a client, ZeroTier assigns an IP address from the range you selected in the \"IPv4 Auto-Assign\" area. Most of the time this is exactly what you want but, occasionally, you may want to override ZeroTier's choice. The simplest approach is:</p> <ul> <li> <p>Type a new IP address into the text field to the right of the +\u00a0;</p> <p>your choice needs to be from the range you selected in the \"IPv4 Auto-Assign\" area</p> </li> <li> <p>Click the + to accept the address; then</p> </li> <li>Delete the unwanted address by clicking the trash-can icon to its left.</li> </ul> <p>ZeroTier IP addresses are like fixed assignments from a DHCP server. They persist. The same client will always get the same IP address each time it connects. </p> <p>Key point:</p> <ul> <li>Clients can't join your ZeroTier network without your approval. If a new client appears in the list which you don't recognise, click the trash-can icon at the far right of its row. That denies the client access - permanently. The client needs to be reset before it can make another attempt.</li> </ul>"},{"location":"Containers/ZeroTier/#otherRemotes","title":"Other devices","text":"<p>Do not install ZeroTier on your Raspberry Pi by following the Linux instructions on the Zerotier downloads page. Those instructions lead to a \"native\" installation. We are about to do all that with a Docker container.</p> <p>You can install ZeroTier clients on other systems but you should hold off on doing that for now because, ultimately, it may not be needed. Whether you need ZeroTier client software on any device will depend on the decisions you make as you follow these instructions.</p>"},{"location":"Containers/ZeroTier/#topology1","title":"Topology 1: ZeroTier client-only","text":"<p>To help you choose between the ZeroTier-client and ZeroTier-router containers, it is useful to study a network topology that does not include routing.</p> Topology 1: Remote client accesses client on home network <p>Four devices are shown:</p> <ul> <li>A is a Raspberry Pi running \"ZeroTier-client\" installed by IOTstack.</li> <li> <p>B is some other device (another Pi, Linux box, Mac, PC).</p> <p>The key thing to note is that B is not running ZeroTier client software.</p> </li> <li> <p>C is your local router, likely an off-the-shelf device running a custom OS.</p> <p>Again, assume C is not running ZeroTier client software.</p> </li> <li> <p>G is the remote client you set up above.</p> </li> </ul> <p>Table\u00a01 summarises what you can and can't do from the remote client G:</p> Table 1: Reachability using only ZeroTier clients <p>G can't reach B or C, directly, because those devices are not running ZeroTier client software.</p> <p>G can reach B and C, indirectly, by first connecting to A. An example would be G opening an SSH session on A then, within that session, opening another SSH session on B or C.</p> <p>It should be apparent that you can also solve this problem by installing ZeroTier client software on B. It would then have its own interface in the 10.244.0.0/16 network that forms the ZeroTier Cloud and be reachable directly from G. The no<sup>\u2020</sup> entries would then become yes, with the caveat that G would reach B via its interface in the 10.244.0.0/16 network.</p> <p>The same would be true for your router C, providing it was capable of running ZeroTier client software.</p> <p>Lessons to learn:</p> <ol> <li>All hosts running a ZeroTier client and sharing a common ZeroTier Network ID can reach each other.</li> <li>You can springboard from a host that is reachable to a host that is otherwise unreachable, but your ability to do that in any given situation may depend on the protocol you are trying to use.</li> </ol> <p>ZeroTier clients are incredibly easy to set up. It's always:</p> <ol> <li>Install the client software.</li> <li>Tell the client the network ID.</li> <li>Authorise the device.</li> </ol> <p>After that, it's full peer-to-peer interworking.</p> <p>The problem with this approach is that it does not scale if you are only signed up for a free ZeroTier account. Free accounts are limited to 25 clients. After that you need a paid account.</p>"},{"location":"Containers/ZeroTier/#topology1install","title":"Installing ZeroTier-client","text":"<p>Now that you understand what the ZeroTier-client will and won't do, if you want to install the ZeroTier client on your Raspberry Pi via IOTstack, proceed like this:</p> <ol> <li>Run the IOTstack menu and choose \"Zerotier-client\".</li> <li> <p>Bring up the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d zerotier-client\n</code></pre> </li> <li> <p>Tell the container to join your ZeroTier network by replacing \u00abNetworkID\u00bb with your ZeroTier Network ID:</p> <pre><code>$ docker exec zerotier zerotier-cli join \u00abNetworkID\u00bb \n</code></pre> <p>You only need to do this once. The information is kept in the container's persistent storage area. Thereafter, the client will rejoin the same network each time the container comes up.</p> </li> <li> <p>Go to ZeroTier Central and authorise the device.</p> </li> </ol> <p>Job done! There are no environment variables to set. It just works.</p>"},{"location":"Containers/ZeroTier/#topology2","title":"Topology 2: ZeroTier router","text":"<p>This topology is a good starting point for using ZeroTier to replicate a WireGuard service running on your Raspberry Pi. Remember, you don't have to make an either/or choice between ZeroTier and WireGuard. You can run both containers side-by-side.</p> Topology 2: Remote client accesses home network <p>With this structure in place, all hosts in Topology\u00a02 can reach each other directly. All the cells in Table\u00a01 are yes. Full peer-to-peer networking!</p>"},{"location":"Containers/ZeroTier/#topology2install","title":"Installing ZeroTier-router","text":"<p>The ZeroTier-router container is just the ZeroTier-client container with some <code>iptables</code> rules. However, you can't run both containers at the same time. If ZeroTier-client is installed:</p> <ol> <li> <p>Terminate the container if it is running:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down zerotier-client\n</code></pre> <p>See also if downing a container doesn't work</p> </li> <li> <p>Remove the existing service definition, either by:</p> <ul> <li>running the menu and de-selecting \"ZeroTier-client\"; or</li> <li>editing your <code>docker-compose.yml</code> to remove the service definition.</li> </ul> </li> </ol> <p>The ZeroTier-router can re-use the ZeroTier-client configuration (and vice-versa) so you should not erase the persistent storage area at:</p> <pre><code>~/IOTstack/volumes/zerotier-one/\n</code></pre> <p>Keeping the configuration also means you won't need to authorise the ZeroTier-router client when it first launches.</p> <p>To install Zerotier-router:</p> <ol> <li> <p>Run the IOTstack menu and choose \"Zerotier-router\".</p> </li> <li> <p>Use a text editor to open your <code>docker-compose.yml</code>. Find the ZeroTier service definition and the environment variables it contains: </p> <pre><code>  environment:\n  - TZ=${TZ:-Etc/UTC}\n  - PUID=1000\n  - PGID=1000\n# - ZEROTIER_ONE_NETWORK_IDS=yourNetworkID\n  - ZEROTIER_ONE_LOCAL_PHYS=eth0 wlan0\n  - ZEROTIER_ONE_USE_IPTABLES_NFT=true\n  - ZEROTIER_ONE_GATEWAY_MODE=both\n</code></pre> <p>You should:</p> <ol> <li>Set your timezone.</li> <li> <p>Uncomment line 9 and replace \"yourNetworkID\" with your ZeroTier Network ID. This variable only has an effect the first time ZeroTier is launched. It is an alternative to executing the following command after the container has come up the first time:</p> <pre><code>$ docker exec zerotier zerotier-cli join \u00abNetworkID\u00bb\n</code></pre> <p>The reason for the plural variable name (\"IDS\") is because it supports joining multiple networks on first launch. Network IDs are space-separated, like this:</p> <pre><code>- ZEROTIER_ONE_NETWORK_IDS=3926d64e8ff148b3 ef7a364a687c45e0\n</code></pre> </li> <li> <p>If necessary, change line 10 to represent your active local interfaces. Examples:</p> <ul> <li> <p>if your Raspberry Pi only connects to WiFi, you would use:</p> <pre><code>- ZEROTIER_ONE_LOCAL_PHYS=wlan0\n</code></pre> </li> <li> <p>if both Ethernet and WiFi are active, use:</p> <pre><code>- ZEROTIER_ONE_LOCAL_PHYS=eth0 wlan0\n</code></pre> </li> </ul> </li> </ol> </li> <li> <p>Launch the container:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d zerotier-router\n</code></pre> </li> <li> <p>If the Raspberry Pi running the service has not previously been authorised in ZeroTier Central, authorise it. Make a note of the IP address assigned to the device in ZeroTier Central. In Topology\u00a02 it is 10.244.0.1.</p> </li> <li> <p>You also need to set up some static routes:</p> <ul> <li> <p>In ZeroTier Central \u2026</p> <p>Please start by reading Managed Routes.</p> <p>Once you understand how to construct a valid less-specific route, go to ZeroTier Central and find the \"Managed Routes\" area. Under \"Add Routes\" are text-entry fields. Enter the values into the fields:</p> <pre><code>Destination: 192.168.202.0/23 (via) 10.244.0.1\n</code></pre> <p>Click Submit.</p> <p>With reference to Topology 2:</p> <ul> <li>192.168.202.0/23 is the less-specific route to the home network; and</li> <li>10.244.0.1 is the IP address of A in the ZeroTier Cloud.</li> </ul> <p>This route teaches ZeroTier clients that the 10.244.0.0/16 network offers a path to the less-specific range (192.168.202.0/23) encompassing the home subnet (192.168.203.0/24).</p> <p>Remote clients can then reach devices on your home network. When a packet arrives on A, it is passed through NAT so devices on your home network \"think\" the packet has come from A. That means they can reply. However, this only works for connections that are initiated by remote clients like G. Devices on your home network like B and C can't initiate connections with remote clients because they don't know where to send the traffic. That's the purpose of the next static route.</p> </li> <li> <p>In your home router C \u2026</p> <p>Add a static route to the ZeroTier Cloud pointing to the IP address of your Raspberry Pi on your home network. In Topology 2, this is:</p> <pre><code>10.244.0.0/16 via 192.168.203.50\n</code></pre> <p>You need to figure out how to add this route in your router's user interface.</p> <p>Here's an example of what actually happens once this route is in place. Suppose B wants to communicate with G. B is not a ZeroTier client so it doesn't know that A offers a path to G. The IP stack running on B sends the packet to the default gateway C (your router). Because of the static route, C sends the packet to A. Once the packet arrives on A, it is forwarded via the ZeroTier Cloud to G.</p> <p>The process of a packet going into a router and coming back out on the same interface is sometimes referred to as \"one-armed routing\". It may seem inefficient but C also sends B what is called an \"ICMP Redirect\" message. This teaches B that it reach G via A so, in practice, not every B-to-G packet needs to transit C.</p> </li> </ul> </li> </ol>"},{"location":"Containers/ZeroTier/#topology3","title":"Topology 3: Full tunnel","text":"<p>The ZeroTier Cloud does not offer a path to the Internet. It is not a VPN solution which will allow you to pretend to be in another location. Every ZeroTier client still needs its own viable path to the Internet.</p> Topology 3: Remote client tunnels to Internet via Home Network <p>In terms of traffic flows, what this means in a practical sense is:</p> <ul> <li>Traffic from G to [A, B or C] (and vice versa) flows over the ZeroTier Cloud and is securely end-to-end encrypted in transit; but</li> <li>All other traffic goes straight to the ISP or cellular carrier and is not encrypted.</li> </ul> <p>This is the routing table you would expect to see on G:</p> <pre><code>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         172.20.10.1     0.0.0.0         UG        0 0          0 wlan0\n10.244.0.0      0.0.0.0         255.255.0.0     U         0 0          0 ztr2qsmswx\n172.20.10.0     0.0.0.0         255.255.255.240 U         0 0          0 wlan0\n192.168.202.0   10.244.0.1      255.255.254.0   UG        0 0          0 ztr2qsmswx\n</code></pre> <p>Executing a <code>traceroute</code> to 8.8.8.8 (Google DNS) shows:</p> <pre><code>$ traceroute 8.8.8.8\ntraceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets\n 1  172.20.10.1 (172.20.10.1)  4.706 ms  4.572 ms  4.398 ms\n 2  10.111.9.189 (10.111.9.189)  49.599 ms  49.807 ms  49.626 ms\n\u2026\n11  dns.google (8.8.8.8)  32.710 ms  32.047 ms\n</code></pre> <p>You can see that the first hop is via 172.20.10.1. This means the traffic is not flowing over the ZeroTier Cloud (10.244.0.0/16). The traffic is reaching 8.8.8.8 via the default route through the phone's connection to the carrier's network (172.20.10.0/28).</p> <p>ZeroTier supports an option for forcing all of a client's traffic to pass over the ZeroTier Cloud. The client's traffic is then end-to-end encrypted, at least until it reaches your home. Traffic destined for the Internet will then pass back out through your home router. From the perspective of the Internet, your remote client will appear to be at your home.</p> <p>Enabling this feature is a two-step process:</p> <ol> <li> <p>In ZeroTier Central, find the \"Managed Routes\" area and add:</p> <pre><code>Destination: 0.0.0.0/0 (via) 10.240.0.1\n</code></pre> <p>This is setting up a \"default route\". 10.240.0.1 is the IP address of A in the ZeroTier network.</p> </li> <li> <p>Each remote client (and only remote clients) needs to be instructed to accept the default route from the ZeroTier Cloud:</p> <ul> <li> <p>iOS clients:</p> <ol> <li>Launch the ZeroTier One app.</li> <li>If the connection is not already enabled, turn it on and wait for it to start.</li> <li>Tap on the network ID (brings up a details sheet).</li> <li>Turn on \"Enable Default Route\".</li> <li>Tap outside the details sheet to dismiss it.</li> <li>Turn the connection off.</li> <li>Turn the connection on again.</li> </ol> <p>Once the client has been configured like this, the \"Enable Default Route\" setting will stick. Subsequent connections will follow the managed default route.</p> <p>If you wish to turn the setting off again, you need to repeat the same series of steps, turning \"Enable Default Route\" off at Step 4.</p> </li> <li> <p>Linux clients: execute the command:</p> <pre><code>$ docker exec zerotier zerotier-cli set \u00abyourNetworkID\u00bb allowDefault=1\n</code></pre> <p>See change option for an explanation of the output and how to turn the option off.</p> </li> <li> <p>macOS clients: open the ZeroTier menu, then the sub-menu for the Network ID, then enable \"Allow Default Router [sic] Override\".</p> </li> <li>Android and Windows clients: follow your nose.</li> </ul> </li> </ol> <p>Once <code>allowDefault</code> is enabled on a client, the routing table changes:</p> <pre><code>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         10.244.0.1      128.0.0.0       UG        0 0          0 ztr2qsmswx\n0.0.0.0         172.20.10.1     0.0.0.0         UG        0 0          0 wlan0\n10.244.0.0      0.0.0.0         255.255.0.0     U         0 0          0 ztr2qsmswx\n128.0.0.0       10.244.0.1      128.0.0.0       UG        0 0          0 ztr2qsmswx\n172.20.10.0     0.0.0.0         255.255.255.240 U         0 0          0 wlan0\n192.168.202.0   10.244.0.1      255.255.254.0   UG        0 0          0 ztr2qsmswx\n</code></pre> <p>Close inspection will show you that two entries have been added to the routing table:</p> Line Route Destination Mask Address Range 2 0.0.0.0/1 10.244.0.1 128.0.0.0 0.0.0.0\u2026127.255.255.255 5 128.0.0.0/1 10.244.0.1 128.0.0.0 128.0.0.0\u2026255.255.255.255 <p>Taken together, these have the same effect as a standard default route (0.0.0.0/0) but, because they are more-specific than the standard default route being offered by the cellular network, the path via ZeroTier Cloud will be preferred.</p> <p>You can test this with a <code>traceroute</code>:</p> <pre><code>$ traceroute 8.8.8.8\ntraceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets\n 1  10.244.0.1 (10.244.0.1)  98.239 ms  98.121 ms  98.042 ms\n 2  192.168.203.1 (192.168.203.1)  98.038 ms  97.943 ms  97.603 ms\n\u2026\n 7  dns.google (8.8.8.8)  104.748 ms  106.669 ms  106.356 ms\n</code></pre> <p>This time, the first hop is via the ZeroTier Cloud to A (10.244.0.1), then out through the local router C (192.168.203.1).</p>"},{"location":"Containers/ZeroTier/#topology4","title":"Topology 4: Multi-site routing","text":"Topology 4: Site-to-Site with ZeroTier-router <p>In this topology, everything can reach everything within your catenet. The installation process for F is the same as it was for A. See Installing ZeroTier-router.</p> <p>In ZeroTier Central you need one \"less-specific\" Managed Route pointing to each site where there is a ZeroTier router.</p> <p>At each site, the local router needs two static routes, both via the IP address of the local host running the ZeroTier-router container:</p> <ol> <li>A static route pointing to the ZeroTier Cloud (10.244.0.0/16); plus</li> <li>A static route covering all of 192.168.0.0/16.</li> </ol> <p>If the second route does not make sense, think of it like this:</p> <ul> <li>A packet destined for the local network (at any site) will match the more-specific routing table entry for that local network and be sent direct to the destination host.</li> <li>Otherwise, the packet will be sent to the local router (default gateway).</li> <li>On the router (C or D), the packet will match the less-specific static route for 192.168.0.0/16 and be forwarded to the local host running the ZeroTier-router container (one-armed routing).</li> <li>Courtesy of the Managed Routes set in ZeroTier Central, the local host running the ZeroTier-router container (A or F) will either have a more-specific route through the ZeroTier Cloud to the destination network, or it won't.</li> <li>If it has a more-specific route, the packet will be forwarded across the ZeroTier Cloud.</li> <li>Otherwise the packet will be dropped and the originator will receive an \"ICMP destination network unreachable\" message.</li> </ul> <p>In essence, both these static routes are \"set and forget\". They assume catenet growth is a possibility, and that it is preferable to set up schemes that will be robust and not need constant tweaking.</p>"},{"location":"Containers/ZeroTier/#topo4tunnel","title":"tunnelling remote clients","text":"<p>The diagram above for Topology 4 does not include a default route in ZeroTier Central. If you implement Topology 4 according to the diagram:</p> <ul> <li>traffic between G and your sites will travel via the ZeroTier Cloud (tunnelled, encrypted); but</li> <li>traffic between G and the wider Internet will not be tunnelled, will not be encrypted by ZeroTier, and will reach the Internet via the ISP or cellular carrier.</li> </ul> <p>If you want remote clients like G to use full tunnelling, you can follow the same approach as for Topology 3. You simply need to decide which site should used by G to reach the Internet. Having made your decision, define an appropriate default route in ZeroTier Central. For example, if G should reach the Internet via:</p> <ul> <li> <p>the left-hand site, the default route should point to the ZeroTier-router running on A:</p> <pre><code>Destination: 0.0.0.0/0 (via) 10.240.0.1\n</code></pre> </li> <li> <p>the right-hand site, the default route should point to the ZeroTier-router running on F:</p> <pre><code>Destination: 0.0.0.0/0 (via) 10.240.0.2\n</code></pre> </li> </ul> <p>Once you implement the default route, everything else is the same as for Topology 3.</p>"},{"location":"Containers/ZeroTier/#managedRoutes","title":"Managed Routes","text":""},{"location":"Containers/ZeroTier/#managedRoutesTLDR","title":"TL;DR","text":"<p>If your home network is a single subnet with a /24 prefix (a subnet mask of 255.255.255.0), you need to follow two rules when constructing the \"destination\" field of a Managed Route in ZeroTier Central:</p> <ol> <li>use a /23 prefix.</li> <li>if the third octet of your home network range is an odd number, subtract 1 to make it an even number.</li> </ol> <p>Examples:</p> Table 2: Constructing Managed Routes for Subnets - examples <p>If your home network has multiple subnets and/or you do not use /24 prefixes then you should either read through the next section or consult one of the many IP address calculators that are available on the Internet. One example:</p> <ul> <li>www.calculator.net</li> </ul>"},{"location":"Containers/ZeroTier/#managedRoutesDetails","title":"The details","text":"<p>This is a slightly contrived example but it will help you to understand why you need Managed Routes and how to construct them correctly in ZeroTier Central.</p> <p>Assume we are talking about Topology\u00a01 and that this is the routing table for host A:</p> <pre><code>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         192.168.203.1   0.0.0.0         UG        0 0          0 eth0\n192.168.203.0   0.0.0.0         255.255.255.0   U         0 0          0 eth0\n</code></pre> <p>Suppose A wants to send a packet to B. The IP stack starts searching the routing table. For each row:</p> <ol> <li> <p>The destination IP address for B (192.168.203.60) is ANDed with the subnet mask (255.255.255.0). Given the last row in the routing table above:</p> <pre><code>candidate = destinationIP AND Genmask\n          = 192.168.203.60 AND 255.255.255.0\n          = 192.168.203.0\n</code></pre> </li> <li> <p>The candidate (192.168.203.0) is compared with the value in the Destination column (192.168.203.0). If the two values are the same, the route is considered to be a match:</p> <pre><code>match = compareEqual(candidate,Destination)\n      = compareEqual(192.168.203.0, 192.168.203.0)\n      = true\n</code></pre> </li> <li> <p>The result is a match so the packet is handed to Layer 2 for transmission via the <code>eth0</code> interface.</p> </li> </ol> <p>Now suppose A wants to send a packet to 8.8.8.8 (Google DNS). The last row of the routing table will evaluate as follows:</p> <pre><code>candidate = destinationIP AND Genmask\n          = 8.8.8.8 AND 255.255.255.0\n          = 8.8.8.0\n    match = compareEqual(candidate,Destination)\n          = compareEqual(8.8.8.0, 192.168.203.0)\n          = false\n</code></pre> <p>The result is no-match so the routing algorithm continues to search the table. Eventually it will arrive at the 0.0.0.0 entry which is known as the \"default route\":</p> <pre><code>candidate = destinationIP AND Genmask\n          = 8.8.8.8 AND 0.0.0.0\n          = 0.0.0.0\n    match = compareEqual(candidate,Destination)\n          = compareEqual(0.0.0.0, 0.0.0.0)\n          = true\n</code></pre> <p>The result of comparing anything with the default route is always a match. Because the \"Gateway\" column is non-zero, the IP address of 192.168.203.1 (C) is used as the \"next hop\". The IP stack searches the routing table again. This new search for 192.168.203.1 will match on the bottom row so the packet will be handed to Layer 2 for transmission out of the <code>eth0</code> interface aimed at C (the local router, otherwise known as the \"default gateway\"). In turn, the local router forwards the packet to the ISP and, eventually, it winds up at 8.8.8.8.</p> <p>Let's bring ZeroTier into the mix.</p> <p>The local subnet shown in Topology\u00a01 is 192.168.203.0/24 so it seems to make sense to use that same subnet in a Managed Route. Assume you configured that in ZeroTier Central:</p> <pre><code>192.168.203.0/24 via 10.144.0.1\n</code></pre> <p>When the ZeroTier client on (A) adds that route to its routing table, you get something like this:</p> <pre><code>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         192.168.203.1   0.0.0.0         UG        0 0          0 eth0\n10.244.0.0      0.0.0.0         255.255.0.0     U         0 0          0 ztr2qsmswx\n192.168.203.0   10.244.0.1      255.255.255.0   UG        0 0          0 ztr2qsmswx\n192.168.203.0   0.0.0.0         255.255.255.0   U         0 0          0 eth0\n</code></pre> <p>To all network gurus following along: please remember this is a contrived example.</p> <p>Study the last two lines. You should be able to see that both lines will match when the IP stack searches this table whenever A needs to send a packet to B. This results in a tie.</p> <p>What normally happens is a tie-breaker algorithm kicks in. Schemes of route metrics, route weights, hop counts, round-trip times or interface priorities are used to pick a winner. Unfortunately, those schemes are all \"implementation defined\". Although the algorithms usually converge on a good answer, sometimes Murphy's Law kicks in. Routing problems are notoriously difficult to diagnose and can manifest in a variety of ways, ranging from sub-optimal routing, where the only symptom may be sluggishness, to forwarding loops, which can render your network mostly useless.</p> <p>Prevention is always better than cure so it is preferable to side-step the entire problem by taking advantage of the fact that IP routing will always match on a more-specific route before a less-specific route, and employ slightly less-specific Managed Routes in ZeroTier Central.</p> <p>What do \"more-\" and \"less-\" mean when we're talking about searching a routing table? The terms refer to the length of the network prefix. In \"/X\" notation, a larger value of X is more-specific than a smaller value of X:</p> <ul> <li>a \"/25\" is more specific then a \"/24\"</li> <li>a \"/23\" is less specific than a \"/24\"</li> </ul> <p>To ensure that the IP stack will always make the correct decision, the Managed Route you configure in ZeroTier Central should always be slightly less-specific than the actual subnet it covers. Given 192.168.203.0/24, your first attempt at constructing a less-specific route might be:</p> <pre><code>192.168.203.0/23 via 10.144.0.1\n</code></pre> <p>Sadly, that won't work. Why? Because the 192.168.203.0/23 subnet does not actually exist. That may surprise you but it's true. It has to do with the requirement that subnet masks use contiguous one-bits. It's easier to understand if you study the binary:</p> Table 3: Invalid vs Valid Managed Route <p>The left hand side of Table\u00a03 shows a network prefix of 192.168.203.0/23 along with what that /23 expands to as a subnet mask of 255.255.254.0. The last row is the result of ANDing the first two rows. Notice the right-most 1-bit in the third octet (circled). That bit hasn't made it to the last row and that's a problem.</p> <p>What's going on here is that the right-most 1-bit in the third octet is not actually part of the network portion of the IP address; it's part of the host portion. For a network prefix to be valid, all the bits in the host portion must be zero. To put it another way, the IP address 192.168.203.0/23 is host .1.0 (ordinal 256) in subnet 192.168.202.0/23.</p> <p>Read that last sentence again because \"in subnet 192.168.202.0/23\" is the clue.</p> <p>The right hand side of Table\u00a03 starts with network prefix 192.168.202.0/23 and ANDs it with its subnet mask. This time the host portion is all-zero. That means it's a valid subnet and, accordingly, can be the subject of a Managed Route. </p> <p>Table\u00a03 tells us something else about a /23 prefix. It tells us that whatever value appears in that third octet, the right-most 1-bit must always be zero. That's another way of saying that a /23 subnet is only valid if the third octet is an even number.</p> <p>At this point, you should understand the reason for the two rules in TL;DR above, and have a better idea of what you are doing if you need to use a subnet calculator.</p>"},{"location":"Containers/ZeroTier/#designConsiderations","title":"Network Design considerations","text":"<p>If you intend to set up multiple sites and route between them using ZeroTier, you need to be aware of some of the consequences that flow from how you need to configure Managed Routes.</p> <p>First, it should be obvious that you can't have two sites with the same network prefix. You and a friend can't both be using 192.168.1.0/24 at home.</p> <p>The second is that the set of less-specific prefixes in Managed Routes can't overlap either. If you are using the 192.168.0.0/24 subnet at home while your friend is using 192.168.1.0/24 at her home, both of your less-specific Managed Routes will be the same: 192.168.0.0/23. If you set up two Managed Routes to 192.168.0.0/23 with different \"via\" addresses, all the routers will think there's a single site that can be reached by multiple routes. That's a recipe for a mess.</p> <p>Putting both of the above together, any network plan for multiple sites should assume a gap of two between subnets. For example, if you are using the subnet 192.168.0.0/24 then your friend should be using 192.168.2.0/24. Your Managed Route will be 192.168.0.0/23, and your friend's Managed Route will be 192.168.2.0/23.</p> <p>None of this stops either you or your friend from using both of the /24 subnets that aggregate naturally under your respective /23 prefixes. For example, the single Managed Route 192.168.0.0/23 naturally aggregates two subnets:</p> <ul> <li>192.168.0.0/24 - eg your Ethernet</li> <li>192.168.1.0/24 - eg your WiFi</li> </ul> <p>Similarly, if you are using more than two subnets, such as:</p> <ul> <li>192.168.0.0/24 - your house Ethernet</li> <li>192.168.1.0/24 - your house WiFi</li> <li>192.168.2.0/24 - your workshop WiFi</li> </ul> <p>then you would slide your ZeroTier Managed Route prefix another bit to the left and use:</p> <pre><code>192.168.0.0/22 via 10.144.0.1\n</code></pre> <p>Notice what happens as you slide the prefix left. Things change in powers of 2:</p> <ul> <li>a /24 prefix Managed Route spans exactly 1 /24 subnet</li> <li>a /23 prefix Managed Route spans exactly 2 /24 subnets</li> <li>a /22 prefix Managed Route spans exactly 4 /24 subnets</li> <li>a /21 prefix Managed Route spans exactly 8 /24 subnets</li> <li>\u2026</li> <li>a /17 prefix Managed Route spans exactly 128 /24 subnets</li> </ul> <p>The direct consequence of that for Managed Routes is:</p> <ul> <li>a /23 prefix means values in the third octet must be wholly divisible by 2</li> <li>a /22 prefix means values in the third octet must be wholly divisible by 4</li> <li>a /21 prefix means values in the third octet must be wholly divisible by 8</li> <li>\u2026</li> <li>a /17 prefix means values in the third octet must be wholly divisible by 128</li> </ul> <p>Understanding how adjacent subnets can be aggregated easily by changing the prefix length should also bring with it the realisation that it is unwise to use a scattergun approach when allocating the third octet among your home subnets. Consider this scheme:</p> <ul> <li>192.168.0.0/24 - your Ethernet</li> <li>192.168.100.0/24 - your house WiFi</li> <li>192.168.200.0/24 - your workshop WiFi</li> </ul> <p>You would need three /23 Managed Routes in ZeroTier Central. In addition, you would prevent anyone else in your private ZeroTier catenet from using 192.168.1.0/24, 192.168.101.0/24 and 192.168.201.0/24. It would be preferable to use a single /22 as shown in the example above.</p> <p>Sure, that third octet can range from 0..255 but it's still a finite resource which is best used wisely, particularly once you start to contemplate using ZeroTier to span multiple sites.</p>"},{"location":"Containers/ZeroTier/#hostPorts","title":"Host mode and ports","text":"<p>The default service definition for ZeroTier-router contains the following lines:</p> <pre><code>  network_mode: host\n  x-ports:\n  - \"9993:9993\"\n</code></pre> <p>Line 13 tells ZeroTier to run in Docker's \"host mode\". This means the processes running inside the container bind to the Raspberry Pi's network ports.</p> <p>Processes running inside non-host-mode containers bind to the container's ports, and then use Network Address Translation (NAT) to reach the Raspberry Pi's ports.</p> <p>The <code>x-</code> prefix on line 14 has the effect of commenting-out the entire clause. In other words, the single <code>x-</code> has exactly the same meaning as:</p> <pre><code># ports:\n# - \"9993:9993\"\n</code></pre> <p>The <code>x-ports</code> clause is included to document the fact that ZeroTier uses the Raspberry Pi's port 9993.</p> <p>Documenting the ports in use for host-mode containers helps IOTstack's maintainers avoid port conflicts when adding new containers.</p> <p>You should not remove the <code>x-</code> prefix. If docker-compose complains about the <code>x-ports</code> clause, the message is actually telling you that your copy of docker-compose is obsolete and that you should upgrade.</p>"},{"location":"Containers/ZeroTier/#dnsConsiderations","title":"The Domain Name System","text":""},{"location":"Containers/ZeroTier/#normalDNS","title":"Normal DNS","text":"<p>If you have a DNS server running somewhere in your catenet, you can ask ZeroTier to propagate that information to your ZeroTier clients. It works the same way as a DHCP server can be configured to provide the IP addresses of DNS servers when handing out leases.</p> <p>It is a two-step process:</p> <ol> <li> <p>In ZeroTier Central, find the \"DNS\" area, complete the (optional) \"Search Domain\" and (required) \"Server Address\" fields, then click Submit.</p> <p>Examples. In Topology\u00a04, suppose the DNS server (eg PiHole or BIND9) is host:</p> <ul> <li>A, then \"Server Address\" = 10.244.0.1 (preferred) or 192.168.203.50 (less preferred);</li> <li>B, then \"Server Address\" = 192.168.203.60 </li> </ul> </li> <li> <p>Each client needs to be instructed to accept the DNS configuration:</p> <ul> <li>iOS clients: always enabled.</li> <li> <p>Linux clients: execute the command:</p> <pre><code>$ docker exec zerotier zerotier-cli set \u00abyourNetworkID\u00bb allowDNS=1\n</code></pre> <p>See change option for an explanation of the output and how to turn the option off.</p> </li> <li> <p>macOS clients: open the ZeroTier menu, then the sub-menu for the Network ID, then enable \"Allow DNS Configuration\".</p> </li> <li>Android and Windows clients: follow your nose.</li> </ul> </li> </ol> <p>Notes:</p> <ul> <li>Notice that clients need to opt-in to receiving DNS via ZeroTier. It is generally more appropriate for remote clients to do this than devices attached to a home network. This is probably why ZeroTier-managed DNS is \"always on\" for iOS clients. Android clients may be the same. For local clients, is usually better to let DHCP hand out DNS servers with the lease.</li> <li> <p>There are reports of <code>allowDNS</code> being unreliable on Linux clients. If you have trouble on Linux, try disabling <code>allowDNS</code> and add the DNS server(s) to:</p> <pre><code>/etc/resolvconf.conf\n</code></pre> </li> </ul>"},{"location":"Containers/ZeroTier/#mDNS","title":"Multicast DNS","text":"<p>The ZeroTier Cloud relays multicast traffic. That means that multicast DNS (mDNS) names are propagated between ZeroTier clients and you can use those names in connection requests.</p> <p>In terms of Topology\u00a04, A, F and G can all reach each other using mDNS names. For example:</p> <pre><code>pi@a:~$ ssh pi@f.local\n</code></pre> <p>However, even if B and C were advertising mDNS names over 192.168.203.0/24, they would be unreachable from D, E, F and G using those mDNS names because B and C are not ZeroTier clients. The same applies to reaching D and E from A, B, C or G using mDNS names.</p>"},{"location":"Containers/ZeroTier/#addressConflicts","title":"Resolving address-range conflicts","text":"<p>As your network infrastructure becomes more complex, you may find that you occasionally run into address-range conflicts that force you to consider renumbering.</p> <p>ZeroTier Central is where you define the subnet used by the ZeroTier Cloud (eg 10.244.0.0/16), while your home router is generally where you define the subnets used on your home networks.</p> <p>Docker typically allocates its internal subnets from 172.16/12 but it can sometimes venture into 192.168/16. Docker tries to stay clear of anything that is in use but it doesn't always have full visibility into every corner of your private catenet.</p> <p>The IOTstack menu adds the following to your compose file:</p> <pre><code>networks:\n\n  default:\n    driver: bridge\n    ipam:\n      driver: default\n\n  nextcloud:\n    driver: bridge\n    internal: true\n    ipam:\n      driver: default\n</code></pre> <p>That structure tells docker-compose that it should construct two networks:</p> <ul> <li><code>iotstack_default</code></li> <li><code>iotstack_nextcloud</code></li> </ul> <p>but leaves it up to docker-compose to work out the details. If you need more control, you can tell docker-compose to use specific subnets by adding two lines to each network definition:</p> <pre><code>networks:\n\n  default:\n    driver: bridge\n    ipam:\n      driver: default\n      config:\n        - subnet: 172.30.0.0/22\n\n  nextcloud:\n    driver: bridge\n    internal: true\n    ipam:\n      driver: default\n      config:\n        - subnet: 172.30.4.0/22\n</code></pre> <p>A /22 is sufficient for 1,021 containers. That may seem like overkill but it doesn't really affect anything. Nevertheless, no part of those subnet prefixes is any kind of \"magic number\". You should feel free to use whatever subnet definitions are appropriate to your needs.</p> <p>Note:</p> <ul> <li>If you are never going to run NextCloud on your Raspberry Pi, you can omit that network definition entirely. Doing so will silence unnecessary messages from docker-compose.</li> <li> <p>The <code>172.30.0.0/22</code> and <code>172.30.4.0/22</code> subnets (or whatever alternative ranges you choose) are private to the host where IOTstack is installed. That means you can re-use these same subnets on multiple hosts (Raspberry Pis or other supported platforms), irrespective of whether those hosts are at the same site (like A and B) or distributed across multiple sites (like A and F).</p> <p>The only time you would need to consider adjusting the subnet ranges is if you happened to be running two or more instances of IOTstack on the same host, simultaneously.</p> </li> </ul>"},{"location":"Containers/ZeroTier/#globalAddressing","title":"Global addressing","text":"<p>Everything in this documentation assumes you are using RFC1918 private ranges throughout your catenet. ZeroTier Cloud makes the same assumption.</p> <p>If some parts of your private catenet are using public addressing (either officially allocated to you or \"misappropriated\" like the 28/7 network), you may need to enable assignment of Global addressing:</p> <ul> <li>iOS clients: not mentioned - likely enabled by default.</li> <li> <p>Linux clients: execute the command:</p> <pre><code>$ docker exec zerotier zerotier-cli set \u00abyourNetworkID\u00bb allowGlobal=1\n</code></pre> <p>See change option for an explanation of the output and how to turn the option off.</p> </li> <li> <p>macOS clients: open the ZeroTier menu, then the sub-menu for the Network ID, then enable \"Allow Assignment of Global IPs\".</p> </li> <li>Android and Windows clients: follow your nose.</li> </ul>"},{"location":"Containers/ZeroTier/#aboutAllowManaged","title":"Allow Managed Addresses","text":"<p>The \"Allow Managed Addresses\" command (aka <code>allowManaged</code> option) is enabled by default. It gives ZeroTier permission to propagate IP addresses and route assignments. It is not a good idea to turn it off. If you turn it off accidentally, you can re-enable it either in the GUI or via:</p> <pre><code>$ docker exec zerotier zerotier-cli set \u00abyourNetworkID\u00bb allowManaged=1\n</code></pre> <p>See change option for an explanation of the output.</p>"},{"location":"Containers/ZeroTier/#usefulCommands","title":"Useful Commands","text":"<p>The commands in this section are given using this syntax:</p> <pre><code>$ zerotier-cli command {argument \u2026}\n</code></pre> <p>When ZeroTier client software is running in a container, you can execute commands:</p> <ul> <li> <p>directly using <code>docker exec</code>:</p> <pre><code>$ docker exec zerotier zerotier-cli command {argument \u2026}\n</code></pre> </li> <li> <p>or by first opening a shell into the container:</p> <pre><code>$ docker exec -it zerotier /bin/ash\n# zerotier-cli command {argument \u2026}\n# exit\n$\n</code></pre> </li> </ul> <p>On macOS you can run the commands from a Terminal window with <code>sudo</code>:</p> <pre><code>$ sudo zerotier-cli command {argument \u2026}\n</code></pre> <p>Windows, presumably, has similar functionality.</p>"},{"location":"Containers/ZeroTier/#cliNetworks","title":"Networks","text":""},{"location":"Containers/ZeroTier/#cliNetworksCheck","title":"Check networks","text":"<p>To check the ZeroTier networks the client has joined:</p> <pre><code>$ zerotier-cli listnetworks\n200 listnetworks &lt;nwid&gt; &lt;name&gt; &lt;mac&gt; &lt;status&gt; &lt;type&gt; &lt;dev&gt; &lt;ZT assigned ips&gt;\n200 listnetworks 900726788b1df8e2 My_Great_Network 33:b0:c6:2e:ad:2d OK PRIVATE feth4026 10.244.0.1/16\n</code></pre>"},{"location":"Containers/ZeroTier/#cliNetworksJoin","title":"Join network","text":"<p>To join a new ZeroTier network:</p> <pre><code>$ zerotier-cli join \u00abNewNetworkID\u00bb \n</code></pre>"},{"location":"Containers/ZeroTier/#cliNetworksLeave","title":"Leave network","text":"<p>To leave an existing ZeroTier network:</p> <pre><code>$ zerotier-cli leave \u00abExistingNetworkID\u00bb \n</code></pre>"},{"location":"Containers/ZeroTier/#cliInfo","title":"Client status","text":"<p>To check the status of a device running ZeroTier client:</p> <pre><code>$ zerotier-cli info\n200 info 340afcaa2a 1.10.1 ONLINE\n</code></pre>"},{"location":"Containers/ZeroTier/#cliPeer","title":"Peer status","text":"<p>To check the status of peers in your ZeroTier Networks:</p> <pre><code>$ zerotier-cli peers\n200 peers\n&lt;ztaddr&gt;   &lt;ver&gt;  &lt;role&gt; &lt;lat&gt; &lt;link&gt; &lt;lastTX&gt; &lt;lastRX&gt; &lt;path&gt;\n7492fd0dc5 1.10.1 LEAF       2 DIRECT 5407     5407     17.203.229.120/47647\nf14094b92a 1.10.1 LEAF     227 DIRECT 1976     1976     34.209.49.222/54643\nC88262CD64 1.10.1 LEAF       2 DIRECT 5411     5408     192.168.1.70/64408\n\u2026\n</code></pre> <p>Tip:</p> <ul> <li> <p>In the <code>&lt;link&gt;</code> column, <code>DIRECT</code> means ZeroTier has been able to arrange for this client (where you are running the command) and that peer to communicate directly. In other words, the traffic is not being relayed through ZeroTier's servers. Seeing <code>RELAY</code> in this field is not necessarily a bad thing but, to quote from the ZeroTier documentation:</p> <p>If you see the peer you're trying to contact in the RELAY state, that means packets are bouncing through our root servers because a direct connection between peers cannot be established. Side effects of RELAYING are increased latency and possible packet loss. See \"Router Configuration Tips\" above for how to resolve this.</p> </li> </ul>"},{"location":"Containers/ZeroTier/#cliOptions","title":"Options","text":"<p>At the time of writing, these options are defined:</p> option Let ZeroTier \u2026 allowDefault \u2026 modify the system's default route allowDNS \u2026 modify the system's DNS settings allowGlobal \u2026 manage IP addresses and Route assignments outside the RFC1918 ranges allowManaged \u2026 manage IP addresses and Route assignments"},{"location":"Containers/ZeroTier/#cliOptionCheck","title":"Check option","text":"<p>To check an option:</p> <pre><code>$ zerotier-cli get \u00abyourNetworkID\u00bb \u00aboption\u00bb\n</code></pre> <p>The result is either \"0\" (false) or \"1\" (true). Example:</p> <pre><code>$ zerotier-cli get 900726788b1df8e2 allowDNS\n0\n</code></pre>"},{"location":"Containers/ZeroTier/#cliOptionSet","title":"Change option","text":"<ul> <li> <p>To enable an option:</p> <pre><code>$ zerotier-cli set \u00abyourNetworkID\u00bb \u00aboption\u00bb=1\n</code></pre> </li> <li> <p>To disable an option:</p> <pre><code>$ zerotier-cli set \u00abyourNetworkID\u00bb \u00aboption\u00bb=0\n</code></pre> </li> </ul> <p>The response to changing an option is a large amount of JSON output. The updated state of the options is near the start. In practice, you can limit the output to just the options with a <code>grep</code>:</p> <pre><code>$ zerotier-cli set 900726788b1df8e2 allowDNS=0 | grep allow\n \"allowDNS\": false,\n \"allowDefault\": false,\n \"allowGlobal\": false,\n \"allowManaged\": true,\n</code></pre>"},{"location":"Containers/ZeroTier/#about-persistent-storage","title":"About persistent storage","text":"<p>Both ZeroTier-client and ZeroTier-router use the same persistent storage area. Should you choose to do so, you can freely switch back and forth between the -client and -router containers without worrying about the persistent storage area.</p> <p>The contents of ZeroTier's persistent storage uniquely identify the client to the ZeroTier Cloud. Unlike WireGuard, it is neither safe nor prudent to copy ZeroTier's persistent storage from one Raspberry Pi to another.</p> <p>An exception to this would be where you actually intend to move a ZeroTier client's identity to a different machine. That will work, providing your migration procedure never results in the same ZeroTier identity being in use on two machines at the same time.</p> <p>You can erase ZeroTier's persistent storage area like this:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down {zerotier-client | zerotier-router}\n$ sudo rm -rf ./volumes/zerotier-one\n</code></pre> <p>Tips:</p> <ol> <li>always double-check <code>sudo</code> commands before hitting Enter.</li> <li>see also if downing a container doesn't work</li> </ol> <p>Erasing persistent storage destroys the client's authorisation (cryptographic credentials). If you start the container again, it will construct a new identity and you will need to re-authorise the client in ZeroTier Central. You should also delete the obsolete client authorisation.</p>"},{"location":"Containers/ZeroTier/#container-maintenance","title":"Container maintenance","text":"<p>ZeroTier (either -client or -router) can be kept up-to-date with routine \"pulls\":</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose pull\n$ docker-compose up -d\n$ docker system prune -f\n</code></pre>"},{"location":"Containers/ZeroTier/#ios-tip","title":"iOS tip","text":"<p>On iOS, you must decide whether to select \"Custom DNS\"  when you define the VPN. If you want to change your mind, you need to delete the connection and start over.</p> <p>Providing you don't delete the Zerotier app, the client's identity remains unchanged so you won't need to re-authorise the client in ZeroTier Central.</p> <p>An example of when you might want to enable Custom DNS is if you want your remote clients to use PiHole for name services. If PiHole is running on the same Raspberry Pi as your Zerotier instance, you should use the IP address associated with the Raspberry Pi's interface to the ZeroTier Cloud (ie 10.244.0.1 in the example topologies).</p>"},{"location":"Containers/Zigbee2MQTT/","title":"Zigbee2MQTT","text":""},{"location":"Containers/Zigbee2MQTT/#quick-links","title":"Quick links","text":"<ul> <li>New users: start here</li> <li>Existing users: Service definition change (circa April 2022)</li> </ul>"},{"location":"Containers/Zigbee2MQTT/#references","title":"References","text":"<ul> <li>Web Guide</li> <li>Supported adapters</li> <li>GitHub</li> <li>DockerHub</li> </ul>"},{"location":"Containers/Zigbee2MQTT/#definitions","title":"Definitions","text":"<ul> <li> <p>\"compose file\" means the file at the path:</p> <pre><code>~/IOTstack/docker-compose.yml\n</code></pre> </li> </ul>"},{"location":"Containers/Zigbee2MQTT/#basicProcess","title":"Basic process for new users","text":"<ol> <li> <p>Run the IOTstack menu and choose both \"Mosquitto\" and \"Zigbee2MQTT\". That adds the service definitions for both of those containers to your compose file.</p> </li> <li> <p>Prepare your Zigbee adapter by flashing its firmware.</p> </li> <li>Follow the steps in Identify your Zigbee adapter to work out how your adapter \"mounts\" on your Raspberry Pi, and edit your compose file to include that information.</li> <li> <p>The default environment variables assume:</p> <ul> <li>You are running Mosquitto and Zigbee2MQTT as IOTstack containers on the same computer; and</li> <li>You want the Zigbee2MQTT web front end to be available on port 8080.</li> </ul> <p>This is a good basis for getting started. If it sounds like it will meet your needs, you will not need to make any changes. Otherwise, review the environment variables and make appropriate changes to the service definition in your compose file.</p> </li> <li> <p>Bring up your stack:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d\n</code></pre> </li> <li> <p>Confirm that the Zigbee2MQTT container appears to be working correctly. You should:</p> <ul> <li>Check container status to confirm that the container is running and stable, and is not in a restart loop;</li> <li>Check the container's log for any errors, warnings or other evidence of malfunction; and</li> <li>Check inter-container connectivity by verifying that the Zigbee2MQTT container is publishing MQTT messages to the Mosquitto broker.</li> </ul> </li> <li> <p>Connect to the web front end and start adding your Zigbee devices.</p> </li> </ol>"},{"location":"Containers/Zigbee2MQTT/#prepareAdapter","title":"Prepare your Zigbee adapter","text":"<p>Zigbee adapters usually need to be \"flashed\" before they can be used by Zigbee2MQTT. To prepare your adatper:</p> <ol> <li>Go to the supported adapters page.</li> <li>Find your adapter in the list.</li> <li>Follow the instructions for flashing your adapter.</li> </ol> <p>Note:</p> <ul> <li>If you can't find your adapter in the list of supported devices, you may not be able to get the Zigbee2MQTT container to connect to it. This kind of problem is outside the scope of IOTstack. You will have to raise the issue with the Zigbee2MQTT project.</li> </ul>"},{"location":"Containers/Zigbee2MQTT/#identifyAdapter","title":"Identify your Zigbee adapter","text":"<p>This section covers adapters that connect to your Raspberry Pi via USB.</p> <p>See connect to a remote adapter for information on connecting to adapters via TCP.</p> <p>Many USB Zigbee adapters mount as <code>/dev/ttyACM0</code> but this is not true for all adapters. In addition, if you have multiple devices connected to your Raspberry Pi that contend for a given device name, there are no guarantees that your Zigbee adapter will always be assigned the same name each time the device list is enumerated.</p> <p>For those reasons, it is better to take the time to identify your Zigbee adapter in a manner that will be predictable, unique and reliable:</p> <ol> <li>If your Zigbee adapter is connected to your Raspberry Pi, disconnect it.</li> <li> <p>Run the following command (the option is the digit \"1\"):</p> <pre><code>$ ls -1 /dev/serial/by-id\n</code></pre> <p>The possible response patterns are:</p> <ul> <li> <p>An error message:</p> <pre><code>ls: cannot access '/dev/serial/by-id': No such file or directory\n</code></pre> </li> <li> <p>A list of one or more lines where your Zigbee adapter is not present. Example:</p> <pre><code>usb-Silicon_Labs_CP2102N_USB_to_UART_Bridge_Controller_f068b8e7e82d4b119c0ee71fa1143ea0-if00-port0\n</code></pre> </li> </ul> <p>The actual response (error, or a list of devices) does not matter. You are simply establishing a baseline.</p> </li> <li> <p>Connect your prepared Zigbee adapter to a USB port on your Raspberry Pi.</p> </li> <li> <p>Repeat the same <code>ls</code> command from step 2. The response pattern should be different from step 2. The list should now contain your Zigbee adapter. Example:</p> <pre><code>usb-Silicon_Labs_CP2102N_USB_to_UART_Bridge_Controller_f068b8e7e82d4b119c0ee71fa1143ea0-if00-port0\nusb-Texas_Instruments_TI_CC2531_USB_CDC___0X00125A00183F06C5-if00\n</code></pre> <p>The second line indicates a CC2531 adapter is attached to the Raspberry Pi.</p> <p>If the response pattern does not change, it means the Raspberry Pi is unable to see your adapter. The two most common reasons are:</p> <ol> <li>Your adapter was not flashed correctly. Start over at prepare your Zigbee adapter.</li> <li> <p>Your adapter does not mount as a serial device. Try repeating steps 2 through 4 with the command:</p> <pre><code>$ ls -1 /dev\n</code></pre> <p>to see if you can discover how your adapter attaches to your Raspberry Pi.</p> <p>One example is the Electrolama zig-a-zig-ah which attaches as <code>/dev/ttyUSB0</code>.</p> </li> </ol> </li> <li> <p>Use the output from the <code>ls</code> command in step 4 to form the absolute path to your Zigbee adapter. Example:</p> <pre><code>/dev/serial/by-id/usb-Texas_Instruments_TI_CC2531_USB_CDC___0X00125A00183F06C5-if00\n</code></pre> </li> <li> <p>Check your work like this (the option is the lower-case letter \"l\"):</p> <pre><code>$ ls -l /dev/serial/by-id/usb-Texas_Instruments_TI_CC2531_USB_CDC___0X00125A00183F06C5-if00\nlrwxrwxrwx 1 root root 13 Mar 31 19:49 dev/serial/by-id/usb-Texas_Instruments_TI_CC2531_USB_CDC___0X00125A00183F06C5-if00 -&gt; ../../ttyACM0\n</code></pre> <p>What the output is telling you is that the by-id path is a symbolic link to <code>/dev/ttyACM0</code>. Although this may always be true on your Raspberry Pi, the only part that is actually guaranteed to be true is the by-id path, which is why you should use it.</p> </li> <li> <p>Once you have identified the path to your adapter, you communicate that information to docker-compose like this:</p> <pre><code>$ echo ZIGBEE2MQTT_DEVICE_PATH=/dev/serial/by-id/usb-Texas_Instruments_TI_CC2531_USB_CDC___0X00125A00183F06C5-if00 &gt;&gt;~/IOTstack/.env\n</code></pre> <p>Note:</p> <ul> <li> <p>if you forget to do this step, docker-compose will display the following error message:</p> <pre><code>parsing ~/IOTstack/docker-compose.yml: error while interpolating services.zigbee2mqtt.devices.[]: required variable ZIGBEE2MQTT_DEVICE_PATH is missing a value: eg echo ZIGBEE2MQTT_DEVICE_PATH=/dev/ttyACM0 &gt;&gt;~/IOTstack/.env\n</code></pre> </li> </ul> </li> <li> <p>Continue from bring up your stack.</p> </li> </ol>"},{"location":"Containers/Zigbee2MQTT/#configuration","title":"Configuration","text":""},{"location":"Containers/Zigbee2MQTT/#envVars","title":"Environment variables","text":"<p>Any value that can be set in a Zigbee2MQTT configuration file can also be set using an environment variable.</p> <p>The Zigbee2MQTT documentation explains the syntax.</p> <p>Note:</p> <ul> <li>Do not use quote marks to enclose the values (right hand sides) of environment variables.</li> </ul> <p>Whenever you change the value of an environment variable, you also need to tell <code>docker-compose</code> to apply the change:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d zigbee2mqtt\n</code></pre> <p>The default service definition provided with IOTstack includes the following environment variables:</p> <ul> <li> <p><code>ZIGBEE2MQTT_CONFIG_MQTT_SERVER=mqtt://mosquitto:1883</code></p> <p>Typical values for this are:</p> <ul> <li> <p><code>mqtt://mosquitto:1883</code></p> <p>This is default value supplied with the IOTstack template. It assumes that both Zigbee2MQTT and the Mosquitto broker are running in non-host mode containers on the same Raspberry Pi.</p> </li> <li> <p><code>mqtt://localhost:1883</code></p> <p>This would be appropriate if you were to run Zigbee2MQTT in host mode and the Mosquitto broker was running on the same Raspberry Pi.</p> </li> <li> <p><code>mqtt://\u00abhost-or-ip\u00bb:1883</code></p> <p>If the Mosquitto broker is running on a different computer, replace <code>\u00abhost-or-ip\u00bb</code> with the IP address or domain name of that other computer. You should also remove or comment-out the following lines from the service definition:</p> <pre><code>depends_on:\n  - mosquitto\n</code></pre> <p>The <code>depends_on</code> clause ensures that the Mosquitto container starts alongside the Zigbee2MQTT container. That would not be appropriate if Mosquitto was running on a separate computer.</p> </li> </ul> </li> <li> <p><code>ZIGBEE2MQTT_CONFIG_FRONTEND=true</code></p> <p>This variable activates the Zigbee2MQTT web interface on port 8080. If you want to change the port number where you access the Zigbee2MQTT web interface, see connecting to the web GUI.</p> </li> <li> <p><code>ZIGBEE2MQTT_CONFIG_ADVANCED_LOG_SYMLINK_CURRENT=true</code></p> <p>Defining this variable causes Zigbee2MQTT to create a symlink pointing to the current log folder at the path:</p> <pre><code>~/IOTstack/volumes/zigbee2mqtt/data/log/current\n</code></pre> <p>See Checking the log for more information about why this is useful.</p> </li> <li> <p><code>- DEBUG=zigbee-herdsman*</code></p> <p>Enabling this variable turns on extended debugging inside the container.</p> </li> </ul>"},{"location":"Containers/Zigbee2MQTT/#confFile","title":"Configuration file","text":"<p>Zigbee2MQTT creates a default configuration file at the path:</p> <pre><code>~/IOTstack/volumes/zigbee2mqtt/data/configuration.yaml\n</code></pre> <p>Although you can edit the configuration file, the approach recommended for IOTstack is to use environment variables.</p> <p>If you decide to edit the configuration file:</p> <ol> <li>You will need to use <code>sudo</code> to edit the file.</li> <li> <p>After you have finished making changes, you need to inform the running container by:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose restart zigbee2mqtt\n</code></pre> </li> <li> <p>Check the log for errors.</p> </li> </ol> <p>Note:</p> <ul> <li>If you start Zigbee2MQTT from a clean slate (ie where the configuration file does not exist) and your compose file does not define the <code>\u2026 MQTT_SERVER</code> environment variable discussed above, the container will go into a restart loop. This happens because the Zigbee2MQTT container defaults to trying to reach the Mosquitto broker at <code>localhost:1883</code> instead of <code>mosquitto:1883</code>. That usually fails.</li> </ul>"},{"location":"Containers/Zigbee2MQTT/#verifying-basic-operation","title":"Verifying basic operation","text":""},{"location":"Containers/Zigbee2MQTT/#checkStatus","title":"Checking status","text":"<pre><code>$ docker ps | grep -e mosquitto -e zigbee2mqtt\nNAMES         CREATED          STATUS\nzigbee2mqtt   33 seconds ago   Up 30 seconds\nmosquitto     33 seconds ago   Up 31 seconds (healthy)\n</code></pre> <p>The above output is filtered down to the relevant columns</p> <p>You are looking for evidence that the container is restarting (ie the \"Status\" column only ever shows a low number of seconds when compared with the \"Created\" column).</p>"},{"location":"Containers/Zigbee2MQTT/#checkLog","title":"Checking the log","text":"<p>You can't use <code>docker logs zigbee2mqtt</code> to inspect the Zigbee2MQTT container's logs. That's because Zigbee2MQTT writes its logging information to the path:</p> <pre><code>~/IOTstack/volumes/zigbee2mqtt/data/log/yyyy-mm-dd.hh-mm-ss/log.txt\n</code></pre> <p>where <code>yyyy-mm-dd.hh-mm-ss</code> is the date and time the container was last started. This means that you have to identify the folder with the latest timestamp before you can inspect the log contained within it.</p> <p>Fortunately, Zigbee2MQTT offers a shortcut. If the <code>\u2026 LOG_SYMLINK_CURRENT</code> environment variable is <code>true</code> then the path to the current log will be:</p> <pre><code>~/IOTstack/volumes/zigbee2mqtt/data/log/current/log.txt\n</code></pre> <p>You can use commands like <code>cat</code> and <code>tail</code> to examine the current log. Example:</p> <pre><code>$ cat ~/IOTstack/volumes/zigbee2mqtt/data/log/current/log.txt\n</code></pre>"},{"location":"Containers/Zigbee2MQTT/#checkMQTT","title":"Checking Mosquitto connectivity","text":"<p>To perform this check, you will need to have the Mosquitto clients installed:</p> <pre><code>$ sudo apt install -y mosquitto-clients\n</code></pre> <p>The Mosquitto clients package includes two command-line tools:</p> <ul> <li><code>mosquitto_pub</code> for publishing MQTT messages to the broker; and</li> <li> <p><code>mosquitto_sub</code> for subscribing to MQTT messages distributed by the broker.</p> <p>In IOTstack, the \"broker\" is usually the Mosquitto container.</p> </li> </ul> <p>Assuming the Mosquitto clients are installed, you can run the following command:</p> <pre><code>$ mosquitto_sub -v -h \"localhost\" -t \"zigbee2mqtt/#\" -F \"%I %t %p\"\n</code></pre> <p>One of two things will happen:</p> <ul> <li>silence, indicating that the Zigbee2MQTT container is not able to communicate with the Mosquitto container. If this happens, you should check the Zigbee2MQTT log. </li> <li>chatter, proving that the Zigbee2MQTT container can communicate with the Mosquitto container.</li> </ul> <p>Terminate the <code>mosquitto_sub</code> command with a Controlc.</p>"},{"location":"Containers/Zigbee2MQTT/#connectGUI","title":"Connecting to the web GUI","text":"<p>Open a browser, and point it to port 8080 on your Raspberry Pi. For example:</p> <pre><code>http://raspberrypi.local:8080\n</code></pre> <p>You should see the Zigbee2MQTT interface.</p> <p>Notes:</p> <ol> <li> <p>The availability of the Zigbee2MQTT UI is governed by an environment variable. If you do not see the UI, check that <code>\u2026 FRONTEND</code> is defined.</p> </li> <li> <p>In the URL above, port 8080 is an external port which is exposed via the following port mapping in the Zigbee2MQTT service definition:</p> <pre><code>ports:\n  - \"8080:8080\"\n</code></pre> <p>If you want to reach the Zigbee2MQTT UI via a different port, you should edit the left hand side of that mapping. For example, if you wanted to use port 10080 you would write: </p> <pre><code>ports:\n  - \"10080:8080\"\n</code></pre> <p>Do not change the internal port number on the right hand side of the mapping. To apply changes to the port mapping:</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose up -d zigbee2mqtt\n</code></pre> </li> </ol>"},{"location":"Containers/Zigbee2MQTT/#shell-access-to-the-container","title":"Shell access to the container","text":"<p>To open a shell inside the Zigbee2MQTT container, run:</p> <pre><code>$ docker exec -it zigbee2mqtt ash\n</code></pre> <p><code>ash</code> is not a typo!</p> <p>To close the shell and leave the container, either type \"exit\" and press return, or press Controld.</p>"},{"location":"Containers/Zigbee2MQTT/#container-maintenance","title":"Container maintenance","text":"<p>When you become aware of a new version of Zigbee2MQTT on DockerHub, do the following:</p> <pre><code>$ cd ~IOTstack\n$ docker-compose pull zigbee2mqtt\n$ docker-compose up -d zigbee2mqtt\n$ docker system prune\n</code></pre> <p>In words:</p> <ol> <li>Be in the correct directory.</li> <li>The <code>pull</code> compares the version on your Raspberry Pi with the latest version on DockerHub, and downloads any later version.</li> <li>If a newer version is downloaded, the <code>up</code> instantiates a new container based on the new image and performs a new-for-old swap. There is barely any downtime.</li> <li>The <code>prune</code> cleans up the older image.</li> </ol> <p>You can omit the <code>zigbee2mqtt</code> arguments from the <code>pull</code> and <code>up</code> commands, in which case <code>docker-compose</code> makes an attempt to pull any available updates for all non-Dockerfile-based images, and then instantiates any new images it has downloaded.</p>"},{"location":"Containers/Zigbee2MQTT/#update202204","title":"Service definition change","text":"<p>This information is for existing users of the Zigbee2MQTT container.</p> <p>The default IOTstack service definition for Zigbee2MQTT has changed:</p> <ul> <li>The container no longer needs to be built using a Dockerfile.</li> <li>The Zigbee2MQTT images on DockerHub can be used \"as is\".</li> <li>Environment variables supplied with the updated service definition exactly replicate the purpose of the old Dockerfile. </li> <li>The Dockerfile supplied with the IOTstack template is deprecated but continues to be provided to maintain backwards compatibility and to avoid introducing a breaking change.</li> </ul> <p>If you were using the Zigbee2MQTT container in IOTstack before April 2022, you should use your favourite text editor to update your compose file to conform with the new service definition.</p> <p>You could run the menu, then de-select and re-select Zigbee2MQTT. That will have the effect of applying the updated service definition but it also risks overwriting any other customisations you may have in place. That is why editing your compose file is the recommended approach.</p> <p>The updated service definition is included here for ease of reference:</p> <pre><code>zigbee2mqtt:\n  container_name: zigbee2mqtt\n  image: koenkk/zigbee2mqtt:latest\n  environment:\n    - TZ=${TZ:-Etc/UTC}\n    - ZIGBEE2MQTT_CONFIG_MQTT_SERVER=mqtt://mosquitto:1883\n    - ZIGBEE2MQTT_CONFIG_FRONTEND=true\n    - ZIGBEE2MQTT_CONFIG_ADVANCED_LOG_SYMLINK_CURRENT=true\n    # - DEBUG=zigbee-herdsman*\n  ports:\n    - \"8080:8080\"\n  volumes:\n    - ./volumes/zigbee2mqtt/data:/app/data\n  devices:\n    - \"${ZIGBEE2MQTT_DEVICE_PATH:?eg echo ZIGBEE2MQTT_DEVICE_PATH=/dev/ttyACM0 &gt;&gt;~/IOTstack/.env}:/dev/ttyACM0\"\n  restart: unless-stopped\n  depends_on:\n    - mosquitto\n</code></pre> <p>The changes you should make to your existing Zigbee2MQTT service definition are:</p> <ol> <li> <p>Replace the <code>build</code> directive:</p> <pre><code>build: ./.templates/zigbee2mqtt/.\n</code></pre> <p>with this <code>image</code> directive:</p> <pre><code>image: koenkk/zigbee2mqtt:latest\n</code></pre> <p>This causes IOTstack to use Zigbee2MQTT images \"as is\" from DockerHub.</p> </li> <li> <p>Add these environment variables:</p> <pre><code>  - ZIGBEE2MQTT_CONFIG_MQTT_SERVER=mqtt://mosquitto:1883\n  - ZIGBEE2MQTT_CONFIG_FRONTEND=true\n  - ZIGBEE2MQTT_CONFIG_ADVANCED_LOG_SYMLINK_CURRENT=true\n</code></pre> <p>The first two have the identical effect to the changes previously made via the Dockerfile. The last variable makes it easier for you to find and view the current log.</p> <p>See environment variables for more detail.</p> </li> <li> <p>Add the dependency clause:</p> <pre><code>depends_on:\n  - mosquitto\n</code></pre> <p>This ensures the Mosquitto container is brought up alongside Zigbee2MQTT. The Zigbee2MQTT container goes into a restart loop if Mosquitto is not reachable so this change enforces that business rule. See <code>\u2026 MQTT_SERVER</code> for the situation where this might not be appropriate.</p> </li> </ol>"},{"location":"Containers/Zigbee2MQTT/#pre-existing-configuration-file","title":"pre-existing configuration file","text":"<p>Environment variables in your compose file override corresponding values set in the configuration file at:</p> <pre><code>~/IOTstack/volumes/zigbee2mqtt/data/configuration.yaml\n</code></pre> <p>If you have customised your existing Zigbee2MQTT configuration file, you should review your settings for potential conflicts with the environment variables introduced by the changes to the IOTstack service definition. You can resolve any conflicts either by:</p> <ul> <li>removing or commenting-out conflicting environment variables; or</li> <li>altering the environment variable values to match your configuration file.</li> </ul> <p>The second approach is recommended because it minimises the risk that Zigbee2MQTT will go into a restart loop if the configuration file is not present when the container starts.</p> <p>As the Zigbee2MQTT documentation explains, any option that can be set in a configuration file can also be set using an environment variable, so you may want to take the opportunity to implement all your settings as environment variables.</p>"},{"location":"Containers/Zigbee2mqttassistant/","title":"Zigbee2Mqtt Assistant","text":""},{"location":"Containers/Zigbee2mqttassistant/#references","title":"References","text":"<ul> <li>Docker</li> <li>Website</li> </ul>"},{"location":"Containers/Zigbee2mqttassistant/#about","title":"About","text":"<p>This service a web frontend which displays Zigbee2Mqtt service messages and able to control it over MQTT. For the  servie a working MQTT server is required and that have to be configured.</p>"},{"location":"Containers/Zigbee2mqttassistant/#environment-parameters","title":"Environment Parameters","text":"<ul> <li><code>Z2MA_SETTINGS__MQTTSERVER=mosquitto</code> - The MQTT service instance which is used by Zigbee2Mqtt instance. Here, \"mosquitto\" is the name of the container.</li> <li><code>Z2MA_SETTINGS__MQTTUSERNAME=name</code> - Used if your MQTT service has authentication enabled. Optional.</li> <li><code>Z2MA_SETTINGS__MQTTPASSWORD=password</code> - Used if your MQTT service has authentication enabled. Optional.</li> <li><code>TZ=Etc/UTC</code>- Set to your timezone. Optional but recommended.</li> </ul>"},{"location":"Containers/Zigbee2mqttassistant/#accessing-the-ui","title":"Accessing the UI","text":"<p>The Zigbee2Mqtt Assistant UI is available using port 8880. For example:</p> <ul> <li><code>http://your.local.ip.address:8880/</code></li> </ul>"},{"location":"Developers/","title":"Contributing","text":"<p>We welcome pull-requests.</p> <p>For larger contributions, please open an issue describing your idea. It may provide valuable discussion and feedback. It also prevents the unfortunate case of two persons working on the same thing. There's no need to wait for any approval.</p> <p>Development guidelines</p> <ul> <li>It-just-works - use good defaults that will work well for a first time user</li> <li>Keep-it-simple - try to keep stuff beginner-friendly and don't go too   deep into advanced topics</li> </ul>"},{"location":"Developers/#writing-documentation","title":"Writing documentation","text":"<p>Tip</p> <p>For simple changes you can straight-up just use the edit link available on every documentation page. It's the pen-icon to the right of the top heading. Write your changes, check the preview-tab everything looks as expected and submit as proposed changes.</p> <p>Documentation is is written as markdown, processed using mkdocs (docs) and the Material theme (docs). The Material theme is not just styling, but provides additional syntax extensions.</p> <p>To test your local changes while writing them and before making a pull-request, start a local mkdocs server: <pre><code>$ ~/IOTstack/scripts/development/mkdocs-serve.sh\n</code></pre> And then open http://127.0.0.1:8000/ in a browser.</p>"},{"location":"Developers/#creating-a-new-service","title":"Creating a new service","text":"<p>In this section you can find information on how to contribute a service to IOTstack. We are generally very accepting of new services where they are useful. Keep in mind that if it is not IOTstack, selfhosted, or automation related we may not approve the PR.</p> <p>Services will grow over time, we may split up the buildstack menu into subsections or create filters to make organising all the services we provide easier to find.</p>"},{"location":"Developers/#checks","title":"Checks","text":"<ul> <li><code>service.yml</code> file is correct</li> <li><code>build.py</code> file is correct</li> <li>Service allows for changing external WUI port from Build Stack's options menu if service uses a HTTP/S port</li> <li>Use a default password, or allow the user to generate a random password for the service for initial installation. If the service asks to setup an account this can be ignored.</li> <li>Ensure Default Configs is updated as required. A helper script (default_ports_md_generator.sh) exists to simplify this. </li> <li>Must detect port conflicts with other services on BuildStack Menu.</li> <li><code>Pre</code> and <code>Post</code> hooks work with no errors. </li> <li>Does not require user to edit config files in order to get the service running.</li> <li>Ensure that your service can be backed up and restored without errors or data loss.</li> <li>Any configs that are required before getting the service running should be configured in the service's options menu (and a BuildStack menu Issue should be displayed if not).</li> <li>Fork the repo and push the changes to your fork. Create a cross repo PR for the mods to review. We may request additional changes from you.</li> </ul>"},{"location":"Developers/#commit-message","title":"Commit message","text":"<pre><code>service_name: Add/Fix/Change feature or bug summary\n\nOptional longer description of the commit. What is changed and why it\nis changed. Wrap at 72 characters.\n\n* You can use markdown formating as this will automatically be the\n  description of your pull-request.\n* End by adding any issues this commit fixes, one per line:\n\nFixes #1234\nFixes #4567\n</code></pre> <ol> <li> <p>The first line is a short description. Keep it short, aim for 50     characters. This is like the subject of an email. It shouldn't try to fully     or uniquely describe what the commit does. More importantly it should aim     to inform why this commit was made.</p> <p><code>service_name</code> - service or project-part being changed, e.g. influxdb, grafana, docs. Documentation changes should use the the name of the service. Use <code>docs</code> if it's changes to general documentation. If all else fails, use the folder-name of the file you are changing. Use lowercase.</p> <p><code>Add/Fix/Change</code> - what type of an change this commit is. Capitalized.</p> <p><code>feature or bug summary</code> - free very short text giving an idea of why/what.</p> </li> <li> <p>Empty line.</p> </li> <li> <p>A longer description of what and why. Wrapped to 72 characters.</p> <p>Use github issue linking to automatically close issues when the pull-request of this commit is merged.</p> </li> </ol> <p>For tips on how to use git, see Git Setup.</p>"},{"location":"Developers/#follow-up","title":"Follow up","text":"<p>If your new service is approved and merged then congratulations! Please watch the Issues page on github over the next few days and weeks to see if any users have questions or issues with your new service.</p> <p>Links:</p> <ul> <li>Default configs</li> <li>Password configuration for Services</li> <li>Build Stack Menu System</li> <li>Coding a new service</li> <li>IOTstack issues</li> </ul>"},{"location":"Developers/BuildStack-RandomPassword/","title":"Build Stack Random Services Password","text":"<p>This page explains how to have a service generate a random password during build time. This will require that your service have a working options menu.</p> <p>Keep in mind that updating strings in a service's yaml config isn't limited to passwords.</p>"},{"location":"Developers/BuildStack-RandomPassword/#a-word-of-caution","title":"A word of caution","text":"<p>Many services often set a password on their initial spin up and store it internally. That means if if the password is changed by the menu afterwards, it may not be reflected in the service. By default the password specified in the documentation should be used, unless the user specifically selected to use a randomly generated one. In the future, the feature to specify a password manually may be added in, much like how ports can be customised.</p>"},{"location":"Developers/BuildStack-RandomPassword/#a-basic-example","title":"A basic example","text":"<p>Inside the service's <code>service.yml</code> file, a special string can be added in for the build script to find and replace. Commonly the string is <code>%randomPassword%</code>, but technically any string can be used. The same string can be used multiple times for the same password to be used multiple times, and/or multiple difference strings can be used for multiple passwords. <pre><code>  mariadb:\n    image: linuxserver/mariadb\n    container_name: mariadb\n    environment:\n      - MYSQL_ROOT_PASSWORD=%randomAdminPassword%\n      - MYSQL_DATABASE=default\n      - MYSQL_USER=mariadbuser\n      - MYSQL_PASSWORD=%randomPassword%\n</code></pre></p> <p>These strings will be updated during the Prebuild Hook stage when building. The code to make this happen is shown below.</p>"},{"location":"Developers/BuildStack-RandomPassword/#code-commonly-used-to-update-passwords","title":"Code commonly used to update passwords","text":"<p>This code can basically be copy-pasted into your service's <code>build.py</code> file. You are welcome to expand upon it if required. It will probably be refactored into a utils function in the future to adear to DRY (Don't Repeat Yourself) practices. <pre><code>def preBuild():\n  # Multi-service load. Most services only include a single service. The exception being NextCloud where the database information needs to match between NextCloud and MariaDB (as defined in NextCloud's 'service.yml' file, not IOTstack's MariaDB).\n  with open((r'%s/' % serviceTemplate) + servicesFileName) as objServiceFile:\n    serviceYamlTemplate = yaml.load(objServiceFile)\n\n  oldBuildCache = {}\n  try:\n    with open(r'%s' % buildCache) as objBuildCache: # Load previous build, if it exists\n      oldBuildCache = yaml.load(objBuildCache)\n  except:\n    pass\n\n  buildCacheServices = {}\n  if \"services\" in oldBuildCache: # If a previous build does exist, load it so that we can reuse the password from it if required.\n    buildCacheServices = oldBuildCache[\"services\"]\n\n  if not os.path.exists(serviceService): # Create the service directory for the service\n    os.makedirs(serviceService, exist_ok=True)\n\n  # Check if buildSettings file exists (from previous build), or create one if it doesn't (in the else block).\n  if os.path.exists(buildSettings):\n    # Password randomisation\n    with open(r'%s' % buildSettings) as objBuildSettingsFile:\n      piHoleYamlBuildOptions = yaml.load(objBuildSettingsFile)\n      if (\n        piHoleYamlBuildOptions[\"databasePasswordOption\"] == \"Randomise database password for this build\"\n        or piHoleYamlBuildOptions[\"databasePasswordOption\"] == \"Randomise database password every build\"\n        or deconzYamlBuildOptions[\"databasePasswordOption\"] == \"Use default password for this build\"\n      ):\n\n        if deconzYamlBuildOptions[\"databasePasswordOption\"] == \"Use default password for this build\":\n          newAdminPassword = \"######\" # Update to what's specified in your documentation\n          newPassword = \"######\" # Update to what's specified in your documentation\n        else:\n          # Generate our passwords\n          newAdminPassword = generateRandomString()\n          newPassword = generateRandomString()\n\n        # Here we loop through each service included in the current service's `service.yml` file and update the password strings.\n        for (index, serviceName) in enumerate(serviceYamlTemplate):\n          dockerComposeServicesYaml[serviceName] = serviceYamlTemplate[serviceName]\n          if \"environment\" in serviceYamlTemplate[serviceName]:\n            for (envIndex, envName) in enumerate(serviceYamlTemplate[serviceName][\"environment\"]):\n              envName = envName.replace(\"%randomPassword%\", newPassword)\n              envName = envName.replace(\"%randomAdminPassword%\", newAdminPassword)\n              dockerComposeServicesYaml[serviceName][\"environment\"][envIndex] = envName\n\n        # If the user had selected to only update the password once, ensure the build options file is updated.\n        if (piHoleYamlBuildOptions[\"databasePasswordOption\"] == \"Randomise database password for this build\"):\n          piHoleYamlBuildOptions[\"databasePasswordOption\"] = \"Do nothing\"\n          with open(buildSettings, 'w') as outputFile:\n            yaml.dump(piHoleYamlBuildOptions, outputFile)\n      else: # Do nothing - don't change password\n        for (index, serviceName) in enumerate(buildCacheServices):\n          if serviceName in buildCacheServices: # Load service from cache if exists (to maintain password)\n            dockerComposeServicesYaml[serviceName] = buildCacheServices[serviceName]\n          else:\n            dockerComposeServicesYaml[serviceName] = serviceYamlTemplate[serviceName]\n\n  # Build options file didn't exist, so create one, and also use default password (default action).\n  else:\n    print(\"PiHole Warning: Build settings file not found, using default password\")\n    time.sleep(1)\n    newAdminPassword = \"######\" # Update to what's specified in your documentation\n    newPassword = \"######\" # Update to what's specified in your documentation\n    for (index, serviceName) in enumerate(serviceYamlTemplate):\n      dockerComposeServicesYaml[serviceName] = serviceYamlTemplate[serviceName]\n      if \"environment\" in serviceYamlTemplate[serviceName]:\n        for (envIndex, envName) in enumerate(serviceYamlTemplate[serviceName][\"environment\"]):\n          envName = envName.replace(\"%randomPassword%\", newPassword)\n          envName = envName.replace(\"%randomAdminPassword%\", newAdminPassword)\n          dockerComposeServicesYaml[serviceName][\"environment\"][envIndex] = envName\n      piHoleYamlBuildOptions = {\n        \"version\": \"1\",\n        \"application\": \"IOTstack\",\n        \"service\": \"PiHole\",\n        \"comment\": \"PiHole Build Options\"\n      }\n\n    piHoleYamlBuildOptions[\"databasePasswordOption\"] = \"Do nothing\"\n    with open(buildSettings, 'w') as outputFile:\n      yaml.dump(piHoleYamlBuildOptions, outputFile)\n\n  return True\n</code></pre></p>"},{"location":"Developers/BuildStack-RandomPassword/#code-for-your-services-menu","title":"Code for your service's menu","text":"<p>While not needed, since the default action is to create a random password, it is a good idea to allow the user to choose what to do. This can be achieved by giving them access to a password menu. This code can be placed in your service's <code>build.py</code> file, that will show a new menu option, allowing users to select it and be taken to a password settings screen.</p> <p>Remember that you need to have an already working menu, and to place this code into it.</p> <pre><code>import signal\n\n...\n\ndef setPasswordOptions():\n  global needsRender\n  global hasRebuiltAddons\n  passwordOptionsMenuFilePath = \"./.templates/{currentService}/passwords.py\".format(currentService=currentServiceName)\n  with open(passwordOptionsMenuFilePath, \"rb\") as pythonDynamicImportFile:\n    code = compile(pythonDynamicImportFile.read(), passwordOptionsMenuFilePath, \"exec\")\n  execGlobals = {\n    \"currentServiceName\": currentServiceName,\n    \"renderMode\": renderMode\n  }\n  execLocals = {}\n  screenActive = False\n  exec(code, execGlobals, execLocals)\n  signal.signal(signal.SIGWINCH, onResize)\n  screenActive = True\n  needsRender = 1\n\n...\n\ndef createMenu():\n  global yourServicesBuildOptions\n  global serviceService\n\n  yourServicesBuildOptions = []\n  yourServicesBuildOptions.append([\n    \"Your Service Password Options\",\n    setPasswordOptions\n  ])\n\n  yourServicesBuildOptions.append([\"Go back\", goBack])\n</code></pre>"},{"location":"Developers/BuildStack-RandomPassword/#password-settings-screen","title":"Password settings screen","text":"<p>The code for the Password settings is lengthy, but it's pasted here for convienence <pre><code>#!/usr/bin/env python3\n\nimport signal\n\ndef main():\n  from blessed import Terminal\n  from deps.chars import specialChars, commonTopBorder, commonBottomBorder, commonEmptyLine\n  from deps.consts import servicesDirectory, templatesDirectory, buildSettingsFileName\n  import time\n  import subprocess\n  import ruamel.yamls\n  import os\n\n  global signal\n  global currentServiceName\n  global menuSelectionInProgress\n  global mainMenuList\n  global currentMenuItemIndex\n  global renderMode\n  global paginationSize\n  global paginationStartIndex\n  global hideHelpText\n\n  yaml = ruamel.yaml.YAML()\n  yaml.preserve_quotes = True\n\n  try: # If not already set, then set it.\n    hideHelpText = hideHelpText\n  except:\n    hideHelpText = False\n\n  term = Terminal()\n  hotzoneLocation = [((term.height // 16) + 6), 0]\n  paginationToggle = [10, term.height - 25]\n  paginationStartIndex = 0\n  paginationSize = paginationToggle[0]\n\n  serviceService = servicesDirectory + currentServiceName\n  serviceTemplate = templatesDirectory + currentServiceName\n  buildSettings = serviceService + buildSettingsFileName\n\n  def goBack():\n    global menuSelectionInProgress\n    global needsRender\n    menuSelectionInProgress = False\n    needsRender = 1\n    return True\n\n  mainMenuList = []\n\n  hotzoneLocation = [((term.height // 16) + 6), 0]\n\n  menuSelectionInProgress = True\n  currentMenuItemIndex = 0\n  menuNavigateDirection = 0\n\n  # Render Modes:\n  #  0 = No render needed\n  #  1 = Full render\n  #  2 = Hotzone only\n  needsRender = 1\n\n  def onResize(sig, action):\n    global mainMenuList\n    global currentMenuItemIndex\n    mainRender(1, mainMenuList, currentMenuItemIndex)\n\n  def generateLineText(text, textLength=None, paddingBefore=0, lineLength=64):\n    result = \"\"\n    for i in range(paddingBefore):\n      result += \" \"\n\n    textPrintableCharactersLength = textLength\n\n    if (textPrintableCharactersLength) == None:\n      textPrintableCharactersLength = len(text)\n\n    result += text\n    remainingSpace = lineLength - textPrintableCharactersLength\n\n    for i in range(remainingSpace):\n      result += \" \"\n\n    return result\n\n  def renderHotZone(term, renderType, menu, selection, hotzoneLocation, paddingBefore = 4):\n    global paginationSize\n    selectedTextLength = len(\"-&gt; \")\n\n    print(term.move(hotzoneLocation[0], hotzoneLocation[1]))\n\n    if paginationStartIndex &gt;= 1:\n      print(term.center(\"{b}       {uaf}      {uaf}{uaf}{uaf}                                                   {ual}           {b}\".format(\n        b=specialChars[renderMode][\"borderVertical\"],\n        uaf=specialChars[renderMode][\"upArrowFull\"],\n        ual=specialChars[renderMode][\"upArrowLine\"]\n      )))\n    else:\n      print(term.center(commonEmptyLine(renderMode)))\n\n    for (index, menuItem) in enumerate(menu): # Menu loop\n      if index &gt;= paginationStartIndex and index &lt; paginationStartIndex + paginationSize:\n        lineText = generateLineText(menuItem[0], paddingBefore=paddingBefore)\n\n        # Menu highlight logic\n        if index == selection:\n          formattedLineText = '-&gt; {t.blue_on_green}{title}{t.normal} &lt;-'.format(t=term, title=menuItem[0])\n          paddedLineText = generateLineText(formattedLineText, textLength=len(menuItem[0]) + selectedTextLength, paddingBefore=paddingBefore - selectedTextLength)\n          toPrint = paddedLineText\n        else:\n          toPrint = '{title}{t.normal}'.format(t=term, title=lineText)\n        # #####\n\n        # Menu check render logic\n        if menuItem[1][\"checked\"]:\n          toPrint = \"     (X) \" + toPrint\n        else:\n          toPrint = \"     ( ) \" + toPrint\n\n        toPrint = \"{bv} {toPrint}  {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"], toPrint=toPrint) # Generate border\n        toPrint = term.center(toPrint) # Center Text (All lines should have the same amount of printable characters)\n        # #####\n        print(toPrint)\n\n    if paginationStartIndex + paginationSize &lt; len(menu):\n      print(term.center(\"{b}       {daf}      {daf}{daf}{daf}                                                   {dal}           {b}\".format(\n        b=specialChars[renderMode][\"borderVertical\"],\n        daf=specialChars[renderMode][\"downArrowFull\"],\n        dal=specialChars[renderMode][\"downArrowLine\"]\n      )))\n    else:\n      print(term.center(commonEmptyLine(renderMode)))\n    print(term.center(commonEmptyLine(renderMode)))\n    print(term.center(commonEmptyLine(renderMode)))\n\n\n  def mainRender(needsRender, menu, selection):\n    global paginationStartIndex\n    global paginationSize\n    term = Terminal()\n\n    if selection &gt;= paginationStartIndex + paginationSize:\n      paginationStartIndex = selection - (paginationSize - 1) + 1\n      needsRender = 1\n\n    if selection &lt;= paginationStartIndex - 1:\n      paginationStartIndex = selection\n      needsRender = 1\n\n    if needsRender == 1:\n      print(term.clear())\n      print(term.move_y(term.height // 16))\n      print(term.black_on_cornsilk4(term.center('IOTstack YourServices Password Options')))\n      print(\"\")\n      print(term.center(commonTopBorder(renderMode)))\n      print(term.center(commonEmptyLine(renderMode)))\n      print(term.center(\"{bv}      Select Password Option                                                    {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n      print(term.center(commonEmptyLine(renderMode)))\n\n    if needsRender &gt;= 1:\n      renderHotZone(term, needsRender, menu, selection, hotzoneLocation)\n\n    if needsRender == 1:\n      print(term.center(commonEmptyLine(renderMode)))\n      if not hideHelpText:\n        if term.height &lt; 32:\n          print(term.center(commonEmptyLine(renderMode)))\n          print(term.center(\"{bv}      Not enough vertical room to render controls help text                     {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(commonEmptyLine(renderMode)))\n        else: \n          print(term.center(commonEmptyLine(renderMode)))\n          print(term.center(\"{bv}      Controls:                                                                 {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(\"{bv}      [Space] to select option                                                  {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(\"{bv}      [Up] and [Down] to move selection cursor                                  {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(\"{bv}      [H] Show/hide this text                                                   {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(\"{bv}      [Enter] to build and save option                                          {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(\"{bv}      [Escape] to cancel changes                                                {bv}\".format(bv=specialChars[renderMode][\"borderVertical\"])))\n          print(term.center(commonEmptyLine(renderMode)))\n          print(term.center(commonEmptyLine(renderMode)))\n      print(term.center(commonBottomBorder(renderMode)))\n\n  def runSelection(selection):\n    import types\n    if len(mainMenuList[selection]) &gt; 1 and isinstance(mainMenuList[selection][1], types.FunctionType):\n      mainMenuList[selection][1]()\n    else:\n      print(term.green_reverse('IOTstack Error: No function assigned to menu item: \"{}\"'.format(mainMenuList[selection][0])))\n\n  def isMenuItemSelectable(menu, index):\n    if len(menu) &gt; index:\n      if len(menu[index]) &gt; 1:\n        if \"skip\" in menu[index][1] and menu[index][1][\"skip\"] == True:\n          return False\n    return True\n\n  def loadOptionsMenu():\n    global mainMenuList\n    mainMenuList.append([\"Use default password for this build\", { \"checked\": True }])\n    mainMenuList.append([\"Randomise database password for this build\", { \"checked\": False }])\n    mainMenuList.append([\"Randomise database password every build\", { \"checked\": False }])\n    mainMenuList.append([\"Do nothing\", { \"checked\": False }])\n\n  def checkMenuItem(selection):\n    global mainMenuList\n    for (index, menuItem) in enumerate(mainMenuList):\n      mainMenuList[index][1][\"checked\"] = False\n\n    mainMenuList[selection][1][\"checked\"] = True\n\n  def saveOptions():\n    try:\n      if not os.path.exists(serviceService):\n        os.makedirs(serviceService, exist_ok=True)\n\n      if os.path.exists(buildSettings):\n        with open(r'%s' % buildSettings) as objBuildSettingsFile:\n          yourServicesYamlBuildOptions = yaml.load(objBuildSettingsFile)\n      else:\n        yourServices = {\n          \"version\": \"1\",\n          \"application\": \"IOTstack\",\n          \"service\": \"Your Service\",\n          \"comment\": \"Your Service Build Options\"\n        }\n\n      yourServices[\"databasePasswordOption\"] = \"\"\n\n      for (index, menuOption) in enumerate(mainMenuList):\n        if menuOption[1][\"checked\"]:\n          yourServices[\"databasePasswordOption\"] = menuOption[0]\n          break\n\n      with open(buildSettings, 'w') as outputFile:\n        yaml.dump(yourServices, outputFile)\n\n    except Exception as err: \n      print(\"Error saving Your Services Password options\", currentServiceName)\n      print(err)\n      return False\n    global hasRebuiltHardwareSelection\n    hasRebuiltHardwareSelection = True\n    return True\n\n  def loadOptions():\n    try:\n      if not os.path.exists(serviceService):\n        os.makedirs(serviceService, exist_ok=True)\n\n      if os.path.exists(buildSettings):\n        with open(r'%s' % buildSettings) as objBuildSettingsFile:\n          yourServicesYamlBuildOptions = yaml.load(objBuildSettingsFile)\n\n        for (index, menuOption) in enumerate(mainMenuList):\n          if menuOption[0] == yourServicesYamlBuildOptions[\"databasePasswordOption\"]:\n            checkMenuItem(index)\n            break\n\n    except Exception as err: \n      print(\"Error loading Your Services Password options\", currentServiceName)\n      print(err)\n      return False\n    return True\n\n\n  if __name__ == 'builtins':\n    global signal\n    term = Terminal()\n    signal.signal(signal.SIGWINCH, onResize)\n    loadOptionsMenu()\n    loadOptions()\n    with term.fullscreen():\n      menuNavigateDirection = 0\n      mainRender(needsRender, mainMenuList, currentMenuItemIndex)\n      menuSelectionInProgress = True\n      with term.cbreak():\n        while menuSelectionInProgress:\n          menuNavigateDirection = 0\n\n          if not needsRender == 0: # Only rerender when changed to prevent flickering\n            mainRender(needsRender, mainMenuList, currentMenuItemIndex)\n            needsRender = 0\n\n          key = term.inkey(esc_delay=0.05)\n          if key.is_sequence:\n            if key.name == 'KEY_TAB':\n              if paginationSize == paginationToggle[0]:\n                paginationSize = paginationToggle[1]\n              else:\n                paginationSize = paginationToggle[0]\n              mainRender(1, mainMenuList, currentMenuItemIndex)\n            if key.name == 'KEY_DOWN':\n              menuNavigateDirection += 1\n            if key.name == 'KEY_UP':\n              menuNavigateDirection -= 1\n            if key.name == 'KEY_ENTER':\n              if saveOptions():\n                return True\n              else:\n                print(\"Something went wrong. Try saving the list again.\")\n            if key.name == 'KEY_ESCAPE':\n              menuSelectionInProgress = False\n              return True\n          elif key:\n            if key == ' ': # Space pressed\n              checkMenuItem(currentMenuItemIndex) # Update checked list\n              needsRender = 2\n            elif key == 'h': # H pressed\n              if hideHelpText:\n                hideHelpText = False\n              else:\n                hideHelpText = True\n              mainRender(1, mainMenuList, currentMenuItemIndex)\n\n          if menuNavigateDirection != 0: # If a direction was pressed, find next selectable item\n            currentMenuItemIndex += menuNavigateDirection\n            currentMenuItemIndex = currentMenuItemIndex % len(mainMenuList)\n            needsRender = 2\n\n            while not isMenuItemSelectable(mainMenuList, currentMenuItemIndex):\n              currentMenuItemIndex += menuNavigateDirection\n              currentMenuItemIndex = currentMenuItemIndex % len(mainMenuList)\n    return True\n\n  return True\n\noriginalSignalHandler = signal.getsignal(signal.SIGINT)\nmain()\nsignal.signal(signal.SIGWINCH, originalSignalHandler)\n</code></pre></p>"},{"location":"Developers/BuildStack-Services/","title":"Build Stack Services system","text":"<p>This page explains how the build stack system works for developers.</p>"},{"location":"Developers/BuildStack-Services/#how-to-define-a-new-service","title":"How to define a new service","text":"<p>A service only requires 2 files: * <code>service.yml</code> - Contains data for docker-compose * <code>build.py</code> - Contains logic that the menu system uses.</p>"},{"location":"Developers/BuildStack-Services/#a-basic-service","title":"A basic service","text":"<p>Inside the <code>service.yml</code> is where the service data for docker-compose is housed, for example: <pre><code>adminer:\n  container_name: adminer\n  image: adminer\n  restart: unless-stopped\n  ports:\n    - \"9080:8080\"\n</code></pre> It is important that the service name match the directory that it's in - that means that the <code>adminer</code> service must be placed into a folder called <code>adminer</code> inside the <code>./.templates</code> directory.</p>"},{"location":"Developers/BuildStack-Services/#basic-build-code-for-service","title":"Basic build code for service","text":"<p>At the very least, the <code>build.py</code> requires the following code: <pre><code>#!/usr/bin/env python3\n\nissues = {} # Returned issues dict\nbuildHooks = {} # Options, and others hooks\nhaltOnErrors = True\n\n# Main wrapper function. Required to make local vars work correctly\ndef main():\n  global currentServiceName # Name of the current service\n\n  # This lets the menu know whether to put \" &gt;&gt; Options \" or not\n  # This function is REQUIRED.\n  def checkForOptionsHook():\n    try:\n      buildHooks[\"options\"] = callable(runOptionsMenu)\n    except:\n      buildHooks[\"options\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This function is REQUIRED.\n  def checkForPreBuildHook():\n    try:\n      buildHooks[\"preBuildHook\"] = callable(preBuild)\n    except:\n      buildHooks[\"preBuildHook\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This function is REQUIRED.\n  def checkForPostBuildHook():\n    try:\n      buildHooks[\"postBuildHook\"] = callable(postBuild)\n    except:\n      buildHooks[\"postBuildHook\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This function is REQUIRED.\n  def checkForRunChecksHook():\n    try:\n      buildHooks[\"runChecksHook\"] = callable(runChecks)\n    except:\n      buildHooks[\"runChecksHook\"] = False\n      return buildHooks\n    return buildHooks\n\n  # Entrypoint for execution\n  if haltOnErrors:\n    eval(toRun)()\n  else:\n    try:\n      eval(toRun)()\n    except:\n      pass\n\n# This check isn't required, but placed here for debugging purposes\nglobal currentServiceName # Name of the current service\nif currentServiceName == 'adminer': # Make sure you update this.\n  main()\nelse:\n  print(\"Error. '{}' Tried to run 'adminer' config\".format(currentServiceName))\n</code></pre> This code doesn't have any port conflicting checking or menu code in it, and just allows the service to be built as is. The best way to learn on extending the functionality of the service's build script is to look at the other services' build scripts. You can also check out the advanced sections on adding menus and checking for issues for services though for a deeper explanation of specific situations.</p>"},{"location":"Developers/BuildStack-Services/#basic-code-for-a-service-that-uses-bash","title":"Basic code for a service that uses bash","text":"<p>If Python isn't your thing, here's a code blob you can copy and paste. Just be sure to update the lines where the comments start with <code>---</code> <pre><code>#!/usr/bin/env python3\n\nissues = {} # Returned issues dict\nbuildHooks = {} # Options, and others hooks\nhaltOnErrors = True\n\n# Main wrapper function. Required to make local vars work correctly\ndef main():\n  import subprocess\n  global dockerComposeServicesYaml # The loaded memory YAML of all checked services\n  global toRun # Switch for which function to run when executed\n  global buildHooks # Where to place the options menu result\n  global currentServiceName # Name of the current service\n  global issues # Returned issues dict\n  global haltOnErrors # Turn on to allow erroring\n\n  from deps.consts import servicesDirectory, templatesDirectory, volumesDirectory, servicesFileName\n\n  # runtime vars\n  serviceVolume = volumesDirectory + currentServiceName # Unused in example\n  serviceService = servicesDirectory + currentServiceName # Unused in example\n  serviceTemplate = templatesDirectory + currentServiceName\n\n  # This lets the menu know whether to put \" &gt;&gt; Options \" or not\n  # This function is REQUIRED.\n  def checkForOptionsHook():\n    try:\n      buildHooks[\"options\"] = callable(runOptionsMenu)\n    except:\n      buildHooks[\"options\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This function is REQUIRED.\n  def checkForPreBuildHook():\n    try:\n      buildHooks[\"preBuildHook\"] = callable(preBuild)\n    except:\n      buildHooks[\"preBuildHook\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This function is REQUIRED.\n  def checkForPostBuildHook():\n    try:\n      buildHooks[\"postBuildHook\"] = callable(postBuild)\n    except:\n      buildHooks[\"postBuildHook\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This function is REQUIRED.\n  def checkForRunChecksHook():\n    try:\n      buildHooks[\"runChecksHook\"] = callable(runChecks)\n    except:\n      buildHooks[\"runChecksHook\"] = False\n      return buildHooks\n    return buildHooks\n\n  # This service will not check anything unless this is set\n  # This function is optional, and will run each time the menu is rendered\n  def runChecks():\n    checkForIssues()\n    return []\n\n  # This function is optional, and will run after the docker-compose.yml file is written to disk.\n  def postBuild():\n    return True\n\n  # This function is optional, and will run just before the build docker-compose.yml code.\n  def preBuild():\n    execComm = \"bash {currentServiceTemplate}/build.sh\".format(currentServiceTemplate=serviceTemplate) # --- You may want to change this\n    print(\"[Wireguard]: \", execComm) # --- Ensure to update the service name with yours\n    subprocess.call(execComm, shell=True) # This is where the magic happens\n    return True\n\n  # #####################################\n  # Supporting functions below\n  # #####################################\n\n  def checkForIssues():\n    return True\n\n  if haltOnErrors:\n    eval(toRun)()\n  else:\n    try:\n      eval(toRun)()\n    except:\n      pass\n\n# This check isn't required, but placed here for debugging purposes\nglobal currentServiceName # Name of the current service\nif currentServiceName == 'wireguard': # --- Ensure to update the service name with yours\n  main()\nelse:\n  print(\"Error. '{}' Tried to run 'wireguard' config\".format(currentServiceName)) # --- Ensure to update the service name with yours\n</code></pre></p>"},{"location":"Developers/Git-Setup/","title":"Git Setup","text":"<p>How to setup and use git for IOTstack development.</p> <ol> <li>First, create a    fork of    SensorsIot/IOTstack on github. And    setup    your ssh-keys.</li> <li>Clone your fork and setup your github username and email    <pre><code>$ git clone git@github.com:&lt;username&gt;/IOTstack.git\n$ cd IOTstack\n$ git config user.name &lt;username&gt;\n$ git config user.email &lt;1234&gt;+&lt;username&gt;@users.noreply.github.com\n</code></pre></li> <li>Add up the SensorsIot/IOTstack upstream    <pre><code>$ git remote add upstream https://github.com/SensorsIot/IOTstack.git\n</code></pre></li> <li>Configure for ease of operation    <pre><code>$ git config fetch.prune true\n$ git config remote.pushDefault origin\n$ git config --add remote.origin.fetch \"^refs/heads/gh-pages\"\n$ git config --add remote.upstream.fetch \"^refs/heads/gh-pages\"\n$ git config branch.master.mergeoptions \"--no-ff\"\n$ git config fetch.parallel 0\n$ git fetch --all\n</code></pre></li> </ol>"},{"location":"Developers/Git-Setup/#make-a-pull-request","title":"Make a pull-request","text":"<pre><code>flowchart LR\n  upstream[\"upstream (SensorsIOT)\"] -- \"1. git fetch + git checkout -b\"\n    --&gt; local[local branch]\n  local -- \"2. git commit\" --&gt; local\n  local -- \"3. git push\" --&gt; origin[\"origin (your fork)\"]\n  origin -- \"3. create github pull-request\" --&gt; upstream</code></pre> <p>Please see Contributing for instructions on how to write commit messages.</p> <p><pre><code>$ git fetch upstream\n$ git checkout -b &lt;your-descriptive-branch-name&gt; upstream/master\n...coding and testing...\n$ git add &lt;your new or changed file&gt;\nCheck everything has been added:\n$ git status\n$ git commit\n$ git push\n</code></pre> When you execute git push, its output should have a link for creating the pull-request to github.</p>"},{"location":"Developers/Git-Setup/#common-operations","title":"Common operations","text":""},{"location":"Developers/Git-Setup/#show-compact-history-with-git-lg","title":"Show compact history with \"git lg\"","text":"<pre><code>$ git config alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"\n</code></pre>"},{"location":"Developers/Git-Setup/#remove-branches-of-merged-pull-requests","title":"Remove branches of merged pull-requests.","text":"<p>When your pull-requests have been merged, their branches aren't needed anymore. Remove them to reduce clutter and distractions. The master branch is never deleted.</p> <pre><code>$ git fetch --all\n$ git checkout master\n$ git branch -r --merged upstream/master | \\\n    grep -v origin/master$ | grep origin | sed 's/origin\\///' | \\\n    xargs -I 'B' git push --delete origin B\n$ git branch --merged upstream/master | grep -v \"  master$\" | \\\n    xargs -I'B' git branch -d B\n</code></pre>"},{"location":"Developers/Git-Setup/#advanced-topics","title":"Advanced topics","text":""},{"location":"Developers/Git-Setup/#fetch-all-pull-requests-as-branches","title":"Fetch all pull-requests as branches","text":"<p>This is handy for easily testing out other persons' suggested changes. The branches are of course fetch-only, and you can't push your own commits to them.</p> <pre><code>$ git config --add remote.upstream.fetch +refs/pull/*/head:refs/remotes/upstream/pr-*\n$ git fetch upstream\n</code></pre> <p>Note: Everything below requires this.</p>"},{"location":"Developers/Git-Setup/#show-up-to-date-branches-not-merged","title":"Show up-to-date branches not merged","text":"<p>Branches that include the latest upstream/master, but are not merged to your current branch, are potentially mergeable pull-requests. This is useful for identifying which pull-requests you should be able to merge without conflict.</p> <pre><code>$ git fetch upstream\n$ git branch -r --contains upstream/master --no-merged upstream/master\n</code></pre>"},{"location":"Developers/Git-Setup/#check-pull-requests-on-github-can-be-merged-without-conflicts","title":"Check pull-requests on Github can be merged without conflicts","text":"<p>In git, the only way to know if a branch can be merged without a conflict, is by actually doing the merge. An alias to (re-)create a branch named <code>merge-test</code> and do merges into it:</p> <pre><code>$ git config alias.test-pull-request-merge $'!f() { : git merge &amp;&amp; \\\n    OPENPULLS=$(curl -s \\'https://api.github.com/repos/SensorsIot/IOTstack/pulls?base=master&amp;per_page=100\\' | \\\n        grep \"^.....number\" | sed -E \\'s/.* ([0-9]+),/  upstream\\\\/pr-\\\\1/\\') &amp;&amp; \\\n    git fetch upstream &amp;&amp; git checkout -B merge-test upstream/master &amp;&amp; \\\n    git branch -r --contains upstream/master --no-merged upstream/master | \\\n    grep upstream/pr- | sort - &lt;(echo \"$OPENPULLS\") | \\\n    { uniq -d; [[ \"$1\" ]] &amp;&amp; echo \"$1\"; } | \\\n    xargs -I B sh -c \"echo Merging B &amp;&amp; \\\n        git merge --no-rerere-autoupdate --no-ff --quiet B || \\\n        { echo ***FAILED TO MERGE B &amp;&amp; exit 255; };\" ;}; f'\n</code></pre> <p>Then use this alias combined with <code>git checkout -</code>, returning your working copy back to the original branch if all merges succeeded:</p> <pre><code>$ git test-pull-request-merge &amp;&amp; git checkout -\n</code></pre> <p>This merges all branches that are: a) currently open pull requests and b) up-to-date, i.e. contains upstream/master and c) not merged already and d) the optional provided argument. Note: won't ignore draft pull-requests. If it encounters a failure, it stops immediately to let you inspect the conflict.</p> <p>Failed merge?</p> <p>If there was a merge-conflict, inspect it e.g. using <code>git diff</code>, but don't do any real work or conflict resolution in the merge-test branch. When you have understood the merge-conflict and want to leave the merge-test branch, abort the failed merge and switch to your actual branch:</p> <pre><code>$ git diff\n$ git merge --abort\n$ git checkout &lt;your-PR-branch-that-resulted-in-the-conflict&gt;\n</code></pre>"},{"location":"Developers/Git-Setup/#check-your-branch-doesnt-conflict-with-any-existing-pull-request","title":"Check your branch doesn't conflict with any existing pull-request","text":"<p>When you intend to submit a pull-request you might want to check that it won't conflict with any of the existing pull-requests.</p> <ol> <li>Commit all your changes into your pull request branch.</li> <li> <p>Use the alias from the previous \"Test all current pull-requests...\"-topic     to test merging your branch in addition to all current pull request:</p> <pre><code>$ git test-pull-request-merge &lt;your-pull-request-branch&gt; &amp;&amp; git checkout -\n</code></pre> <p>If there is a merge-conflict, see \"Failed merge?\" above.</p> </li> </ol>"},{"location":"Developers/Menu-System/","title":"Menu system","text":"<p>This page explains how the menu system works for developers.</p>"},{"location":"Developers/Menu-System/#background","title":"Background","text":"<p>Originally this script was written in bash. After a while it became obvious that bash wasn't well suited to dealing with all the different types of configuration files, and logic that goes with configuring everything. IOTstack needs to be accessible to all levels of programmers and tinkerers, not just ones experienced with Linux and bash. For this reason, it was rewritten in Python since the language syntax is easier to understand, and is more commonly used for scripting and programming than bash. Bash is still used in IOTstack where it makes sense to use it, but the menu system itself uses Python. The code it self while not being the most well structured or efficient, was intentionally made that way so that beginners and experienced programmers could contribute to the project. We are always open to improvements if you have suggestions.</p>"},{"location":"Developers/Menu-System/#menu-structure","title":"Menu Structure","text":"<p>Each screen of the menu is its own Python script. You can find most of these in the <code>./scripts</code> directory. When you select an item from the menu, and it changes screens, it actually dynamically loads and executes that Python script. It passes data as required by placing it into the global variable space so that both the child and the parent script can access it.</p>"},{"location":"Developers/Menu-System/#injecting-and-getting-globals-in-a-child-script","title":"Injecting and getting globals in a child script","text":"<pre><code>with open(childPythonScriptPath, \"rb\") as pythonDynamicImportFile:\n  code = compile(pythonDynamicImportFile.read(), childPythonScriptPath, \"exec\")\nexecGlobals = {\n  \"globalKeyName\": \"globalKeyValue\"\n}\nexecLocals = {}\nprint(globalKeyName) # Will print out 'globalKeyValue'\nexec(code, execGlobals, execLocals)\nprint(globalKeyName) # Will print out 'newValue'\n</code></pre>"},{"location":"Developers/Menu-System/#reading-and-writing-global-variables-in-a-child-script","title":"Reading and writing global variables in a child script","text":"<pre><code>def someFunction:\n  global globalKeyName\n  print(globalKeyName) # Will print out 'globalKeyValue'\n  globalKeyName = \"newValue\"\n</code></pre> <p>Each menu is its own python executable. The entry point is down the bottom of the file wrapped in a <code>main()</code> function to prevent variable scope creep.</p> <p>The code at the bottom of the <code>main()</code> function: <pre><code>if __name__ == 'builtins':\n</code></pre></p> <p>Is actually where the execution path runs, all the code above it is just declared so that it can be called without ordering or scope issues.</p>"},{"location":"Developers/Menu-System/#optimisations","title":"Optimisations","text":"<p>It was obvious early on that the menu system would be slow on lower end devices, such as the Raspberry Pi, especially if it were rending a 4k terminal screen from a desktop via SSH. To mitigate this issue, not all of the screen is redrawn when there is a change. A \"Hotzone\" as it's called in the code, is usually rerendered when there's a change (such as pressing up or down to change an item selection, but not when scrolling). Full screen redraws are expensive and are only used when required, for example, when scrolling the pagination, selecting or deselecting a service, expanding or collapsing the menu and so on.</p>"},{"location":"Developers/Menu-System/#environments-and-encoding","title":"Environments and encoding","text":"<p>At the very beginning of the main menu screen (<code>./scripts/main_menu.py</code>) the function <code>checkRenderOptions()</code> is run to determine what characters can be displayed on the screen. It will try various character sets, and eventually default to ASCII if none of the fancier stuff can be rendered. This setting is passed into of the sub menus through the submenu's global variables so that they don't have to recheck when they load.</p>"},{"location":"Developers/Menu-System/#sub-menus","title":"Sub-Menus","text":"<p>From the main screen, you will see several sections leading to various submenus. Most of these menus work in the same way as the main menu. The only exception to this rule is the Build Stack menu, which is probably the most complex part of IOTstack.</p>"},{"location":"Developers/Menu-System/#build-stack-menu","title":"Build Stack Menu","text":"<p>Path: <code>./scripts/buildstack_menu.py</code></p>"},{"location":"Developers/Menu-System/#loading","title":"Loading","text":"<ol> <li>Upon loading, the Build Stack menu will get a list of folders inside the <code>./templates</code> directory and check for a <code>build.py</code> file inside each of them. This can be seen in the <code>generateTemplateList()</code> function, which is executed before the first rendering happens.</li> <li>The menu will then check if the file <code>./services/docker-compose.save.yml</code> exists. This file is used to save the configuration of the last build. This happens in the <code>loadCurrentConfigs()</code> function. It is important that the service name in the compose file matches the folder name, any service that doesn't will either cause an error, or won't be loaded into the menu.</li> <li>If a previous build did exist the menu will then run the <code>prepareMenuState()</code> function that basically checks which items should be ticked, and check for any issues with the ticked items by running <code>checkForIssues()</code>.</li> </ol>"},{"location":"Developers/Menu-System/#selection-and-deselection","title":"Selection and deselection","text":"<p>When an item is selected, 3 things happen: 1. Update the UI variable (<code>menu</code>) with function <code>checkMenuItem(selectionIndex)</code> to let the user know the current state. 2. Update the array holding every checked item <code>setCheckedMenuItems()</code>. It uses the UI variable (<code>menu</code>) to know which items are set. 3. Check for any issues with the new list of selected items by running <code>checkForIssues()</code>.</p>"},{"location":"Developers/Menu-System/#check-for-options-submenus-of-services","title":"Check for options (submenus of services)","text":"<p>During a full render sequence (this is not a hotzone render), the build stack menu checks to see if each of the services has an options menu. It does this by executing the <code>build.py</code> script of each of the services and passing in <code>checkForOptionsHook</code> into the <code>toRun</code> global variable property to see if the script has a <code>runOptionsMenu</code> function. If the service's function result is true, without error, then the options text will appear up for that menu item.</p>"},{"location":"Developers/Menu-System/#check-for-issues","title":"Check for issues","text":"<p>When a service is selected or deselected on the menu, the <code>checkForIssues()</code> function is run. This function iterates through each of the selected menu items' folders executing the <code>build.py</code> script and passing in <code>checkForRunChecksHook</code> into the <code>toRun</code> global variable property to see if the script has a <code>runChecks</code> function. The <code>runChecks</code> function is different depending on the service, since each service has its own requirements. Generally though, the <code>runChecks</code> function should check for conflicting port conflicts again any of the other services that are enabled. The menu will still allow you to build the stack, even if issues are present, assumine there's no errors raised during the build process.</p>"},{"location":"Developers/Menu-System/#prebuild-hook","title":"Prebuild hook","text":"<p>Pressing enter on the Build Stack menu kicks off the build process. The Build Stack menu will execute the <code>runPrebuildHook()</code> function. This function iterates through each of the selected menu items' folders executing the <code>build.py</code> script and passing in <code>checkForPreBuildHook</code> into the <code>toRun</code> global variable property to see if the script has a <code>preBuild</code> function. The <code>preBuild</code> function is different depending on the service, since each service has its own requirements. Some services may not even use the prebuild hook. The prebuild is very useful for setting up the services' configuration however. For example, it can be used to autogenerate a password for a paticular service, or copy and modify a configuration file from the <code>./.templates</code> directory into the <code>./services</code> or <code>./volumes</code> directory.</p>"},{"location":"Developers/Menu-System/#postbuild-hook","title":"Postbuild hook","text":"<p>The Build Stack menu will execute the <code>runPostBuildHook()</code> function in the final step of the build process, after the <code>docker-compose.yml</code> file has been written to disk. This function iterates through each of the selected menu items' folders executing the <code>build.py</code> script and passing in <code>checkForPostBuildHook</code> into the <code>toRun</code> global variable property to see if the script has a <code>postBuild</code> function. The <code>postBuild</code> function is different depending on the service, since each service has its own requirements. Most services won't require this function, but it can be useful for cleaning up temporary files and so on.</p>"},{"location":"Developers/Menu-System/#the-build-process","title":"The build process","text":"<p>The selected services' yaml configuration is already loaded into memory before the build stack process is started.</p> <ol> <li>Run prebuildHooks.</li> <li>Read <code>./.templates/docker-compose-base.yml</code> file into a in memory yaml structure.</li> <li>Add selected services into the in memory structure.</li> <li>If it exists merge the <code>./compose-override.yml</code> file into memory</li> <li>Write the in memory yaml structure to disk <code>./docker-compose.yml</code>.</li> <li>Run postbuildHooks.</li> <li>Run <code>postbuild.sh</code> if it exists, with the list of services built.</li> </ol>"},{"location":"Developers/PostBuild-Script/","title":"Postbuild BASH Script","text":"<p>The postbuild bash script allows for executing arbitrary execution of bash commands after the stack has been build.</p>"},{"location":"Developers/PostBuild-Script/#how-to-use","title":"How to use","text":"<p>Place a file in the main directory called <code>postbuild.sh</code>. When the buildstack build logic finishes, it'll execute the <code>postbuild.sh</code> script, passing in each service selected from the buildstack menu as a parameter. This script is run each time the buildstack logic runs.</p>"},{"location":"Developers/PostBuild-Script/#updates","title":"Updates","text":"<p>The <code>postbuild.sh</code> file has been added to gitignore, so it won't be updated by IOTstack when IOTstack is updated. It has also been added to the backup script so that it will be backed up with your personal IOTstack backups.</p>"},{"location":"Developers/PostBuild-Script/#example-postbuildsh-script","title":"Example <code>postbuild.sh</code> script","text":"<p>The following script will print out each of the services built, and a custom message for nodered. If it was the first time the script was executed, it'll also output \"Fresh Install\" at the end, using a <code>.install_tainted</code> file for knowing. <pre><code>#!/bin/bash\n\nfor iotstackService in \"$@\"\ndo\n  echo \"$iotstackService\"\n  if [ \"$iotstackService\" == \"nodered\" ]; then\n    echo \"NodeRed Installed!\"\n  fi\ndone\n\nif [ ! -f .install_tainted ]; then\n  echo \"Fresh Install!\"\n  touch .install_tainted\nfi\n</code></pre></p>"},{"location":"Developers/PostBuild-Script/#what-is-my-purpose","title":"What is my purpose?","text":"<p>The postbuild script can be used to run custom bash commands, such as moving files, or issuing commands that your services expect to be completed before running.</p>"},{"location":"Updates/","title":"Updating the project","text":"<p>There are two different update sources: the IOTstack project (github.com) and Docker image registries (e.g. hub.docker.com). Both the initial stack creation and updates use both of these. Initial creation is a bit simpler, as the intermediate steps are done automatically. For a full update they need to be performed explicitly. To illustrate the steps and artifacts of the update process:</p> <pre><code>flowchart TD\n  GIT[github.com/sensorsiot/IOTstack.git]\n  GIT       --- GITPULL([$ git pull -r])\n  GITPULL   --&gt; TEMPLATES[\"~/IOTstack/.templates\"]\n  TEMPLATES --- MENU([$ ./menu.sh -&gt; Build stack])\n  MENU      --&gt; COMPOSE[\"~/IOTstack/docker-compose.yml\n                         ~/IOTstack/.templates/*/Dockerfile\n                         ~/IOTstack/services/*/Dockerfile\"]\n  COMPOSE   --- UP([\"$ docker-compose up --build -d\"])\n\n  HUB[hub.docker.com images and tags]\n  HUB       --- PULL([$ docker-compose pull\\n$ docker-compose build --pull --no-cache])\n  COMPOSE   --- PULL\n  PULL      --&gt; CACHE[local Docker image cache]\n  CACHE     --- UP\n\n  UP        --&gt; CONTAINER[recreated Docker containers based on the latest cached images]\n\n  classDef command fill:#9996,stroke-width:0px\n  class GITPULL,MENU,UP,PULL command</code></pre> Minor details fudged in the graph <p>In order to keep the graph simple, some minor details were left unprecise:</p> <ul> <li><code>$ docker-compose pull</code> will read <code>docker-compose.yml</code>, in order to know     what image tags to check for updates.</li> <li> <p><code>$ docker-compose build --pull --no-cache</code> will use <code>docker-compose.yml</code>     to find which of the \"build:\" sources are in use:</p> <ul> <li><code>~/IOTstack/.templates/*/Dockerfile</code></li> <li><code>~/IOTstack/services/*/Dockerfile</code></li> <li>remote repositories with Dockerfiles</li> </ul> <p>and pull Docker images referenced in these while building.</p> </li> <li> <p><code>$ docker-compose up --build -d</code> may not require the \"--build\"-flag,     but having it won't hurt (and may help keep some corner-case problems     away, docker may be a bit finicky).</p> </li> </ul>"},{"location":"Updates/#backup-and-rollback","title":"Backup and rollback","text":"<p>The usual way of backing up just your <code>~/IOTstack</code> contents isn't sufficient for a 100% identical restore. Some containers may have local ephemeral modifications that will be lost when they're recreated. Currently running containers may be based on now outdated images. Recreating a container using an old image is tricky. The local Docker image cache can't easily be restored to the same state with old images and old tag references. The <code>docker pull</code> will fetch the latest images, but it's not unheard of that the latest image may break something.</p> <p>Thus to guarantee a successful rollback to the pre-update state, you have to shutdown your RPi and save a complete disk image backup of its storage using another machine.</p> <p>For a hobby project, not having a perfect rollback may be a risk you're willing to take. Usually image problems will have fixes/workarounds within a day.</p>"},{"location":"Updates/#update-raspberry-pi-os","title":"Update Raspberry Pi OS","text":"<p>You should keep your Raspberry Pi up-to-date. Despite the word \"container\" suggesting that containers are fully self-contained, they sometimes depend on operating system components (WireGuard is an example).</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade -y\n</code></pre>"},{"location":"Updates/#recommended-update-only-docker-images","title":"Recommended: Update only Docker images","text":"<p>When you built the stack using the menu, it created the Docker Compose file <code>docker-compose.yml</code>. This file and any used build instructions (<code>Dockerfile</code>s), use image name and tag references to images on hub.docker.com or other registries. An undefined tag defaults to <code>:latest</code>. When Docker is told to pull updated images, it will download the images into the local cache, based upon what is currently stored at the registry for the used names and tags.</p> <p>Updating the IOTstack project templates and recreating your <code>docker-compose.yml</code> isn't usually necessary. Doing so isn't likely to provide much benefits, and may actually break something. A full update is only recommended when there is a new feature or change you need.</p> <p>Recommended update procedure</p> <ol> <li>Shutdown your RPi, remove the storage medium and do a full backup    image    of the storage to another machine. Reattach the storage back and power    up your RPi.    NOTE: To skip this step may cause days of downtime as you debug a    problem or wait for fixes.</li> <li>Get latest images from the web:    <pre><code>$ docker-compose pull\n</code></pre></li> <li>Rebuild localy created images based on new parent images:    <pre><code>$ docker-compose build --pull --no-cache\n</code></pre>    Note: this may not do anything, depending on your selected services.</li> <li>Update(recreate) containers that have new images:    <pre><code>$ docker-compose up --build -d\n</code></pre></li> </ol> <p>If a service fails to start after it's updated, especially if you are updating frequently, wait for a few hours and repeat the update procedure. Sometimes bad releases are published to hub.docker.com, but they are usually fixed in under half a day. Of course you are always welcome to report the problem to our Discord server. Usually someone else has encountered the same problem and reported the fix.</p>"},{"location":"Updates/#full-update","title":"Full update","text":"<p>Periodically updates are made to project which include new or updated container template, changes to backups or additional features. To evaluate if this is really needed, see the changelog or merged pull requests. To apply all these changes all service definitions are recreated. As a drawback, this will wipe any custom changes to docker-compose.yml, may change semantics or even require manual migration steps.</p> <p>Breaking update</p> <p>A change done 2022-01-18 will require manual steps or you may get an error like: <code>ERROR: Service \"influxdb\" uses an undefined network \"iotstack_nw\"</code></p> <p>Full update steps:</p> <ol> <li>Shutdown your RPi, remove the storage medium and do a full backup    image    of the storage to another machine. Reattach the storage back and power up    your RPi.    NOTE: To skip this step may cause days of downtime as you debug a problem or    wait for fixes.</li> <li> <p>check <code>git status --untracked-files no</code> for any local changes you may have     made to project files. For any listed changes, either:</p> <ol> <li>Save and preserve your change by doing a local commit: <code>git commit -m    \"local customization\" -- path/to/changed_file</code>, or</li> <li>Revert it using: <code>git checkout -- path/to/changed_file</code></li> </ol> </li> <li> <p>Update project files from github: <code>git pull -r origin master</code></p> </li> <li>Save your current compose file: <code>cp docker-compose.yml    docker-compose.yml.bak</code>. NOTE: this is really useful, as the next step will    overwrite all your previous manual changes to docker-compose.yml.</li> <li>Recreate the compose file and Dockerfile:s: <code>./menu.sh</code>, select Build Stack,    for each of your selected services: de- and re-select it, press enter to    build, and then exit.</li> <li>check the changes for obvious errors (e.g. passwords): <code>diff    docker-compose.yml docker-compose.yml.bak</code></li> <li>Perform the Docker image update procedure:     <pre><code>$ docker-compose pull\n$ docker-compose build --pull --no-cache \n$ docker-compose up --build -d \n</code></pre></li> </ol>"},{"location":"Updates/#troubleshooting-if-a-container-fails-to-start-after-update","title":"Troubleshooting: if a container fails to start after update","text":"<ul> <li>try restarting the whole stack: <code>docker-compose restart</code></li> <li>Check log output of the failing service: <code>docker-compose logs *service-name*</code><ul> <li>try googling and fixing problems in docker-compose.yml manually.</li> </ul> </li> <li>check how the container definitions have changed: <code>diff docker-compose.yml     docker-compose.yml.bak</code></li> <li>try rebuilding your complete stack from scratch:<ol> <li>check that you have a backup.</li> <li>stop and remove Docker containers: <code>docker-compose down</code></li> <li>remove all menu generated files: <code>rm -r docker-compose.yml services</code></li> <li>recreate the stack: <code>./menu.sh</code>, select Build Stack, select all your    services, press enter to build, and then exit.</li> <li>try starting: <code>docker-compose up -d</code></li> </ol> </li> <li>Go to the IOTstack Discord and describe your   problem. We're happy to help.</li> </ul>"},{"location":"Updates/#old-menu","title":"Old-menu","text":"<p>Warning</p> <p>If you ran <code>git checkout -- 'git ls-files -m'</code> as suggested in the old wiki entry then please check your duck.sh because it removed your domain and token</p> <p>Git offers build in functionality to fetch the latest changes.</p> <p><code>git pull origin master</code> will fetch the latest changes from GitHub without overwriting files that you have modified yourself. If you have done a local commit then your project may to handle a merge conflict.</p> <p>This can be verified by running <code>git status</code>. You can ignore if it reports duck.sh as being modified.</p> <p></p> <p>Should you have any modified scripts or templates they can be reset to the latest version with <code>git checkout -- scripts/ .templates/</code></p> <p>With the new latest version of the project you can now use the menu to build your stack. If there is a particular container you would like to update its template then you can select that at the overwrite option for your container. You have the choice to not to overwrite, preserve env files or to completely overwrite any changes (passwords)</p> <p></p> <p>After your stack had been rebuild you can run <code>docker-compose up -d</code> to pull in the latest changes. If you have not update your images in a while consider running the <code>./scripts/update.sh</code> to get the latest version of the image from Docker hub as well</p>"},{"location":"Updates/Changelog/","title":"Changelog","text":""},{"location":"Updates/Changelog/#latest","title":"Latest","text":"<p>(may include items not yet merged)</p> <ul> <li>Fixes to bash aliases.</li> <li>Timescaledb template fixed and public port now mapped to 5433.</li> </ul>"},{"location":"Updates/Changelog/#2022-06-12","title":"2022-06-12","text":"<ul> <li>Dockerfile based Zigbee2MQTT deprecated, requiring migration.</li> <li>New service: Duckdns, deprecates the   <code>duck/duck.sh</code> script.</li> <li>New service: Influxdb 2, supported only on   fully 64bit systems.</li> <li>Docker health checks added to Grafana and InfluxDB.</li> </ul>"},{"location":"Updates/Changelog/#2022-04-26","title":"2022-04-26","text":"<ul> <li>New service: Syncthing</li> <li>Zigbee2MQTT: Service definition change</li> <li>Dropping support for Home Assistant Supervised. Home Assistant Container   still available.</li> <li>Homebridge is now on port 8581</li> <li>Documentation: Added: Git Setup. Large changes   to: Updates, InfluxDB,   Grafana, Pi-hole,   Docker Logging.</li> </ul>"},{"location":"Updates/Changelog/#2022-01-18","title":"2022-01-18","text":"<ul> <li>Networking change requiring migration.</li> </ul>"},{"location":"Updates/New-Menu-Release-Notes/","title":"New IOTstack Menu","text":""},{"location":"Updates/New-Menu-Release-Notes/#background","title":"Background","text":"<p>Originally this script was written in bash. After a while it became obvious that bash wasn't well suited to dealing with all the different types of configuration files, and logic that goes with configuring everything. IOTstack needs to be accessible to all levels of programmers and tinkerers, not just ones experienced with Linux and bash. For this reason, it was rewritten in Python since the language syntax is easier to understand, and is more commonly used for scripting and programming than bash. Bash is still used in IOTstack where it makes sense to use it, but the menu system itself uses Python. The code is intentionally made so that beginners and experienced programmers could contribute to the project. We are always open to improvements if you have suggestions.</p>"},{"location":"Updates/New-Menu-Release-Notes/#on-going-improvements","title":"On-going improvements","text":"<p>There are many features that are needing to be introduced into the new menu system. From meta tags on services for filtering, to optional nginx autoconfiguration and authentication. For this reason you may initially experience bugs (very hard to test every type of configuration!). The new menu system has been worked on and tested for 6 months and we think it's stable enough to merge into the master branch for mainstream usage. The code still needs some work to make it easier to add new services and to not require copy pasting the same code for each new service. Also to make the menu system not be needed at all (so it can be automated with bash scripts).</p>"},{"location":"Updates/New-Menu-Release-Notes/#breaking-changes","title":"Breaking changes","text":"<p>There are a few changes that you need to be aware of:</p> <ul> <li>Docker Environmental <code>*.env</code> files are no longer a thing by default. Everything needed is specified in the service.yml file, you can still optionally use them though either with Custom Overrides or with the PostBuild script. Specific config files for certain services still work as they once did.</li> <li>Python 3, pip3, PyYAML and Blessed are all required to be installed.</li> <li>Not backwards compatible with old menu system. You will be able to switch back to the old menu system for a period of time by changing to the <code>old-menu</code> branch. It will be unmaintained except for critical updates. It will eventually be removed - but not before everyone is ready to leave it.</li> </ul> <p>Test that your backups are working before you switch. The <code>old-menu</code> branch will become avaiable just before the new menu is merged into master to ensure it has the latest commits applied.</p>"},{"location":"Updates/New-Menu-Release-Notes/#full-change-list","title":"Full change list","text":"<ul> <li>Menu and everything that goes with it rewritten in Python and Blessed</li> <li>Easy installation script</li> <li>All services rewritten to be compatible with PyYAML</li> <li>Optional port selection for services</li> <li>Issue checking for services before building</li> <li>Options for services now in menu (no more editing <code>service.yml</code> files)</li> <li>Automatic password generation for each service</li> <li>Pre and post scripts for customising services</li> <li>Removed env files</li> <li>Backup and restoring more streamlined</li> <li>Documentation updated for all services</li> <li>No longer needs to be installed in the home directory <code>~</code>.</li> </ul>"},{"location":"Updates/gcgarner-migration/","title":"Migrating from gcgarner to SensorsIot","text":"<p>These instructions explain how to migrate from gcgarner/IOTstack to SensorsIot/IOTstack.</p> <p>Migrating to SensorsIot/IOTstack was fairly easy when this repository was first forked from gcgarner/IOTstack. Unfortunately, what was a fairly simple switching procedure no longer works properly because conflicts have emerged.</p> <p>The probability of conflicts developing increases as a function of time since the fork. Conflicts were and are pretty much inevitable so a more involved procedure is needed.</p>"},{"location":"Updates/gcgarner-migration/#migration-steps","title":"Migration Steps","text":""},{"location":"Updates/gcgarner-migration/#step-1-check-your-assumptions","title":"Step 1 \u2013 Check your assumptions","text":"<p>Make sure that you are, actually, on gcgarner. Don't assume!</p> <pre><code>$ git remote -v\norigin  https://github.com/gcgarner/IOTstack.git (fetch)\norigin  https://github.com/gcgarner/IOTstack.git (push)\n</code></pre> <p>Do not proceed if you don't see those URLs!</p>"},{"location":"Updates/gcgarner-migration/#step-2-take-iotstack-down","title":"Step 2 \u2013 Take IOTstack down","text":"<p>Take your stack down. This is not strictly necessary but we'll be moving the goalposts a bit so it's better to be on the safe side.</p> <pre><code>$ cd ~/IOTstack\n$ docker-compose down\n</code></pre>"},{"location":"Updates/gcgarner-migration/#step-3-choose-your-migration-method","title":"Step 3 \u2013 Choose your migration method","text":"<p>There are two basic approaches to switching from gcgarner/IOTstack to SensorsIot/IOTstack:</p> <ul> <li>Migration by changing upstream repository</li> <li>Migration by clone and merge</li> </ul> <p>You can think of the first as \"working with git\" while the second is \"using brute force\".</p> <p>The first approach will work if you haven't tried any other migration steps and/or have not made too many changes to items in your gcgarner/IOTstack that are under git control.</p> <p>If you are already stuck or you try the first approach and get a mess, or it all looks far too hard to sort out, then try the Migration by clone and merge approach.</p>"},{"location":"Updates/gcgarner-migration/#migration-option-1-change-upstream-repository","title":"Migration Option 1 \u2013 change upstream repository","text":""},{"location":"Updates/gcgarner-migration/#check-for-local-changes","title":"Check for local changes","text":"<p>Make sure you are on the master branch (you probably are so this is just a precaution), and then see if Git thinks you have made any local changes:</p> <pre><code>$ cd ~/IOTstack\n$ git checkout master\n$ git status\n</code></pre> <p>If Git reports any \"modified\" files, those will probably get in the way of a successful migration so it's a good idea to get those out of the way.</p> <p>For example, suppose you edited <code>menu.sh</code> at some point. Git would report that as:</p> <pre><code>    modified:   menu.sh\n</code></pre> <p>The simplest way to deal with modified files is to rename them to move them out of the way, and then restore the original:</p> <ol> <li> <p>Rename your customised version by adding your initials to the end of the filename. Later, you can come back and compare your customised version with the version from GitHub and see if you want to preserve any changes.</p> <p>Here I'm assuming your initials are \"jqh\":</p> <pre><code>$ mv menu.sh menu.sh.jqh\n</code></pre> </li> <li> <p>Tell git to restore the unmodified version:</p> <pre><code>$ git checkout -- menu.sh\n</code></pre> </li> <li> <p>Now, repeat the Git command that complained about the file:</p> <pre><code>$ git status\n</code></pre> <p>The modified file will show up as \"untracked\" which is OK (ignore it)</p> <pre><code>Untracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    menu.sh.jqh\n</code></pre> </li> </ol>"},{"location":"Updates/gcgarner-migration/#synchronise-with-gcgarner-on-github","title":"Synchronise with gcgarner on GitHub","text":"<p>Make sure your local copy of gcgarner is in sync with GitHub.</p> <pre><code>$ git pull\n</code></pre>"},{"location":"Updates/gcgarner-migration/#get-rid-of-any-upstream-reference","title":"Get rid of any upstream reference","text":"<p>There may or may not be any \"upstream\" set. The most likely reason for this to happen is if you used your local copy as the basis of a Pull Request.</p> <p>The next command will probably return an error, which you should ignore. It's just a precaution.</p> <pre><code>$ git remote remove upstream\n</code></pre>"},{"location":"Updates/gcgarner-migration/#point-to-sensorsiot","title":"Point to SensorsIot","text":"<p>Change your local repository to point to SensorsIot.</p> <pre><code>$ git remote set-url origin https://github.com/SensorsIot/IOTstack.git\n</code></pre>"},{"location":"Updates/gcgarner-migration/#synchronise-with-sensorsiot-on-github","title":"Synchronise with SensorsIot on GitHub","text":"<p>This is where things can get a bit tricky so please read these instructions carefully before you proceed.</p> <p>When you run the next command, it will probably give you a small fright by opening a text-editor window. Don't panic - just keep reading. Now, run this command:</p> <pre><code>$ git pull -X theirs origin master\n</code></pre> <p>The text editor window will look something like this:</p> <pre><code>Merge branch 'master' of https://github.com/SensorsIot/IOTstack\n\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\n</code></pre> <p>The first line is a pre-prepared commit message, the remainder is boilerplate instructions which you can ignore.</p> <p>Exactly which text editor opens is a function of your <code>EDITOR</code> environment variable and the <code>core.editor</code> set in your global Git configuration. If you:</p> <ul> <li> <p>remember changing <code>EDITOR</code> and/or <code>core.editor</code> then, presumably, you will know how to interact with your chosen text editor. You don't need to make any changes to this file. All you need to do is save the file and exit;</p> </li> <li> <p>don't remember changing either <code>EDITOR</code> or <code>core.editor</code> then the editor will probably be the default <code>vi</code> (aka <code>vim</code>). You need to type \":wq\" (without the quotes) and then press return. The \":\" puts <code>vi</code> into command mode, the \"w\" says \"save the file\" and \"q\" means \"quit <code>vi</code>\". Pressing return runs the commands.  </p> </li> </ul> <p>Git will display a long list of stuff. It's very tempting to ignore it but it's a good idea to take a closer look, particularly for signs of error or any lines beginning with:</p> <pre><code>Auto-merging\n</code></pre> <p>At the time of writing, you can expect Git to mention these two files:</p> <pre><code>Auto-merging menu.sh\nAuto-merging .templates/zigbee2mqtt/service.yml\n</code></pre> <p>Those are known issues and the merge strategy <code>-X theirs</code> on the <code>git pull</code> command you have just executed deals with both, correctly, by preferring the SensorsIot version.</p> <p>Similar conflicts may emerge in future and those will probably be dealt with, correctly, by the same merge strategy. Nevertheless, you should still check the output very carefully for other signs of merge conflict so that you can at least be alive to the possibility that the affected files may warrant closer inspection.</p> <p>For example, suppose you saw:</p> <pre><code>Auto-merging .templates/someRandomService/service.yml\n</code></pre> <p>If you don't use <code>someRandomService</code> then you could safely ignore this on the basis that it was \"probably right\". However, if you did use that service and it started to misbehave after migration, you would know that the <code>service.yml</code> file was a good place to start looking for explanations.</p>"},{"location":"Updates/gcgarner-migration/#finish-with-a-pull","title":"Finish with a pull","text":"<p>At this point, only the migrated master branch is present on your local copy of the repository. The next command brings you fully in-sync with GitHub:</p> <pre><code>$ git pull\n</code></pre>"},{"location":"Updates/gcgarner-migration/#migration-option-2-clone-and-merge","title":"Migration Option 2 \u2013 clone and merge","text":"<p>If you have been following the process correctly, your IOTstack will already be down.</p>"},{"location":"Updates/gcgarner-migration/#rename-your-existing-iotstack-folder","title":"Rename your existing IOTstack folder","text":"<p>Move your old IOTstack folder out of the way, like this:</p> <pre><code>$ cd ~\n$ mv IOTstack IOTstack.old\n</code></pre> <p>Note:</p> <ul> <li>You should not need <code>sudo</code> for the <code>mv</code> command but it is OK to use it if necessary.</li> </ul>"},{"location":"Updates/gcgarner-migration/#fetch-a-clean-clone-of-sensorsiotiotstack","title":"Fetch a clean clone of SensorsIot/IOTstack","text":"<pre><code>$ git clone https://github.com/SensorsIot/IOTstack.git ~/IOTstack\n</code></pre> <p>Explore the result:</p> <pre><code>$ tree -aFL 1 --noreport ~/IOTstack\n/home/pi/IOTstack\n\u251c\u2500\u2500 .bash_aliases\n\u251c\u2500\u2500 .git/\n\u251c\u2500\u2500 .github/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .native/\n\u251c\u2500\u2500 .templates/\n\u251c\u2500\u2500 .tmp/\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 docs/\n\u251c\u2500\u2500 duck/\n\u251c\u2500\u2500 install.sh*\n\u251c\u2500\u2500 menu.sh*\n\u251c\u2500\u2500 mkdocs.yml\n\u2514\u2500\u2500 scripts/\n</code></pre> <p>Note:</p> <ul> <li>If the <code>tree</code> command is not installed for some reason, use <code>ls -A1F ~/IOTstack</code>.</li> </ul> <p>Observe what is not there:</p> <ul> <li>There is no <code>docker-compose.yml</code></li> <li>There is no <code>backups</code> directory</li> <li>There is no <code>services</code> directory</li> <li>There is no <code>volumes</code> directory</li> </ul> <p>From this, it should be self-evident that a clean checkout from GitHub is the factory for all IOTstack installations, while the contents of <code>backups</code>, <code>services</code>, <code>volumes</code> and <code>docker-compose.yml</code> represent each user's individual choices, configuration options and data.</p>"},{"location":"Updates/gcgarner-migration/#merge-old-into-new","title":"Merge old into new","text":"<p>Execute the following commands:</p> <pre><code>$ mv ~/IOTstack.old/docker-compose.yml ~/IOTstack\n$ mv ~/IOTstack.old/services ~/IOTstack\n$ sudo mv ~/IOTstack.old/volumes ~/IOTstack \n</code></pre> <p>You should not need to use <code>sudo</code> for the first two commands. However, if you get a permissions conflict on either, you should proceed like this:</p> <ul> <li> <p>docker-compose.yml</p> <pre><code>$ sudo mv ~/IOTstack.old/docker-compose.yml ~/IOTstack\n$ sudo chown pi:pi ~/IOTstack/docker-compose.yml\n</code></pre> </li> <li> <p>services</p> <pre><code>$ sudo mv ~/IOTstack.old/services ~/IOTstack\n$ sudo chown -R pi:pi ~/IOTstack/services\n</code></pre> </li> </ul> <p>There is no need to migrate the <code>backups</code> directory. You are better off creating it by hand:</p> <pre><code>$ mkdir ~/IOTstack/backups\n</code></pre>"},{"location":"Updates/gcgarner-migration/#step-4-choose-your-menu","title":"Step 4 \u2013 Choose your menu","text":"<p>If you have reached this point, you have migrated to SensorsIot/IOTstack where you are on the \"master\" branch. This implies \"new menu\".</p> <p>The choice of menu is entirely up to you. Differences include:</p> <ol> <li>New menu takes a lot more screen real-estate than old menu. If you do a fair bit of work on small screens (eg iPad) you might find it hard to work with new menu.</li> <li>New menu creates a large number of internal Docker networks whereas old menu has one internal network to rule them all. The practical consequence is that most users see error messages for networks being defined but not used, and occasionally run into problems where two containers can't talk to each other without tinkering with the networks. Neither of those happen under old menu. See Issue 245 if you want more information on this.</li> <li>New menu has moved the definition of environment variables into <code>docker-compose.yml</code>. Old menu keeps environment variables in \"environment files\" in <code>~/IOTstack/services</code>. There is no \"right\" or \"better\" about either approach. It's just something to be aware of.</li> <li>Under new menu, the <code>service.yml</code> files in <code>~/IOTstack/.templates</code> have all been left-shifted by two spaces. That means you can no longer use copy and paste to test containers - you're stuck with the extra work of re-adding the spaces. Again, this doesn't matter but you do need to be aware of it.</li> </ol> <p>What you give up when you choose old menu is summarised in the following. If a container appears on the right hand side but not the left then it is only available in new menu.</p> <pre><code>old-menu                master (new menu)\n\u251c\u2500\u2500 adminer             \u251c\u2500\u2500 adminer\n\u251c\u2500\u2500 blynk_server        \u251c\u2500\u2500 blynk_server\n\u251c\u2500\u2500 dashmachine         \u251c\u2500\u2500 dashmachine\n\u251c\u2500\u2500 deconz              \u251c\u2500\u2500 deconz\n\u251c\u2500\u2500 diyhue              \u251c\u2500\u2500 diyhue\n\u251c\u2500\u2500 domoticz            \u251c\u2500\u2500 domoticz\n\u251c\u2500\u2500 dozzle              \u251c\u2500\u2500 dozzle\n\u251c\u2500\u2500 espruinohub         \u251c\u2500\u2500 espruinohub\n                      &gt; \u251c\u2500\u2500 example_template\n\u251c\u2500\u2500 gitea               \u251c\u2500\u2500 gitea\n\u251c\u2500\u2500 grafana             \u251c\u2500\u2500 grafana\n\u251c\u2500\u2500 heimdall            \u251c\u2500\u2500 heimdall\n                      &gt; \u251c\u2500\u2500 home_assistant\n\u251c\u2500\u2500 homebridge          \u251c\u2500\u2500 homebridge\n\u251c\u2500\u2500 homer               \u251c\u2500\u2500 homer\n\u251c\u2500\u2500 influxdb            \u251c\u2500\u2500 influxdb\n\u251c\u2500\u2500 mariadb             \u251c\u2500\u2500 mariadb\n\u251c\u2500\u2500 mosquitto           \u251c\u2500\u2500 mosquitto\n\u251c\u2500\u2500 motioneye           \u251c\u2500\u2500 motioneye\n\u251c\u2500\u2500 nextcloud           \u251c\u2500\u2500 nextcloud\n\u251c\u2500\u2500 nodered             \u251c\u2500\u2500 nodered\n\u251c\u2500\u2500 openhab             \u251c\u2500\u2500 openhab\n\u251c\u2500\u2500 pihole              \u251c\u2500\u2500 pihole\n\u251c\u2500\u2500 plex                \u251c\u2500\u2500 plex\n\u251c\u2500\u2500 portainer           \u251c\u2500\u2500 portainer\n\u251c\u2500\u2500 portainer_agent     \u251c\u2500\u2500 portainer_agent\n\u251c\u2500\u2500 portainer-ce        \u251c\u2500\u2500 portainer-ce\n\u251c\u2500\u2500 postgres            \u251c\u2500\u2500 postgres\n\u251c\u2500\u2500 prometheus          \u251c\u2500\u2500 prometheus\n\u251c\u2500\u2500 python              \u251c\u2500\u2500 python\n\u251c\u2500\u2500 qbittorrent         \u251c\u2500\u2500 qbittorrent\n\u251c\u2500\u2500 rtl_433             \u251c\u2500\u2500 rtl_433\n\u251c\u2500\u2500 tasmoadmin          \u251c\u2500\u2500 tasmoadmin\n\u251c\u2500\u2500 telegraf            \u251c\u2500\u2500 telegraf\n\u251c\u2500\u2500 timescaledb         \u251c\u2500\u2500 timescaledb\n\u251c\u2500\u2500 transmission        \u251c\u2500\u2500 transmission\n\u251c\u2500\u2500 webthings_gateway   \u251c\u2500\u2500 webthings_gateway\n\u251c\u2500\u2500 wireguard           \u251c\u2500\u2500 wireguard\n\u2514\u2500\u2500 zigbee2mqtt         \u251c\u2500\u2500 zigbee2mqtt\n                      &gt; \u2514\u2500\u2500 zigbee2mqtt_assistant\n</code></pre> <p>You also give up the <code>compose-override.yml</code> functionality. On the other hand, Docker has its own <code>docker-compose.override.yml</code> which works with both menus.</p> <p>If you want to switch to the old menu:</p> <pre><code>$ git checkout old-menu\n</code></pre> <p>Any time you want to switch back to the new menu:</p> <pre><code>$ git checkout master\n</code></pre> <p>You can switch back and forth as much as you like and as often as you like. It's no harm, no foul. The branch you are on just governs what you see when you run:</p> <pre><code>$ ./menu.sh\n</code></pre> <p>Although you can freely change branches, it's probably not a good idea to try to mix-and-match your menus. Pick one menu and stick to it.</p> <p>Even so, nothing will change until you run your chosen menu to completion and allow it to generate a new <code>docker-compose.yml</code>.</p>"},{"location":"Updates/gcgarner-migration/#step-5-bring-up-your-stack","title":"Step 5 \u2013 Bring up your stack","text":"<p>Unless you have gotten ahead of yourself and have already run the menu (old or new) then nothing will have changed in the parts of your <code>~/IOTstack</code> folder that define your IOTstack implementation. You can safely:</p> <pre><code>$ docker-compose up -d\n</code></pre>"},{"location":"Updates/gcgarner-migration/#see-also","title":"See also","text":"<p>There is another gist Installing Docker for IOTstack which explains how to overcome problems with outdated Docker and Docker-Compose installations.</p> <p>Depending on the age of your gcgarner installation, you may run into problems which will be cured by working through that gist. </p>"},{"location":"Updates/migration-network-change/","title":"Migration: network change","text":"<p>Networking under both new menu (master branch) and old menu (old-menu branch) has undergone a significant change. This will not affect new users of IOTstack (who will adopt it automatically). Neither will it affect existing users who do not use the menu to maintain their stacks (see adopting networking changes by hand below).</p> <p>Users who do use the menu to maintain their stacks will also be unaffected until the next menu run, at which point it will be prudent to down your stack entirely and re-select all your containers. Downing the stack causes Docker to remove all associated networks as well as the containers.</p> <p>These changes mean that networking is identical under both old and new menus. To summarise the changes:</p> <ol> <li> <p>Only two internal networks are defined \u2013 as follows:</p> <ul> <li>\"default\" which adopts the name <code>iotstack_default</code> at runtime.</li> <li>\"nextcloud\" which adopts the name <code>iotstack_nextcloud</code> at runtime.</li> </ul> <p>If you are using docker-compose v2.0.0 or later then the <code>iotstack_nextcloud</code> network will only be instantiated if you select NextCloud as one of your services. Earlier versions of docker-compose instantiate all networks even if no service uses them (which is why you get those warnings at \"up\" time).</p> </li> <li> <p>The only service definitions which now have <code>networks:</code> directives are:</p> <ul> <li>NextCloud: joins the \"default\" and \"nextcloud\" networks; and</li> <li>NextCloud_DB: joins the \"nextcloud\" network.</li> </ul> <p>All other containers will join the \"default\" network, automatically, without needing any <code>networks:</code> directives.</p> </li> </ol>"},{"location":"Updates/migration-network-change/#adopting-networking-changes-by-hand","title":"adopting networking changes by hand","text":"<p>If you maintain your <code>docker-compose.yml</code> by hand, you can adopt the networking changes by doing the following:</p> <ol> <li>Take your stack down. This causes Docker to remove any existing networks. </li> <li> <p>Remove all <code>networks:</code> directives wherever they appear in your <code>docker-compose.yml</code>. That includes: </p> <ul> <li>the <code>networks:</code> directives in all service definitions; and</li> <li>the <code>networks:</code> specifications at the end of the file.</li> </ul> </li> <li> <p>Append the contents of the following file to your <code>docker-compose.yml</code>:</p> <pre><code>~/IOTstack/.templates/docker-compose-base.yml\n</code></pre> <p>For example:</p> <pre><code>$ cat ~/IOTstack/.templates/docker-compose-base.yml &gt;&gt;~/IOTstack/docker-compose.yml\n</code></pre> <p>The <code>docker-compose-base.yml</code> file is named <code>env.yml</code> in the old-menu branch.</p> </li> <li> <p>If you run the NextCloud service then:</p> <ul> <li> <p>Add these lines to the NextCloud service definition:</p> <pre><code>networks:\n  - default\n  - nextcloud\n</code></pre> </li> <li> <p>Add these lines to the NextCloud_DB service definition:</p> <pre><code>networks:\n  - nextcloud\n</code></pre> </li> </ul> </li> <li> <p>Bring up your stack. </p> </li> </ol>"}]}